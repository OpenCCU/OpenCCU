diff -ruN barebox-2012.02.0/arch/arm/boards/at91sam9260ek/env/bin/init_board barebox-2012.02.0-ccu2/arch/arm/boards/at91sam9260ek/env/bin/init_board
--- barebox-2012.02.0/arch/arm/boards/at91sam9260ek/env/bin/init_board	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/at91sam9260ek/env/bin/init_board	2013-01-14 12:46:26.000000000 +0100
@@ -1,18 +1,44 @@
 #!/bin/sh
 
-#PIOA_31
-gpio_get_value 63
+button_name="dfu_bp"
+button_wait=5
+
+product_id=0x1234
+vendor_id=0x4321
+
+dfu_config="/dev/nand0.barebox.bb(barebox)sr,/dev/nand0.kernel.bb(kernel)r,/dev/nand0.rootfs.bb(rootfs)r"
+
+if [ $at91_udc0.vbus != 1 ]
+then
+	echo "No USB Device cable plugged, normal boot"
+	exit
+fi
+
+gpio_get_value ${dfu_button}
 if [ $? != 0 ]
 then
+	autoboot_timeout=16
+	echo "enable tty over USB Device, increase the boot delay to ${autoboot_timeout}s"
+	usbserial
+	exit
+fi
+
+echo "${button_name} pressed detected wait ${button_wait}s"
+timeout -s -a ${button_wait}
+
+if [ $at91_udc0.vbus != 1 ]
+then
+	echo "No USB Device cable plugged, normal boot"
 	exit
 fi
 
-echo "BP4 pressed detected wait 5s"
-timeout -s -a 5
-gpio_get_value 63
+gpio_get_value ${dfu_button}
 if [ $? != 0 ]
 then
-	echo "BP4 released, normal boot"
+	echo "${button_name} released, normal boot"
+	autoboot_timeout=16
+	echo "enable tty over USB Device, increase the boot delay to ${autoboot_timeout}s"
+	usbserial
 	exit
 fi
 
@@ -20,4 +46,5 @@
 echo "Start DFU Mode"
 echo ""
 
-dfu /dev/self0(barebox)sr,/dev/nand0.kernel.bb(kernel)r,/dev/nand0.root.bb(root)r -P 0x1234 -V 0x4321
+led ds5 1
+dfu ${dfu_config} -P ${product_id} -V ${vendor_id}
diff -ruN barebox-2012.02.0/arch/arm/boards/at91sam9260ek/init.c barebox-2012.02.0-ccu2/arch/arm/boards/at91sam9260ek/init.c
--- barebox-2012.02.0/arch/arm/boards/at91sam9260ek/init.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/at91sam9260ek/init.c	2013-01-14 12:46:26.000000000 +0100
@@ -201,6 +201,37 @@
 	.pullup_pin	= -EINVAL,		/* pull-up driven by UDC */
 };
 
+struct gpio_led leds[] = {
+	{
+		.gpio	= AT91_PIN_PA6,
+		.active_low	= 1,
+		.led	= {
+			.name = "ds5",
+		},
+	}, {
+		.gpio	= AT91_PIN_PA9,
+		.led	= {
+			.name = "ds3",
+		},
+	},
+};
+
+static void __init ek_add_led(void)
+{
+	int i;
+
+#ifdef CONFIG_AT91_HAVE_2MMC
+	leds[0].gpio = AT91_PIN_PB8;
+	leds[1].gpio = AT91_PIN_PB9;
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(leds); i++) {
+		at91_set_gpio_output(leds[i].gpio, leds[i].active_low);
+		led_gpio_register(&leds[i]);
+	}
+	led_set_trigger(LED_TRIGGER_HEARTBEAT, &leds[1].led);
+}
+
 static int at91sam9260ek_mem_init(void)
 {
 	at91_add_device_sdram(64 * 1024 * 1024);
@@ -213,8 +244,10 @@
 {
 	at91_set_gpio_input(AT91_PIN_PA30, 1);	/* btn3 */
 	at91_set_deglitch(AT91_PIN_PA30, 1);
+	export_env_ull("dfu_button", AT91_PIN_PA30);
 	at91_set_gpio_input(AT91_PIN_PA31, 1);	/* btn4 */
 	at91_set_deglitch(AT91_PIN_PA31, 1);
+	export_env_ull("btn4", AT91_PIN_PA31);
 }
 
 static int at91sam9260ek_devices_init(void)
@@ -226,6 +259,7 @@
 	at91_add_device_udc(&ek_udc_data);
 	ek_usb_add_device_mci();
 	ek_add_device_buttons();
+	ek_add_led();
 
 	armlinux_set_bootparams((void *)(AT91_CHIPSELECT_1 + 0x100));
 	ek_set_board_type();
diff -ruN barebox-2012.02.0/arch/arm/boards/at91sam9263ek/config.h barebox-2012.02.0-ccu2/arch/arm/boards/at91sam9263ek/config.h
--- barebox-2012.02.0/arch/arm/boards/at91sam9263ek/config.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/at91sam9263ek/config.h	2013-01-14 12:46:26.000000000 +0100
@@ -61,15 +61,16 @@
 #define CONFIG_SYS_SDRC_TR_VAL2		1200		/* SDRAM_TR */
 
 /* setup SMC0, CS0 (NOR Flash) - 16-bit, 15 WS */
-#define CONFIG_SYS_SMC0_SETUP0_VAL					\
+#define CONFIG_SYS_SMC_CS	0
+#define CONFIG_SYS_SMC_SETUP_VAL					\
 		(AT91_SMC_NWESETUP_(10) | AT91_SMC_NCS_WRSETUP_(10) |	\
 		 AT91_SMC_NRDSETUP_(10) | AT91_SMC_NCS_RDSETUP_(10))
-#define CONFIG_SYS_SMC0_PULSE0_VAL					\
+#define CONFIG_SYS_SMC_PULSE_VAL					\
 		(AT91_SMC_NWEPULSE_(11) | AT91_SMC_NCS_WRPULSE_(11) |	\
 		 AT91_SMC_NRDPULSE_(11) | AT91_SMC_NCS_RDPULSE_(11))
-#define CONFIG_SYS_SMC0_CYCLE0_VAL	\
+#define CONFIG_SYS_SMC_CYCLE_VAL	\
 		(AT91_SMC_NWECYCLE_(22) | AT91_SMC_NRDCYCLE_(22))
-#define CONFIG_SYS_SMC0_MODE0_VAL				\
+#define CONFIG_SYS_SMC_MODE_VAL					\
 		(AT91_SMC_READMODE | AT91_SMC_WRITEMODE |	\
 		 AT91_SMC_DBW_16 |				\
 		 AT91_SMC_TDFMODE |				\
diff -ruN barebox-2012.02.0/arch/arm/boards/beagle/board.c barebox-2012.02.0-ccu2/arch/arm/boards/beagle/board.c
--- barebox-2012.02.0/arch/arm/boards/beagle/board.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/beagle/board.c	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,319 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Raghavendra KH <r-khandenahally@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * @file
+ * @brief Beagle Specific Board Initialization routines
+ */
+
+/**
+ * @page ti_beagle Texas Instruments Beagle Board
+ *
+ * FileName: arch/arm/boards/omap/board-beagle.c
+ *
+ * Beagle Board from Texas Instruments as described here:
+ * http://www.beagleboard.org
+ *
+ * This board is based on OMAP3530.
+ * More on OMAP3530 (including documentation can be found here):
+ * http://focus.ti.com/docs/prod/folders/print/omap3530.html
+ *
+ * This file provides initialization in two stages:
+ * @li boot time initialization - do basics required to get SDRAM working.
+ * This is run from SRAM - so no case constructs and global vars can be used.
+ * @li run time initialization - this is for the rest of the initializations
+ * such as flash, uart etc.
+ *
+ * Boot time initialization includes:
+ * @li SDRAM initialization.
+ * @li Pin Muxing relevant for Beagle.
+ *
+ * Run time initialization includes
+ * @li serial @ref serial_ns16550.c driver device definition
+ *
+ * Originally from arch/arm/boards/omap/board-sdp343x.c
+ */
+
+#include <common.h>
+#include <console.h>
+#include <init.h>
+#include <driver.h>
+#include <sizes.h>
+#include <io.h>
+#include <ns16550.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/silicon.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/control.h>
+#include <mach/omap3-mux.h>
+#include <mach/gpmc.h>
+#include <mach/gpmc_nand.h>
+#include <mach/ehci.h>
+#include <i2c/i2c.h>
+#include <linux/err.h>
+#include <usb/ehci.h>
+#include <mach/xload.h>
+
+/******************** Board Boot Time *******************/
+
+/**
+ * @brief Do the SDRC initialization for 128Meg Micron DDR for CS0
+ *
+ * @return void
+ */
+static void sdrc_init(void)
+{
+	/* SDRAM software reset */
+	/* No idle ack and RESET enable */
+	writel(0x1A, SDRC_REG(SYSCONFIG));
+	sdelay(100);
+	/* No idle ack and RESET disable */
+	writel(0x18, SDRC_REG(SYSCONFIG));
+
+	/* SDRC Sharing register */
+	/* 32-bit SDRAM on data lane [31:0] - CS0 */
+	/* pin tri-stated = 1 */
+	writel(0x00000100, SDRC_REG(SHARING));
+
+	/* ----- SDRC Registers Configuration --------- */
+	/* SDRC_MCFG0 register */
+	writel(0x02584099, SDRC_REG(MCFG_0));
+
+	/* SDRC_RFR_CTRL0 register */
+	writel(0x54601, SDRC_REG(RFR_CTRL_0));
+
+	/* SDRC_ACTIM_CTRLA0 register */
+	writel(0xA29DB4C6, SDRC_REG(ACTIM_CTRLA_0));
+
+	/* SDRC_ACTIM_CTRLB0 register */
+	writel(0x12214, SDRC_REG(ACTIM_CTRLB_0));
+
+	/* Disble Power Down of CKE due to 1 CKE on combo part */
+	writel(0x00000081, SDRC_REG(POWER));
+
+	/* SDRC_MANUAL command register */
+	/* NOP command */
+	writel(0x00000000, SDRC_REG(MANUAL_0));
+	/* Precharge command */
+	writel(0x00000001, SDRC_REG(MANUAL_0));
+	/* Auto-refresh command */
+	writel(0x00000002, SDRC_REG(MANUAL_0));
+	/* Auto-refresh command */
+	writel(0x00000002, SDRC_REG(MANUAL_0));
+
+	/* SDRC MR0 register Burst length=4 */
+	writel(0x00000032, SDRC_REG(MR_0));
+
+	/* SDRC DLLA control register */
+	writel(0x0000000A, SDRC_REG(DLLA_CTRL));
+
+	return;
+}
+
+/**
+ * @brief Do the pin muxing required for Board operation.
+ * We enable ONLY the pins we require to set. OMAP provides pins which do not
+ * have alternate modes. Such pins done need to be set.
+ *
+ * See @ref MUX_VAL for description of the muxing mode.
+ *
+ * @return void
+ */
+static void mux_config(void)
+{
+	/* SDRC_D0 - SDRC_D31 default mux mode is mode0 */
+
+	/* GPMC */
+	MUX_VAL(CP(GPMC_A1), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A2), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A3), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A4), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A5), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A6), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A7), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A8), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A9), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A10), (IDIS | PTD | DIS | M0));
+
+	/* D0-D7 default mux mode is mode0 */
+	MUX_VAL(CP(GPMC_D8), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D9), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D10), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D11), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D12), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D13), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D14), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D15), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_CLK), (IDIS | PTD | DIS | M0));
+	/* GPMC_NADV_ALE default mux mode is mode0 */
+	/* GPMC_NOE default mux mode is mode0 */
+	/* GPMC_NWE default mux mode is mode0 */
+	/* GPMC_NBE0_CLE default mux mode is mode0 */
+	MUX_VAL(CP(GPMC_NBE0_CLE), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NBE1), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NWP), (IEN | PTD | DIS | M0));
+	/* GPMC_WAIT0 default mux mode is mode0 */
+	MUX_VAL(CP(GPMC_WAIT1), (IEN | PTU | EN | M0));
+
+	/* SERIAL INTERFACE */
+	MUX_VAL(CP(UART3_CTS_RCTX), (IEN | PTD | EN | M0));
+	MUX_VAL(CP(UART3_RTS_SD), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART3_RX_IRRX), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(UART3_TX_IRTX), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_CLK), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_STP), (IDIS | PTU | EN | M0));
+	MUX_VAL(CP(HSUSB0_DIR), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_NXT), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA0), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA1), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA2), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA3), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA4), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA5), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA6), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(HSUSB0_DATA7), (IEN | PTD | DIS | M0));
+	/* I2C1_SCL default mux mode is mode0 */
+	/* I2C1_SDA default mux mode is mode0 */
+	/* USB EHCI (port 2) */
+	MUX_VAL(CP(MCSPI1_CS3),		(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_CLK),		(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_CS0),		(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(MCSPI2_CS1),		(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D11_ES2),	(IDIS | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTU | DIS | M3));
+	MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M4)) /*GPIO_147*/;
+}
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+static int beagle_board_init(void)
+{
+	int in_sdram = running_in_sdram();
+
+	omap3_core_init();
+
+	mux_config();
+	/* Dont reconfigure SDRAM while running in SDRAM! */
+	if (!in_sdram)
+		sdrc_init();
+
+	return 0;
+}
+pure_initcall(beagle_board_init);
+
+/******************** Board Run Time *******************/
+
+#ifdef CONFIG_DRIVER_SERIAL_NS16550
+
+static struct NS16550_plat serial_plat = {
+	.clock = 48000000,      /* 48MHz (APLL96/2) */
+	.shift = 2,
+};
+
+/**
+ * @brief UART serial port initialization - remember to enable COM clocks in
+ * arch
+ *
+ * @return result of device registration
+ */
+static int beagle_console_init(void)
+{
+	/* Register the serial port */
+	add_ns16550_device(-1, OMAP_UART3_BASE, 1024, IORESOURCE_MEM_8BIT,
+			   &serial_plat);
+
+	return 0;
+}
+console_initcall(beagle_console_init);
+#endif /* CONFIG_DRIVER_SERIAL_NS16550 */
+
+#ifdef CONFIG_USB_EHCI_OMAP
+static struct omap_hcd omap_ehci_pdata = {
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+	.phy_reset  = 1,
+	.reset_gpio_port[0]  = -EINVAL,
+	.reset_gpio_port[1]  = 147,
+	.reset_gpio_port[2]  = -EINVAL
+};
+
+static struct ehci_platform_data ehci_pdata = {
+	.flags = 0,
+};
+#endif /* CONFIG_USB_EHCI_OMAP */
+
+static struct i2c_board_info i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("twl4030", 0x48),
+	},
+};
+
+static int beagle_mem_init(void)
+{
+	arm_add_mem_device("ram0", 0x80000000, 128 * 1024 * 1024);
+
+	return 0;
+}
+mem_initcall(beagle_mem_init);
+
+static int beagle_devices_init(void)
+{
+	i2c_register_board_info(0, i2c_devices, ARRAY_SIZE(i2c_devices));
+	add_generic_device("i2c-omap", -1, NULL, OMAP_I2C1_BASE, SZ_4K,
+			   IORESOURCE_MEM, NULL);
+
+#ifdef CONFIG_USB_EHCI_OMAP
+	if (ehci_omap_init(&omap_ehci_pdata) >= 0)
+		add_usb_ehci_device(-1, OMAP_EHCI_BASE,
+				    OMAP_EHCI_BASE + 0x10, &ehci_pdata);
+#endif /* CONFIG_USB_EHCI_OMAP */
+#ifdef CONFIG_OMAP_GPMC
+	/* WP is made high and WAIT1 active Low */
+	gpmc_generic_init(0x10);
+#endif
+	gpmc_generic_nand_devices_init(0, 16, OMAP_ECC_HAMMING_CODE_HW_ROMCODE);
+
+	add_generic_device("omap-hsmmc", -1, NULL, OMAP_MMC1_BASE, SZ_4K,
+			   IORESOURCE_MEM, NULL);
+
+	armlinux_set_bootparams((void *)0x80000100);
+	armlinux_set_architecture(MACH_TYPE_OMAP3_BEAGLE);
+
+	return 0;
+}
+device_initcall(beagle_devices_init);
diff -ruN barebox-2012.02.0/arch/arm/boards/beagle/config.h barebox-2012.02.0-ccu2/arch/arm/boards/beagle/config.h
--- barebox-2012.02.0/arch/arm/boards/beagle/config.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/beagle/config.h	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,21 @@
+/**
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#endif	/* __CONFIG_H */
diff -ruN barebox-2012.02.0/arch/arm/boards/beagle/Makefile barebox-2012.02.0-ccu2/arch/arm/boards/beagle/Makefile
--- barebox-2012.02.0/arch/arm/boards/beagle/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/beagle/Makefile	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1 @@
+obj-y += board.o
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/ccu2.c barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/ccu2.c
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/ccu2.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/ccu2.c	2013-02-14 07:54:40.000000000 +0100
@@ -0,0 +1,416 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <common.h>
+#include <init.h>
+#include <environment.h>
+#include <mci.h>
+#include <net.h>
+#include <nand.h>
+#include <partition.h>
+
+#include <asm/io.h>
+#include <asm/armlinux.h>
+
+#include <fec.h>
+#include <mach/gpio.h>
+#include <mach/imx-regs.h>
+#include <mach/iomux-imx28.h>
+#include <mach/clock.h>
+#include <mach/mci.h>
+#include <mach/gpmi.h>
+#include <mach/watchdog.h>
+
+#include <generated/mach-types.h>
+
+
+/* setup the CPU card internal signals */
+static uint32_t const		ccu2_pad_setup[] = {
+	/*
+	 * Note: To setup the external phy in a manner the phy supports, its
+	 * configuration is divided into a small part here at the beginning of
+	 * the pad configuration and the remaining configuration at the end of
+	 * these definitions.  Here: Switch on the power supply to the
+	 * external phy, but keep its reset line low.
+	 */
+	LCD_WR_RWN_GPIO | VE_3_3V | BITKEEPER(1) | GPIO_IN, /* ENET0-INT */
+
+	ENET_CLK    | VE_3_3V | BITKEEPER(0),
+
+	ENET0_TX_EN | VE_3_3V | PULLUP(1),
+	ENET0_MDC   | VE_3_3V | PULLUP(1),
+	ENET0_MDIO  | VE_3_3V | PULLUP(0), /* external pullup */
+	ENET0_TXD0  | VE_3_3V | PULLUP(1),
+	ENET0_TXD1  | VE_3_3V | PULLUP(1),
+
+	/*
+	 * force the mod pins to a specific level
+	 * '111' means: "All capable. Auto-negotiation enabled".
+	 * For other values refer LAN8710's datasheet,
+	 * chapter "Mode Bus - MODE[2:0]"
+	 */
+	ENET0_RXD0_GPIO  | VE_3_3V | GPIO_IN | PULLUP(1), /* MOD0 */
+	ENET0_RXD1_GPIO  | VE_3_3V | GPIO_IN | PULLUP(1), /* MOD1 */
+	ENET0_RX_EN_GPIO | VE_3_3V | GPIO_IN | PULLUP(1), /* MOD2 */
+
+	/* deassert ETH0 reset */
+	AUART0_CTS_GPIO  | VE_3_3V | BITKEEPER(1) | GPIO_OUT | GPIO_VALUE(1),
+
+
+	/* MCI interface */
+	SSP0_D0 | VE_3_3V | PULLUP(1),
+	SSP0_D1 | VE_3_3V | PULLUP(1),
+	SSP0_D2 | VE_3_3V | PULLUP(1),
+	SSP0_D3 | VE_3_3V | PULLUP(1),
+	SSP0_D4_GPIO | VE_3_3V | GPIO_IN | PULLUP(1),	/* unused */
+	SSP0_D5_GPIO | VE_3_3V | GPIO_IN | PULLUP(1),	/* unused */
+	SSP0_D6_GPIO | VE_3_3V | GPIO_IN | PULLUP(1),	/* unused */
+	SSP0_D7_GPIO | VE_3_3V | GPIO_IN | PULLUP(1),	/* unused */
+	SSP0_CMD | VE_3_3V | PULLUP(1),
+	SSP0_SCK | VE_3_3V | BITKEEPER(1),
+	PWM3_GPIO | VE_3_3V | GPIO_OUT | GPIO_VALUE(1),	/* SD-PWR-EN */
+
+	/* SPI interface to Atmel IC; keep signals floating because both the
+	 * mx28 and the avr can be SPI masters */
+	SSP2_SCK_GPIO | GPIO_IN | VE_3_3V | BITKEEPER(0),
+	SSP2_MOSI_GPIO | GPIO_IN | VE_3_3V | PULLUP(0),
+	SSP2_MISO_GPIO | GPIO_IN | VE_3_3V | PULLUP(0),
+
+	SSP2_SS0_GPIO | VE_3_3V | PULLUP(0),
+	SSP2_SS1_GPIO | VE_3_3V | PULLUP(0),
+	SSP2_SS2_GPIO | GPIO_OUT | GPIO_VALUE(0) | VE_3_3V | PULLUP(1),
+
+	/* I2C interface */
+	I2C0_SCL | VE_3_3V | BITKEEPER(1),
+	I2C0_SDA | VE_3_3V | BITKEEPER(1),
+
+	/* AUART0 */
+	AUART0_RX | VE_3_3V | BITKEEPER(1),
+	AUART0_TX | VE_3_3V | BITKEEPER(1),
+
+	/* AUART1 */
+	AUART1_RX | VE_3_3V | PULLUP(1),
+	AUART1_TX | VE_3_3V | PULLUP(1),
+
+	/* KEY/LED */
+	SAIF0_BITCLK_GPIO | VE_3_3V | GPIO_IN, /* KEY */
+	SAIF0_LRCLK_GPIO | VE_3_3V | GPIO_OUT | GPIO_VALUE(1),	/* LED-1 */
+	SAIF0_MCLK_GPIO | VE_3_3V | GPIO_OUT | GPIO_VALUE(1),	/* LED-0 */
+	SAIF0_SDATA0_GPIO | VE_3_3V | GPIO_OUT | GPIO_VALUE(1), /* LED-2 */
+
+	/* DUART */
+	PWM0_DUART_RX | VE_3_3V | BITKEEPER(1),
+	PWM1_DUART_TX | VE_3_3V | BITKEEPER(1),
+
+	/* MP */
+	SAIF1_SDATA0_GPIO | VE_3_3V | GPIO_OUT | BITKEEPER(1),	/* MP111 */
+	PWM2_GPIO | VE_3_3V | GPIO_OUT | PULLUP(1),		/* MP304 */
+	PWM4_GPIO | VE_3_3V | GPIO_OUT | BITKEEPER(1),		/* MP305 */
+	GPMI_CE1N_GPIO | VE_3_3V | GPIO_IN | PULLUP(1),		/* MP302 */
+	GPMI_READY1_GPIO | VE_3_3V | GPIO_IN | PULLUP(1),	/* MP303 */
+
+	/* USB */
+	LCD_RD_E_GPIO | VE_3_3V | GPIO_OUT | GPIO_VALUE(0),  /* USB1-EN */
+	AUART0_RTS_GPIO | VE_3_3V | GPIO_IN | GPIO_VALUE(1), /* USB0-EN */
+
+	/* GPMI */
+	GPMI_ALE | VE_3_3V | PULLUP(0),
+	GPMI_CE0N | VE_3_3V | PULLUP(0),
+	GPMI_CLE | VE_3_3V | PULLUP(0),
+	GPMI_RDN | VE_3_3V | PULLUP(0),
+	GPMI_READY0 | VE_3_3V | PULLUP(0),
+	GPMI_WRN | VE_3_3V | PULLUP(0),
+	GPMI_D0 |  VE_3_3V | PULLUP(0),
+	GPMI_D1 |  VE_3_3V | PULLUP(0),
+	GPMI_D2 |  VE_3_3V | PULLUP(0),
+	GPMI_D3 |  VE_3_3V | PULLUP(0),
+	GPMI_D4 |  VE_3_3V | PULLUP(0),
+	GPMI_D5 |  VE_3_3V | PULLUP(0),
+	GPMI_D6 |  VE_3_3V | PULLUP(0),
+	GPMI_D7 |  VE_3_3V | PULLUP(0),
+
+	GPMI_RESETN | VE_3_3V | PULLUP(0),
+};
+
+/* setup the CPU card internal signals */
+static uint32_t const		ccu2_pad_late_setup[] = {
+	/* ethernet initialization; part 2 */
+
+	/* release the reset ('mod' pins get latched) */
+	AUART0_CTS_GPIO | VE_3_3V | BITKEEPER(1) | GPIO_OUT | GPIO_VALUE(1),
+
+	/* right now the 'mod' pins are in their native mode */
+	ENET0_RXD0  | VE_3_3V | PULLUP(0),
+	ENET0_RXD1  | VE_3_3V | PULLUP(0),
+	ENET0_RX_EN | VE_3_3V | PULLUP(0),
+};
+
+static int ccu2_mem_init(void)
+{
+	arm_add_mem_device("ram0", IMX_MEMORY_BASE, 256 * 1024 * 1024);
+
+	return 0;
+}
+mem_initcall(ccu2_mem_init);
+
+static uint64_t	board_sernum;
+
+static void ccu2_set_ethaddr_factory(uint32_t const ocotp[4])
+{
+	if (ocotp[0] != 0 && ocotp[0] != 0xbadabada &&
+	    ocotp[1] != 0 && ocotp[1] != 0xbadabada) {
+		unsigned char	mac[6] = {
+			[0] = (ocotp[0] >> 24) & 0xffu,
+			[1] = (ocotp[0] >> 16) & 0xffu,
+			[2] = (ocotp[0] >>  8) & 0xffu,
+			[3] = (ocotp[0] >>  0) & 0xffu,
+			[4] = (ocotp[1] >> 24) & 0xffu,
+			[5] = (ocotp[1] >> 16) & 0xffu,
+		};
+
+		eth_register_ethaddr(0, mac);
+	} else if (board_sernum != 0 &&
+		   board_sernum != 0xbadabadabadabadaULL) {
+		unsigned char	mac[6] = {
+			[0] = 0x02,
+			[1] = (unsigned int)(board_sernum >> 32) & 0xffu,
+			[2] = (unsigned int)(board_sernum >> 24) & 0xffu,
+			[3] = (unsigned int)(board_sernum >> 16) & 0xffu,
+			[4] = (unsigned int)(board_sernum >>  8) & 0xffu,
+			[5] = (unsigned int)(board_sernum >>  0) & 0xffu,
+		};
+
+		eth_register_ethaddr(0, mac);
+	}
+}
+
+static void ccu2_set_eq3_id(char *id_str, uint32_t const ocotp[4])
+{
+	size_t		i;
+
+	id_str[0] = (ocotp[1] >>  8) & 0xffu;
+	id_str[1] = (ocotp[1] >>  0) & 0xffu;
+	id_str[2] = (ocotp[2] >> 24) & 0xffu;
+	id_str[3] = (ocotp[2] >> 16) & 0xffu;
+	id_str[4] = (ocotp[2] >>  8) & 0xffu;
+	id_str[5] = (ocotp[2] >>  0) & 0xffu;
+	id_str[6] = (ocotp[3] >> 24) & 0xffu;
+	id_str[7] = (ocotp[3] >> 16) & 0xffu;
+	id_str[8] = (ocotp[3] >>  8) & 0xffu;
+	id_str[9] = (ocotp[3] >>  0) & 0xffu;
+
+	for (i = 0; i < 10; ++i) {
+		if (id_str[i] < 32 || id_str[i] > 127) {
+			id_str[0] = '\0';
+			return;
+		}
+	}
+}
+
+static struct mxs_mci_platform_data mci0_pdata = {
+	.caps = MMC_MODE_4BIT,
+	.voltages = MMC_VDD_32_33 | MMC_VDD_33_34,	/* fixed to 3.3 V */
+	.f_min = 400 * 1000,
+	.f_max = 25000000,
+};
+
+/* PhyAD[0..2]=0, RMIISEL=1 */
+static struct fec_platform_data fec_info = {
+	.xcv_type = RMII,
+	.phy_addr = 0,
+};
+
+struct mxs_nand_platform_data const	nand_info = {
+	.ns_data_setup = 25,
+	.ns_data_hold = 15,
+	.ns_address_setup = 150,
+	.ns_busy_timeout = 700000,
+};
+
+static int ccu2_core_init(void)
+{
+	int 		i;
+
+	/* initizalize gpios */
+	for (i = 0; i < ARRAY_SIZE(ccu2_pad_setup); i++)
+		imx_gpio_mode(ccu2_pad_setup[i]);
+
+	watchdog_prepare();
+	watchdog_trigger(5000);
+
+	return 0;
+}
+core_initcall(ccu2_core_init);
+
+static int ccu2_console_init(void)
+{
+	if (1)
+	add_generic_device("stm_serial", 0, NULL, IMX_DBGUART_BASE, 8192,
+			   IORESOURCE_MEM, NULL);
+
+	if (0)
+	add_generic_device("imxapp_serial", 0, NULL, IMX_UART0_BASE, 0x100,
+			   IORESOURCE_MEM, NULL);
+
+	return 0;
+}
+console_initcall(ccu2_console_init);
+
+static int ccu2_devices_init(void)
+{
+	int 		i;
+	uint32_t	ocotp_cust[4];
+	char		eq3_id[12] = { [10] = ' ', [11] = '\0' };
+	unsigned int	loops;
+
+	writel((1u << 12), 0x8002c004);	/* HW_OCOTP_CTRL |= RD_BANK_OPEN */
+
+	/* enable IOCLK0 to run at the PLL frequency */
+	imx_set_ioclk(0, 480000000);
+	/* run the SSP unit clock at 100 MHz */
+	imx_set_sspclk(0, 100000000, 1);
+	/* run the SSP unit clock at 100 MHz */
+	imx_set_sspclk(1, 100000000, 1);
+
+	imx_set_gpmiclk(60000000, 0);
+
+	imx_enable_enetclk();
+
+	/* {{{ slot for releasing J301 */
+	udelay(500000);
+	watchdog_prepare();
+	watchdog_trigger(5000);
+	/* }}} */
+
+	armlinux_set_bootparams((void *)IMX_MEMORY_BASE + 0x100);
+	armlinux_set_architecture(MACH_TYPE_ELV_CCU2);
+
+	/* delay access to OCOTP */
+	while (readl(0x8002c000) & (1u << 8))
+		;			/* noop */
+
+	ocotp_cust[0]  = readl(0x8002c020);
+	ocotp_cust[1]  = readl(0x8002c030);
+	ocotp_cust[2]  = readl(0x8002c040);
+	ocotp_cust[3]  = readl(0x8002c050);
+
+	/* \todo: do this? do we reveal secrets? */
+	/* \todo: fixme! manual says, UN2 is hi-word but this seems to be
+	 * equal to OPS3 */
+	board_sernum   = readl(0x8002c160);	/* HW_OCOTP_OPS3 */
+	board_sernum <<= 32;
+	board_sernum  |= readl(0x8002c150);	/* HW_OCOTP_OPS2 */
+
+	writel((1u << 12), 0x8002c008);	/* HW_OCOTP_CTRL &= ~RD_BANK_OPEN */
+
+	armlinux_set_serial(board_sernum);
+	ccu2_set_ethaddr_factory(ocotp_cust);
+	ccu2_set_eq3_id(eq3_id, ocotp_cust);
+
+	/* ensure that pins are driven for t_csh = 1ns but not more than
+	 * t_odad = 800ns */
+	gpio_set_value(3*32 + 2, 0);	/* ENET-nRST */
+	udelay(10000);
+	gpio_set_value(3*32 + 2, 1);	/* ENET-nRST */
+
+	/* initizalize gpios */
+	for (i = 0; i < ARRAY_SIZE(ccu2_pad_late_setup); i++)
+		imx_gpio_mode(ccu2_pad_late_setup[i]);
+
+	/* create devices */
+
+	add_generic_device("mxs_mci", 0, NULL, IMX_SSP0_BASE, 0x2000,
+			   IORESOURCE_MEM, &mci0_pdata);
+
+	add_generic_device("fec_imx", 0, NULL, IMX_FEC0_BASE, 0x4000,
+			   IORESOURCE_MEM, &fec_info);
+
+	add_generic_device("mxs_nand", 0, NULL, 0, 0, IORESOURCE_MEM,
+			   (void *)&nand_info);
+
+	imx_dump_clocks();
+
+	printf("Board serial: %s(%08x:%08x); boot flags %02x\n",
+	       eq3_id,
+	       (unsigned int)(board_sernum >> 32),
+	       (unsigned int)(board_sernum >>  0),
+	       readl(0x80056070) & 0xffu);
+
+	return 0;
+}
+device_initcall(ccu2_devices_init);
+
+static struct {
+	size_t		size;
+	char const	*name;
+	char const	*bb_name;
+} const		PARTITIONS[] = {
+	{      1024 * 1024, NULL, NULL }, /* FCB */
+	{      1024 * 1024, NULL, NULL }, /* BBT */
+	{      1024 * 1024, "env0_raw",    "env0" },
+	{      1536 * 1024, "bootstream0", "bootstream0.bb" },
+	{ 6 * 1024 * 1024, "bootstream1", "bootstream1.bb" },
+};
+
+static int ccu2_late_init(void)
+{
+	size_t		offset = 0;
+	size_t		i;
+	int		rc = 0;
+	unsigned int	ctrl_usb = readl(0x80080140);
+
+	/* disconnect USB client */
+	if (ctrl_usb & (1u << 0)) {
+		writel(ctrl_usb & ~(1u << 0), 0x80080140);
+		while (readl(0x80080140) & (1u << 0))
+			;		/* noop */
+		writel((ctrl_usb & ~(1u << 0)) | (1u << 1), 0x80080140);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(PARTITIONS); ++i) {
+		BUG_ON(!PARTITIONS[i].name && PARTITIONS[i].bb_name);
+
+		if (PARTITIONS[i].name) {
+			rc = devfs_add_partition("nand0", offset,
+						 PARTITIONS[i].size,
+						 PARTITION_FIXED,
+						 PARTITIONS[i].name);
+			if (rc < 0)
+				printk(KERN_ERR
+				       "failed to add partition '%s': %d\n",
+				       PARTITIONS[i].name, rc);
+		}
+
+		if (PARTITIONS[i].bb_name && !rc) {
+
+			rc = dev_add_bb_dev(PARTITIONS[i].name,
+					    PARTITIONS[i].bb_name);
+
+			if (rc < 0)
+				printk(KERN_ERR
+				       "failed to add bb partition '%s': %d\n",
+				       PARTITIONS[i].bb_name, rc);
+		}
+
+		if (rc < 0)
+			break;
+
+		offset += PARTITIONS[i].size;
+	}
+
+	return rc;
+}
+late_initcall(ccu2_late_init);
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/config.h barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/config.h
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/config.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/config.h	2013-01-14 12:46:26.000000000 +0100
@@ -0,0 +1,22 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_BAREBOX_BOARD_EQ3CCU2_CONFIG_H
+#define H_BAREBOX_BOARD_EQ3CCU2_CONFIG_H
+
+
+
+#endif	/* H_BAREBOX_BOARD_EQ3CCU2_CONFIG_H */
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/bin/boot_board barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/bin/boot_board
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/bin/boot_board	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/bin/boot_board	2013-01-14 12:46:26.000000000 +0100
@@ -0,0 +1,6 @@
+#! /bin/sh
+
+if [ x$rootfs_loc != xnet ]; then
+   echo "Setting watchdog..."
+   watchdog 120000
+fi
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/bin/bootstream barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/bin/bootstream
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/bin/bootstream	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/bin/bootstream	2013-01-14 12:46:26.000000000 +0100
@@ -0,0 +1,27 @@
+#! /bin/sh
+
+num=0
+image=
+mode=tftp
+xname=eq3-ccu2.sb
+
+. /env/config
+
+while getopt "i:n:" Option; do
+    if [ ${Option} = i ]; then
+	num=${OPTARG}
+        xname=eq3-ccu2-${num}.sb
+    elif [ ${Option} = n ]; then
+        image=${OPTARG}
+    else
+	echo "usage: bootstream [-i <num>] [-n <name>]"
+	exit 1
+    fi
+done
+
+if [ x${image} = x ]; then
+    image=${xname}
+fi
+
+part=/dev/bootstream${num}.bb
+. /env/bin/_update || exit 1
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/bin/init_board barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/bin/init_board
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/bin/init_board	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/bin/init_board	2013-01-14 12:46:26.000000000 +0100
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+watchdog 120000
+login -t ${autoboot_timeout}
+
+# clear secondary boot flag and pending boot flags
+mw 0x80056078 0x20000002
+
+watchdog off
+exit
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/config barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/config
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/config	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/config	2013-02-14 16:01:33.000000000 +0100
@@ -0,0 +1,63 @@
+### --*- sh -*--
+machine=ccu2
+baseboard=eq3-ccu2
+
+cfgmode=productive
+#cfgmode=development
+
+# use 'dhcp' to do dhcp in barebox and in kernel
+# use 'none' if you want to skip kernel ip autoconfiguration
+#ip=dhcp
+
+# or set your networking parameters here
+#eth0.ipaddr=a.b.c.d
+#eth0.ethaddr=de:ad:be:ef:00:00
+#eth0.netmask=a.b.c.d
+#eth0.serverip=a.b.c.d
+#eth0.gateway=a.b.c.d
+
+# can be either 'tftp', 'nfs', 'nand', 'nor' or 'disk'
+#kernel_loc=tftp
+# can be either 'net', 'nand', 'nor', 'disk' or 'initrd'
+#rootfs_loc=net
+
+test -n "$cfgmode_" || cfgmode_=$cfgmode
+export cfgmode_
+
+if [ $cfgmode_ = productive ]; then
+    ip=none
+    kernel_loc=nand
+    rootfs_loc=nand
+elif [ $cfgmode_ = development ]; then
+    ip=dhcp
+    kernel_loc=tftp
+    rootfs_loc=net
+fi
+
+# can be either 'jffs2' or 'ubifs'
+rootfs_type=ubifs
+rootfsimage=${baseboard}-root.${rootfs_type}
+
+rootfs_mtdblock_nand=7
+
+# The image type of the kernel. Can be uimage, zimage, raw, or raw_lzo
+kernelimage_type=uimage
+kernelimage=${baseboard}-kernel.img
+
+if [ -n $user ]; then
+	kernelimage="$user"-"$kernelimage"
+	nfsroot="${eth0.serverip}:/home/$user/nfsroot/$machine"
+	rootfsimage="$user"-"$rootfsimage"
+elif [ -n "$rootpath" ]; then
+	nfsroot="${eth0.serverip}:${rootpath}"
+else
+	nfsroot="${eth0.serverip}:/srv/sysroots/mx28/eq3-ccu2"
+fi
+
+autoboot_timeout=3
+
+bootargs="eq3Mode=production console=ttyAMA0,115200 ubi.mtd=7 ubi.mtd=6 ro"
+#bootargs="$bootargs earlyprintk"
+
+nand_device="gpmi-nand"
+nand_parts="1024k(fcb)ro,1024k(bbt),1024k(bootenv),1536k(bootstream0),6M(bootstream1)ro,4M(kernel),48M(user),-(root)"
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/config.test barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/config.test
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/config.test	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/config.test	2013-02-14 18:00:48.000000000 +0100
@@ -0,0 +1,63 @@
+### --*- sh -*--
+machine=ccu2
+baseboard=eq3-ccu2
+
+cfgmode=productive
+#cfgmode=development
+
+# use 'dhcp' to do dhcp in barebox and in kernel
+# use 'none' if you want to skip kernel ip autoconfiguration
+#ip=dhcp
+
+# or set your networking parameters here
+#eth0.ipaddr=a.b.c.d
+#eth0.ethaddr=de:ad:be:ef:00:00
+#eth0.netmask=a.b.c.d
+#eth0.serverip=a.b.c.d
+#eth0.gateway=a.b.c.d
+
+# can be either 'tftp', 'nfs', 'nand', 'nor' or 'disk'
+#kernel_loc=tftp
+# can be either 'net', 'nand', 'nor', 'disk' or 'initrd'
+#rootfs_loc=net
+
+test -n "$cfgmode_" || cfgmode_=$cfgmode
+export cfgmode_
+
+if [ $cfgmode_ = productive ]; then
+    ip=none
+    kernel_loc=nand
+    rootfs_loc=nand
+elif [ $cfgmode_ = development ]; then
+    ip=dhcp
+    kernel_loc=tftp
+    rootfs_loc=net
+fi
+
+# can be either 'jffs2' or 'ubifs'
+rootfs_type=ubifs
+rootfsimage=${baseboard}-root.${rootfs_type}
+
+rootfs_mtdblock_nand=7
+
+# The image type of the kernel. Can be uimage, zimage, raw, or raw_lzo
+kernelimage_type=uimage
+kernelimage=${baseboard}-kernel.img
+
+if [ -n $user ]; then
+	kernelimage="$user"-"$kernelimage"
+	nfsroot="${eth0.serverip}:/home/$user/nfsroot/$machine"
+	rootfsimage="$user"-"$rootfsimage"
+elif [ -n "$rootpath" ]; then
+	nfsroot="${eth0.serverip}:${rootpath}"
+else
+	nfsroot="${eth0.serverip}:/srv/sysroots/mx28/eq3-ccu2"
+fi
+
+autoboot_timeout=3
+
+bootargs="eq3Mode=test console=ttyAMA0,115200 ubi.mtd=7 ubi.mtd=6 ro"
+#bootargs="$bootargs earlyprintk"
+
+nand_device="gpmi-nand"
+nand_parts="1024k(fcb)ro,1024k(bbt),1024k(bootenv),1536k(bootstream0),6M(bootstream1)ro,4M(kernel),48M(user),-(root)"
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/etc/passwd barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/etc/passwd
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/env/etc/passwd	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/env/etc/passwd	2013-02-14 16:17:49.000000000 +0100
@@ -0,0 +1 @@
+"XlT&[@l-`;61ZRm5-hSDyB,87hhqB6K705ffd2d2174b6b86012b7c34ebba9b834a10365
diff -ruN barebox-2012.02.0/arch/arm/boards/eq3-ccu2/Makefile barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/Makefile
--- barebox-2012.02.0/arch/arm/boards/eq3-ccu2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eq3-ccu2/Makefile	2013-01-14 12:46:26.000000000 +0100
@@ -0,0 +1 @@
+obj-y += ccu2.o
diff -ruN barebox-2012.02.0/arch/arm/boards/eukrea_cpuimx35/eukrea_cpuimx35.c barebox-2012.02.0-ccu2/arch/arm/boards/eukrea_cpuimx35/eukrea_cpuimx35.c
--- barebox-2012.02.0/arch/arm/boards/eukrea_cpuimx35/eukrea_cpuimx35.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/eukrea_cpuimx35/eukrea_cpuimx35.c	2013-01-14 12:46:26.000000000 +0100
@@ -91,6 +91,7 @@
 
 static struct imx_ipu_fb_platform_data ipu_fb_data = {
 	.mode		= &imxfb_mode,
+	.num_modes	= 1,
 	.bpp		= 16,
 	.enable		= eukrea_cpuimx35_enable_display,
 };
diff -ruN barebox-2012.02.0/arch/arm/boards/freescale-mx35-3-stack/3stack.c barebox-2012.02.0-ccu2/arch/arm/boards/freescale-mx35-3-stack/3stack.c
--- barebox-2012.02.0/arch/arm/boards/freescale-mx35-3-stack/3stack.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/freescale-mx35-3-stack/3stack.c	2013-01-14 12:46:27.000000000 +0100
@@ -100,6 +100,7 @@
 
 static struct imx_ipu_fb_platform_data ipu_fb_data = {
 	.mode		= &CTP_CLAA070LC0ACW,
+	.num_modes	= 1,
 	.bpp		= 16,
 };
 
@@ -130,7 +131,8 @@
 
 static int f3s_mem_init(void)
 {
-	arm_add_mem_device("ram0", IMX_SDRAM_CS0, 124 * 1024 * 1024);
+	arm_add_mem_device("ram0", IMX_SDRAM_CS0, 128 * 1024 * 1024);
+	arm_add_mem_device("ram1", IMX_SDRAM_CS1, 128 * 1024 * 1024);
 
 	return 0;
 }
diff -ruN barebox-2012.02.0/arch/arm/boards/freescale-mx35-3-stack/env/config barebox-2012.02.0-ccu2/arch/arm/boards/freescale-mx35-3-stack/env/config
--- barebox-2012.02.0/arch/arm/boards/freescale-mx35-3-stack/env/config	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/freescale-mx35-3-stack/env/config	2013-01-14 12:46:27.000000000 +0100
@@ -40,11 +40,12 @@
 
 bootargs="console=ttymxc0,115200"
 
-nor_parts="256k(barebox)ro,512k(bareboxenv),2M(kernel),-(root)"
+nor_parts="256k(barebox)ro,512k(bareboxenv),4M(kernel),-(root)"
 rootfs_mtdblock_nor=3
 
-nand_parts="256k(barebox)ro,512k(bareboxenv),2M(kernel),-(root)"
+nand_parts="256k(barebox)ro,512k(bareboxenv),4M(kernel),-(root)"
 rootfs_mtdblock_nand=7
+nand_device=mxc_nand
 
 # set a fancy prompt (if support is compiled in)
 PS1="\e[1;32mbarebox@\e[1;31m\h:\w\e[0m "
diff -ruN barebox-2012.02.0/arch/arm/boards/freescale-mx35-3-stack/flash_header.c barebox-2012.02.0-ccu2/arch/arm/boards/freescale-mx35-3-stack/flash_header.c
--- barebox-2012.02.0/arch/arm/boards/freescale-mx35-3-stack/flash_header.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/freescale-mx35-3-stack/flash_header.c	2013-01-14 12:46:27.000000000 +0100
@@ -13,23 +13,47 @@
 	{ .ptr_type = 4, .addr = 0xb8002050, .val = 0x0000d843, },
 	{ .ptr_type = 4, .addr = 0xB8002054, .val = 0x22252521, },
 	{ .ptr_type = 4, .addr = 0xB8002058, .val = 0x22220a00, },
+
 	{ .ptr_type = 4, .addr = 0xB8001010, .val = 0x00000304, },
 	{ .ptr_type = 4, .addr = 0xB8001010, .val = 0x0000030C, },
+
 	{ .ptr_type = 4, .addr = 0xB8001004, .val = 0x007ffc3f, },
+	{ .ptr_type = 4, .addr = 0xB800100C, .val = 0x007ffc3f, },
+
 	{ .ptr_type = 4, .addr = 0xB8001000, .val = 0x92220000, },
+	{ .ptr_type = 4, .addr = 0xB8001008, .val = 0x92220000, },
+
 	{ .ptr_type = 4, .addr = 0x80000400, .val = 0x12345678, },
+	{ .ptr_type = 4, .addr = 0x90000400, .val = 0x12345678, },
+
 	{ .ptr_type = 4, .addr = 0xB8001000, .val = 0xA2220000, },
+	{ .ptr_type = 4, .addr = 0xB8001008, .val = 0xA2220000, },
+
 	{ .ptr_type = 4, .addr = 0x80000000, .val = 0x87654321, },
+	{ .ptr_type = 4, .addr = 0x90000000, .val = 0x87654321, },
+
 	{ .ptr_type = 4, .addr = 0x80000000, .val = 0x87654321, },
+	{ .ptr_type = 4, .addr = 0x90000000, .val = 0x87654321, },
+
 	{ .ptr_type = 4, .addr = 0xB8001000, .val = 0xB2220000, },
+	{ .ptr_type = 4, .addr = 0xB8001008, .val = 0xB2220000, },
+
 	{ .ptr_type = 1, .addr = 0x80000233, .val = 0xda, },
+	{ .ptr_type = 1, .addr = 0x90000233, .val = 0xda, },
+
 	{ .ptr_type = 1, .addr = 0x82000780, .val = 0xda, },
+	{ .ptr_type = 1, .addr = 0x92000780, .val = 0xda, },
+
 	{ .ptr_type = 1, .addr = 0x82000400, .val = 0xda, },
+	{ .ptr_type = 1, .addr = 0x92000400, .val = 0xda, },
+
 	{ .ptr_type = 4, .addr = 0xB8001000, .val = 0x82226080, },
+	{ .ptr_type = 4, .addr = 0xB8001008, .val = 0x82226080, },
+
 	{ .ptr_type = 4, .addr = 0xB8001004, .val = 0x007ffc3f, },
 	{ .ptr_type = 4, .addr = 0xB800100C, .val = 0x007ffc3f, },
+
 	{ .ptr_type = 4, .addr = 0xB8001010, .val = 0x00000304, },
-	{ .ptr_type = 4, .addr = 0xB8001008, .val = 0x00002000, },
 };
 
 
diff -ruN barebox-2012.02.0/arch/arm/boards/freescale-mx35-3-stack/lowlevel_init.S barebox-2012.02.0-ccu2/arch/arm/boards/freescale-mx35-3-stack/lowlevel_init.S
--- barebox-2012.02.0/arch/arm/boards/freescale-mx35-3-stack/lowlevel_init.S	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/freescale-mx35-3-stack/lowlevel_init.S	2013-01-14 12:46:27.000000000 +0100
@@ -28,8 +28,8 @@
 #include "board-mx35_3stack.h"
 
 #define CSD0_BASE_ADDR		0x80000000
-#define ESDCTL_BASE_ADDR	0xB8001000
 #define CSD1_BASE_ADDR		0x90000000
+#define ESDCTL_BASE_ADDR	0xB8001000
 
 #define writel(val, reg) \
 	ldr		r0,	=reg;	\
@@ -122,9 +122,9 @@
 	str	r1, [r0, #CCM_CGR1]
 
 	/* Skip SDRAM initialization if we run from RAM */
-	cmp	pc, #0x80000000
+	cmp	pc, #CSD0_BASE_ADDR
 	bls	1f
-	cmp	pc, #0x90000000
+	cmp	pc, #CSD1_BASE_ADDR
 	bhi	1f
 
 	mov	pc, r10
@@ -138,14 +138,17 @@
 	/* ip(r12) has used to save lr register in upper calling */
 	mov	fp, lr
 
+	/* setup bank 0 */
 	mov	r5, #0x00
 	mov	r2, #0x00
 	mov	r1, #CSD0_BASE_ADDR
 	bl	setup_sdram_bank
-	cmp	r3, #0x0
-	orreq	r5, r5, #1
-	eorne	r2, r2, #0x1
-	blne	setup_sdram_bank
+
+	/* setup bank 1 */
+	mov	r5, #0x00
+	mov	r2, #0x00
+	mov	r1, #CSD1_BASE_ADDR
+	bl	setup_sdram_bank
 
 	mov	lr, fp
 
diff -ruN barebox-2012.02.0/arch/arm/boards/guf-cupid/board.c barebox-2012.02.0-ccu2/arch/arm/boards/guf-cupid/board.c
--- barebox-2012.02.0/arch/arm/boards/guf-cupid/board.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/guf-cupid/board.c	2013-01-14 12:46:22.000000000 +0100
@@ -92,6 +92,7 @@
 
 static struct imx_ipu_fb_platform_data ipu_fb_data = {
 	.mode		= &guf_cupid_fb_mode,
+	.num_modes	= 1,
 	.bpp		= 16,
 	.enable		= cupid_fb_enable,
 };
diff -ruN barebox-2012.02.0/arch/arm/boards/mmccpu/config.h barebox-2012.02.0-ccu2/arch/arm/boards/mmccpu/config.h
--- barebox-2012.02.0/arch/arm/boards/mmccpu/config.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/mmccpu/config.h	2013-01-14 12:46:22.000000000 +0100
@@ -62,44 +62,45 @@
 #define CONFIG_SYS_SDRC_TR_VAL2		780		/* SDRAM_TR */
 
 /* setup CS0 (NOR Flash) - 16-bit */
+#define CONFIG_SYS_SMC_CS	0
 #if 1
-#define CONFIG_SYS_SMC0_SETUP0_VAL					\
+#define CONFIG_SYS_SMC_SETUP_VAL					\
 		(AT91_SMC_NWESETUP_(3) | AT91_SMC_NCS_WRSETUP_(2) |	\
 		 AT91_SMC_NRDSETUP_(8) | AT91_SMC_NCS_RDSETUP_(0))
-#define CONFIG_SYS_SMC0_PULSE0_VAL					\
+#define CONFIG_SYS_SMC_PULSE_VAL					\
 		(AT91_SMC_NWEPULSE_(5) | AT91_SMC_NCS_WRPULSE_(7) |	\
 		 AT91_SMC_NRDPULSE_(5) | AT91_SMC_NCS_RDPULSE_(13))
-#define CONFIG_SYS_SMC0_CYCLE0_VAL	\
+#define CONFIG_SYS_SMC_CYCLE_VAL	\
 		(AT91_SMC_NWECYCLE_(16) | AT91_SMC_NRDCYCLE_(16))
-#define CONFIG_SYS_SMC0_MODE0_VAL				\
+#define CONFIG_SYS_SMC_MODE_VAL					\
 		(AT91_SMC_READMODE | AT91_SMC_WRITEMODE |	\
 		 AT91_SMC_DBW_16 |				\
 		 AT91_SMC_TDFMODE |				\
 		 AT91_SMC_TDF_(6))
 #elif 0	/* slow setup */
-#define CONFIG_SYS_SMC0_SETUP0_VAL					\
+#define CONFIG_SYS_SMC_SETUP_VAL					\
 		(AT91_SMC_NWESETUP_(3) | AT91_SMC_NCS_WRSETUP_(2) |	\
 		 AT91_SMC_NRDSETUP_(8) | AT91_SMC_NCS_RDSETUP_(0))
-#define CONFIG_SYS_SMC0_PULSE0_VAL					\
+#define CONFIG_SYS_SMC_PULSE_VAL					\
 		(AT91_SMC_NWEPULSE_(5) | AT91_SMC_NCS_WRPULSE_(7) |	\
 		 AT91_SMC_NRDPULSE_(5) | AT91_SMC_NCS_RDPULSE_(13))
-#define CONFIG_SYS_SMC0_CYCLE0_VAL	\
+#define CONFIG_SYS_SMC_CYCLE_VAL	\
 		(AT91_SMC_NWECYCLE_(0xd00) | AT91_SMC_NRDCYCLE_(0xd00))
-#define CONFIG_SYS_SMC0_MODE0_VAL				\
+#define CONFIG_SYS_SMC_MODE_VAL					\
 		(AT91_SMC_READMODE | AT91_SMC_WRITEMODE |	\
 		 AT91_SMC_DBW_16 |				\
 		 AT91_SMC_TDFMODE |				\
 		 AT91_SMC_TDF_(1))
 #else	/* RONETIX' original values */
-#define CONFIG_SYS_SMC0_SETUP0_VAL					\
+#define CONFIG_SYS_SMC_SETUP_VAL					\
 		(AT91_SMC_NWESETUP_(10) | AT91_SMC_NCS_WRSETUP_(10) |	\
 		 AT91_SMC_NRDSETUP_(10) | AT91_SMC_NCS_RDSETUP_(10))
-#define CONFIG_SYS_SMC0_PULSE0_VAL					\
+#define CONFIG_SYS_SMC_PULSE_VAL					\
 		(AT91_SMC_NWEPULSE_(11) | AT91_SMC_NCS_WRPULSE_(11) |	\
 		 AT91_SMC_NRDPULSE_(11) | AT91_SMC_NCS_RDPULSE_(11))
-#define CONFIG_SYS_SMC0_CYCLE0_VAL	\
+#define CONFIG_SYS_SMC_CYCLE_VAL	\
 		(AT91_SMC_NWECYCLE_(22) | AT91_SMC_NRDCYCLE_(22))
-#define CONFIG_SYS_SMC0_MODE0_VAL				\
+#define CONFIG_SYS_SMC_MODE_VAL					\
 		(AT91_SMC_READMODE | AT91_SMC_WRITEMODE |	\
 		 AT91_SMC_DBW_16 |				\
 		 AT91_SMC_TDFMODE |				\
diff -ruN barebox-2012.02.0/arch/arm/boards/omap343xdsp/board.c barebox-2012.02.0-ccu2/arch/arm/boards/omap343xdsp/board.c
--- barebox-2012.02.0/arch/arm/boards/omap343xdsp/board.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/omap343xdsp/board.c	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,651 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Nishanth Menon <x0nishan@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * @file
+ * @brief SDP3430 Specific Board Initialization routines
+ */
+
+/**
+ * @page ti_SDP3430 Texas Instruments SDP3430
+ *
+ * FileName: arch/arm/boards/omap/board-sdp343x.c
+ *
+ * SDP3430 from Texas Instruments as described here:
+ * http://www.ti.com/omap3430_devplatform
+ * This file provides initialization in two stages:
+ * @li boot time initialization - do basics required to get SDRAM working.
+ * This is run from SRAM - so no case constructs and global vars can be used.
+ * @li run time initialization - this is for the rest of the initializations
+ * such as flash, uart etc.
+ *
+ * Boot time initialization includes:
+ * @li SDRAM initialization.
+ * @li Pin Muxing relevant for SDP3430.
+ *
+ * Run time initialization includes
+ * @li serial @ref serial_ns16550.c driver device definition
+ *
+ * Originally from http://linux.omap.com/pub/bootloader/3430sdp/u-boot-v1.tar.gz
+ */
+
+#include <common.h>
+#include <console.h>
+#include <init.h>
+#include <driver.h>
+#include <io.h>
+#include <ns16550.h>
+#include <asm/armlinux.h>
+#include <mach/silicon.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/control.h>
+#include <mach/omap3-mux.h>
+#include <mach/gpmc.h>
+#include <errno.h>
+
+/******************** Board Boot Time *******************/
+static void sdrc_init(void);
+static void mux_config(void);
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+static int sdp343x_board_init(void)
+{
+	int in_sdram = running_in_sdram();
+
+	omap3_core_init();
+
+	mux_config();
+	if (!in_sdram)
+		sdrc_init();
+
+	return 0;
+}
+pure_initcall(sdp343x_board_init);
+
+/**
+ * @brief Do the SDRC initialization for 128Meg Infenion DDR for CS0
+ *
+ * @return void
+ */
+static void sdrc_init(void)
+{
+	/* Issue SDRC Soft reset  */
+	writel(0x12, SDRC_REG(SYSCONFIG));
+    /* Wait until Reset complete */
+    while ((readl(SDRC_REG(STATUS)) & 0x1) == 0);
+    /* SDRC to normal mode */
+	writel(0x10, SDRC_REG(SYSCONFIG));
+	/* SDRC Sharing register */
+	/* 32-bit SDRAM on data lane [31:0] - CS0 */
+	/* pin tri-stated = 1 */
+	writel(0x00000100, SDRC_REG(SHARING));
+
+	/* ----- SDRC_REG(CS0 Configuration --------- */
+	/* SDRC_REG(MCFG0 register */
+	writel(0x02584019, SDRC_REG(MCFG_0));
+
+	/* SDRC_REG(RFR_CTRL0 register */
+	writel(0x0003DE01, SDRC_REG(RFR_CTRL_0));
+
+	/* SDRC_REG(ACTIM_CTRLA0 register */
+	writel(0X5A9A4486, SDRC_REG(ACTIM_CTRLA_0));
+
+	/* SDRC_REG(ACTIM_CTRLB0 register */
+	writel(0x00000010, SDRC_REG(ACTIM_CTRLB_0));
+
+	/* Disble Power Down of CKE cuz of 1 CKE on combo part */
+	writel(0x00000081, SDRC_REG(POWER));
+
+	/* SDRC_REG(Manual command register */
+	/* NOP command */
+	writel(0x00000000, SDRC_REG(MANUAL_0));
+	/* Precharge command */
+	writel(0x00000001, SDRC_REG(MANUAL_0));
+	/* Auto-refresh command */
+	writel(0x00000002, SDRC_REG(MANUAL_0));
+	/* Auto-refresh command */
+	writel(0x00000002, SDRC_REG(MANUAL_0));
+
+	/* SDRC MR0 register */
+	/* CAS latency = 3 */
+	/* Write Burst = Read Burst */
+	/* Serial Mode */
+	writel(0x00000032, SDRC_REG(MR_0));	/* Burst length =4 */
+
+    /* SDRC DLLA control register */
+	/* Enable DLL A */
+	writel(0x0000000A, SDRC_REG(DLLA_CTRL));
+
+    /* wait until DLL is locked  */
+    while ((readl(SDRC_REG(DLLA_STATUS)) & 0x4) == 0);
+	return;
+}
+
+/**
+ * @brief Do the pin muxing required for Board operation.
+ *
+ * See @ref MUX_VAL for description of the muxing mode. Since some versions
+ * of Linux depend on all pin muxing being done at barebox level, we may need to
+ * enable CONFIG_MACH_OMAP_ADVANCED_MUX to enable the full fledged pin muxing.
+ *
+ * @return void
+ */
+static void mux_config(void)
+{
+	/* Essential MUX Settings */
+	MUX_VAL(CP(SDRC_D0), (IEN | PTD | DIS | M0));	/* SDRC_D0 */
+	MUX_VAL(CP(SDRC_D1), (IEN | PTD | DIS | M0));	/* SDRC_D1 */
+	MUX_VAL(CP(SDRC_D2), (IEN | PTD | DIS | M0));	/* SDRC_D2 */
+	MUX_VAL(CP(SDRC_D3), (IEN | PTD | DIS | M0));	/* SDRC_D3 */
+	MUX_VAL(CP(SDRC_D4), (IEN | PTD | DIS | M0));	/* SDRC_D4 */
+	MUX_VAL(CP(SDRC_D5), (IEN | PTD | DIS | M0));	/* SDRC_D5 */
+	MUX_VAL(CP(SDRC_D6), (IEN | PTD | DIS | M0));	/* SDRC_D6 */
+	MUX_VAL(CP(SDRC_D7), (IEN | PTD | DIS | M0));	/* SDRC_D7 */
+	MUX_VAL(CP(SDRC_D8), (IEN | PTD | DIS | M0));	/* SDRC_D8 */
+	MUX_VAL(CP(SDRC_D9), (IEN | PTD | DIS | M0));	/* SDRC_D9 */
+	MUX_VAL(CP(SDRC_D10), (IEN | PTD | DIS | M0));	/* SDRC_D10 */
+	MUX_VAL(CP(SDRC_D11), (IEN | PTD | DIS | M0));	/* SDRC_D11 */
+	MUX_VAL(CP(SDRC_D12), (IEN | PTD | DIS | M0));	/* SDRC_D12 */
+	MUX_VAL(CP(SDRC_D13), (IEN | PTD | DIS | M0));	/* SDRC_D13 */
+	MUX_VAL(CP(SDRC_D14), (IEN | PTD | DIS | M0));	/* SDRC_D14 */
+	MUX_VAL(CP(SDRC_D15), (IEN | PTD | DIS | M0));	/* SDRC_D15 */
+	MUX_VAL(CP(SDRC_D16), (IEN | PTD | DIS | M0));	/* SDRC_D16 */
+	MUX_VAL(CP(SDRC_D17), (IEN | PTD | DIS | M0));	/* SDRC_D17 */
+	MUX_VAL(CP(SDRC_D18), (IEN | PTD | DIS | M0));	/* SDRC_D18 */
+	MUX_VAL(CP(SDRC_D19), (IEN | PTD | DIS | M0));	/* SDRC_D19 */
+	MUX_VAL(CP(SDRC_D20), (IEN | PTD | DIS | M0));	/* SDRC_D20 */
+	MUX_VAL(CP(SDRC_D21), (IEN | PTD | DIS | M0));	/* SDRC_D21 */
+	MUX_VAL(CP(SDRC_D22), (IEN | PTD | DIS | M0));	/* SDRC_D22 */
+	MUX_VAL(CP(SDRC_D23), (IEN | PTD | DIS | M0));	/* SDRC_D23 */
+	MUX_VAL(CP(SDRC_D24), (IEN | PTD | DIS | M0));	/* SDRC_D24 */
+	MUX_VAL(CP(SDRC_D25), (IEN | PTD | DIS | M0));	/* SDRC_D25 */
+	MUX_VAL(CP(SDRC_D26), (IEN | PTD | DIS | M0));	/* SDRC_D26 */
+	MUX_VAL(CP(SDRC_D27), (IEN | PTD | DIS | M0));	/* SDRC_D27 */
+	MUX_VAL(CP(SDRC_D28), (IEN | PTD | DIS | M0));	/* SDRC_D28 */
+	MUX_VAL(CP(SDRC_D29), (IEN | PTD | DIS | M0));	/* SDRC_D29 */
+	MUX_VAL(CP(SDRC_D30), (IEN | PTD | DIS | M0));	/* SDRC_D30 */
+	MUX_VAL(CP(SDRC_D31), (IEN | PTD | DIS | M0));	/* SDRC_D31 */
+	MUX_VAL(CP(SDRC_CLK), (IEN | PTD | DIS | M0));	/* SDRC_CLK */
+	MUX_VAL(CP(SDRC_DQS0), (IEN | PTD | DIS | M0));	/* SDRC_DQS0 */
+	MUX_VAL(CP(SDRC_DQS1), (IEN | PTD | DIS | M0));	/* SDRC_DQS1 */
+	MUX_VAL(CP(SDRC_DQS2), (IEN | PTD | DIS | M0));	/* SDRC_DQS2 */
+	MUX_VAL(CP(SDRC_DQS3), (IEN | PTD | DIS | M0));	/* SDRC_DQS3 */
+	/* GPMC */
+	MUX_VAL(CP(GPMC_A1), (IDIS | PTD | DIS | M0));	/* GPMC_A1 */
+	MUX_VAL(CP(GPMC_A2), (IDIS | PTD | DIS | M0));	/* GPMC_A2 */
+	MUX_VAL(CP(GPMC_A3), (IDIS | PTD | DIS | M0));	/* GPMC_A3 */
+	MUX_VAL(CP(GPMC_A4), (IDIS | PTD | DIS | M0));	/* GPMC_A4 */
+	MUX_VAL(CP(GPMC_A5), (IDIS | PTD | DIS | M0));	/* GPMC_A5 */
+	MUX_VAL(CP(GPMC_A6), (IDIS | PTD | DIS | M0));	/* GPMC_A6 */
+	MUX_VAL(CP(GPMC_A7), (IDIS | PTD | DIS | M0));	/* GPMC_A7 */
+	MUX_VAL(CP(GPMC_A8), (IDIS | PTD | DIS | M0));	/* GPMC_A8 */
+	MUX_VAL(CP(GPMC_A9), (IDIS | PTD | DIS | M0));	/* GPMC_A9 */
+	MUX_VAL(CP(GPMC_A10), (IDIS | PTD | DIS | M0));	/* GPMC_A10 */
+	MUX_VAL(CP(GPMC_D0), (IEN | PTD | DIS | M0));	/* GPMC_D0 */
+	MUX_VAL(CP(GPMC_D1), (IEN | PTD | DIS | M0));	/* GPMC_D1 */
+	MUX_VAL(CP(GPMC_D2), (IEN | PTD | DIS | M0));	/* GPMC_D2 */
+	MUX_VAL(CP(GPMC_D3), (IEN | PTD | DIS | M0));	/* GPMC_D3 */
+	MUX_VAL(CP(GPMC_D4), (IEN | PTD | DIS | M0));	/* GPMC_D4 */
+	MUX_VAL(CP(GPMC_D5), (IEN | PTD | DIS | M0));	/* GPMC_D5 */
+	MUX_VAL(CP(GPMC_D6), (IEN | PTD | DIS | M0));	/* GPMC_D6 */
+	MUX_VAL(CP(GPMC_D7), (IEN | PTD | DIS | M0));	/* GPMC_D7 */
+	MUX_VAL(CP(GPMC_D8), (IEN | PTD | DIS | M0));	/* GPMC_D8 */
+	MUX_VAL(CP(GPMC_D9), (IEN | PTD | DIS | M0));	/* GPMC_D9 */
+	MUX_VAL(CP(GPMC_D10), (IEN | PTD | DIS | M0));	/* GPMC_D10 */
+	MUX_VAL(CP(GPMC_D11), (IEN | PTD | DIS | M0));	/* GPMC_D11 */
+	MUX_VAL(CP(GPMC_D12), (IEN | PTD | DIS | M0));	/* GPMC_D12 */
+	MUX_VAL(CP(GPMC_D13), (IEN | PTD | DIS | M0));	/* GPMC_D13 */
+	MUX_VAL(CP(GPMC_D14), (IEN | PTD | DIS | M0));	/* GPMC_D14 */
+	MUX_VAL(CP(GPMC_D15), (IEN | PTD | DIS | M0));	/* GPMC_D15 */
+	MUX_VAL(CP(GPMC_NCS0), (IDIS | PTU | EN | M0));	/* GPMC_NCS0 */
+	MUX_VAL(CP(GPMC_NCS1), (IDIS | PTU | EN | M0));	/* GPMC_NCS1 */
+	MUX_VAL(CP(GPMC_NCS2), (IDIS | PTU | EN | M0));	/* GPMC_NCS2 */
+	MUX_VAL(CP(GPMC_NCS3), (IDIS | PTU | EN | M0));	/* GPMC_NCS3 */
+	/* GPIO_55 - FLASH_DIS */
+	MUX_VAL(CP(GPMC_NCS4), (IEN | PTU | EN | M4));
+	/* GPIO_56 - TORCH_EN */
+	MUX_VAL(CP(GPMC_NCS5), (IDIS | PTD | DIS | M4));
+	/* GPIO_57 - AGPS SLP */
+	MUX_VAL(CP(GPMC_NCS6), (IEN | PTD | DIS | M4));
+	/* GPMC_58 - WLAN_IRQ */
+	MUX_VAL(CP(GPMC_NCS7), (IEN | PTU | EN | M4));
+	MUX_VAL(CP(GPMC_CLK), (IDIS | PTD | DIS | M0));	/* GPMC_CLK */
+	/* GPMC_NADV_ALE */
+	MUX_VAL(CP(GPMC_NADV_ALE), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NOE), (IDIS | PTD | DIS | M0));	/* GPMC_NOE */
+	MUX_VAL(CP(GPMC_NWE), (IDIS | PTD | DIS | M0));	/* GPMC_NWE */
+	/* GPMC_NBE0_CLE */
+	MUX_VAL(CP(GPMC_NBE0_CLE), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NBE1), (IEN | PTD | DIS | M4));	/* GPIO_61 -BT_SHUTDN */
+	MUX_VAL(CP(GPMC_NWP), (IEN | PTD | DIS | M0));	/* GPMC_NWP */
+	MUX_VAL(CP(GPMC_WAIT0), (IEN | PTU | EN | M0));	/* GPMC_WAIT0 */
+	MUX_VAL(CP(GPMC_WAIT1), (IEN | PTU | EN | M0));	/* GPMC_WAIT1 */
+	MUX_VAL(CP(GPMC_WAIT2), (IEN | PTU | EN | M4));	/* GPIO_64 */
+	MUX_VAL(CP(GPMC_WAIT3), (IEN | PTU | EN | M4));	/* GPIO_65 */
+
+	/* SERIAL INTERFACE */
+	/* UART3_CTS_RCTX */
+	MUX_VAL(CP(UART3_CTS_RCTX), (IEN | PTD | EN | M0));
+	/* UART3_RTS_SD */
+	MUX_VAL(CP(UART3_RTS_SD), (IDIS | PTD | DIS | M0));
+	/* UART3_RX_IRRX */
+	MUX_VAL(CP(UART3_RX_IRRX), (IEN | PTD | DIS | M0));
+	/* UART3_TX_IRTX */
+	MUX_VAL(CP(UART3_TX_IRTX), (IDIS | PTD | DIS | M0));
+	/* HSUSB0_CLK */
+	MUX_VAL(CP(HSUSB0_CLK), (IEN | PTD | DIS | M0));
+	/* HSUSB0_STP */
+	MUX_VAL(CP(HSUSB0_STP), (IDIS | PTU | EN | M0));
+	/* HSUSB0_DIR */
+	MUX_VAL(CP(HSUSB0_DIR), (IEN | PTD | DIS | M0));
+	/* HSUSB0_NXT */
+	MUX_VAL(CP(HSUSB0_NXT), (IEN | PTD | DIS | M0));
+	/* HSUSB0_DATA0 */
+	MUX_VAL(CP(HSUSB0_DATA0), (IEN | PTD | DIS | M0));
+	/* HSUSB0_DATA1 */
+	MUX_VAL(CP(HSUSB0_DATA1), (IEN | PTD | DIS | M0));
+	/* HSUSB0_DATA2 */
+	MUX_VAL(CP(HSUSB0_DATA2), (IEN | PTD | DIS | M0));
+	/* HSUSB0_DATA3 */
+	MUX_VAL(CP(HSUSB0_DATA3), (IEN | PTD | DIS | M0));
+	/* HSUSB0_DATA4 */
+	MUX_VAL(CP(HSUSB0_DATA4), (IEN | PTD | DIS | M0));
+	/* HSUSB0_DATA5 */
+	MUX_VAL(CP(HSUSB0_DATA5), (IEN | PTD | DIS | M0));
+	/* HSUSB0_DATA6 */
+	MUX_VAL(CP(HSUSB0_DATA6), (IEN | PTD | DIS | M0));
+	/* HSUSB0_DATA7 */
+	MUX_VAL(CP(HSUSB0_DATA7), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(I2C1_SCL), (IEN | PTU | EN | M0));	/* I2C1_SCL */
+	MUX_VAL(CP(I2C1_SDA), (IEN | PTU | EN | M0));	/* I2C1_SDA */
+#ifdef CONFIG_MACH_OMAP_ADVANCED_MUX
+	/* DSS */
+	MUX_VAL(CP(DSS_PCLK), (IDIS | PTD | DIS | M0));	/* DSS_PCLK */
+	MUX_VAL(CP(DSS_HSYNC), (IDIS | PTD | DIS | M0));	/* DSS_HSYNC */
+	MUX_VAL(CP(DSS_VSYNC), (IDIS | PTD | DIS | M0));	/* DSS_VSYNC */
+	MUX_VAL(CP(DSS_ACBIAS), (IDIS | PTD | DIS | M0));	/* DSS_ACBIAS */
+	MUX_VAL(CP(DSS_DATA0), (IDIS | PTD | DIS | M0));	/* DSS_DATA0 */
+	MUX_VAL(CP(DSS_DATA1), (IDIS | PTD | DIS | M0));	/* DSS_DATA1 */
+	MUX_VAL(CP(DSS_DATA2), (IDIS | PTD | DIS | M0));	/* DSS_DATA2 */
+	MUX_VAL(CP(DSS_DATA3), (IDIS | PTD | DIS | M0));	/* DSS_DATA3 */
+	MUX_VAL(CP(DSS_DATA4), (IDIS | PTD | DIS | M0));	/* DSS_DATA4 */
+	MUX_VAL(CP(DSS_DATA5), (IDIS | PTD | DIS | M0));	/* DSS_DATA5 */
+	MUX_VAL(CP(DSS_DATA6), (IDIS | PTD | DIS | M0));	/* DSS_DATA6 */
+	MUX_VAL(CP(DSS_DATA7), (IDIS | PTD | DIS | M0));	/* DSS_DATA7 */
+	MUX_VAL(CP(DSS_DATA8), (IDIS | PTD | DIS | M0));	/* DSS_DATA8 */
+	MUX_VAL(CP(DSS_DATA9), (IDIS | PTD | DIS | M0));	/* DSS_DATA9 */
+	MUX_VAL(CP(DSS_DATA10), (IDIS | PTD | DIS | M0));	/* DSS_DATA10 */
+	MUX_VAL(CP(DSS_DATA11), (IDIS | PTD | DIS | M0));	/* DSS_DATA11 */
+	MUX_VAL(CP(DSS_DATA12), (IDIS | PTD | DIS | M0));	/* DSS_DATA12 */
+	MUX_VAL(CP(DSS_DATA13), (IDIS | PTD | DIS | M0));	/* DSS_DATA13 */
+	MUX_VAL(CP(DSS_DATA14), (IDIS | PTD | DIS | M0));	/* DSS_DATA14 */
+	MUX_VAL(CP(DSS_DATA15), (IDIS | PTD | DIS | M0));	/* DSS_DATA15 */
+	MUX_VAL(CP(DSS_DATA16), (IDIS | PTD | DIS | M0));	/* DSS_DATA16 */
+	MUX_VAL(CP(DSS_DATA17), (IDIS | PTD | DIS | M0));	/* DSS_DATA17 */
+	MUX_VAL(CP(DSS_DATA18), (IDIS | PTD | DIS | M0));	/* DSS_DATA18 */
+	MUX_VAL(CP(DSS_DATA19), (IDIS | PTD | DIS | M0));	/* DSS_DATA19 */
+	MUX_VAL(CP(DSS_DATA20), (IDIS | PTD | DIS | M0));	/* DSS_DATA20 */
+	MUX_VAL(CP(DSS_DATA21), (IDIS | PTD | DIS | M0));	/* DSS_DATA21 */
+	MUX_VAL(CP(DSS_DATA22), (IDIS | PTD | DIS | M0));	/* DSS_DATA22 */
+	MUX_VAL(CP(DSS_DATA23), (IDIS | PTD | DIS | M0));	/* DSS_DATA23 */
+	/* CAMERA */
+	MUX_VAL(CP(CAM_HS), (IEN | PTU | EN | M0));	/* CAM_HS */
+	MUX_VAL(CP(CAM_VS), (IEN | PTU | EN | M0));	/* CAM_VS */
+	MUX_VAL(CP(CAM_XCLKA), (IDIS | PTD | DIS | M0));	/* CAM_XCLKA */
+	MUX_VAL(CP(CAM_PCLK), (IEN | PTU | EN | M0));	/* CAM_PCLK */
+	/* GPIO_98 - CAM_RESET */
+	MUX_VAL(CP(CAM_FLD), (IDIS | PTD | DIS | M4));
+	MUX_VAL(CP(CAM_D0), (IEN | PTD | DIS | M0));	/* CAM_D0 */
+	MUX_VAL(CP(CAM_D1), (IEN | PTD | DIS | M0));	/* CAM_D1 */
+	MUX_VAL(CP(CAM_D2), (IEN | PTD | DIS | M0));	/* CAM_D2 */
+	MUX_VAL(CP(CAM_D3), (IEN | PTD | DIS | M0));	/* CAM_D3 */
+	MUX_VAL(CP(CAM_D4), (IEN | PTD | DIS | M0));	/* CAM_D4 */
+	MUX_VAL(CP(CAM_D5), (IEN | PTD | DIS | M0));	/* CAM_D5 */
+	MUX_VAL(CP(CAM_D6), (IEN | PTD | DIS | M0));	/* CAM_D6 */
+	MUX_VAL(CP(CAM_D7), (IEN | PTD | DIS | M0));	/* CAM_D7 */
+	MUX_VAL(CP(CAM_D8), (IEN | PTD | DIS | M0));	/* CAM_D8 */
+	MUX_VAL(CP(CAM_D9), (IEN | PTD | DIS | M0));	/* CAM_D9 */
+	MUX_VAL(CP(CAM_D10), (IEN | PTD | DIS | M0));	/* CAM_D10 */
+	MUX_VAL(CP(CAM_D11), (IEN | PTD | DIS | M0));	/* CAM_D11 */
+	MUX_VAL(CP(CAM_XCLKB), (IDIS | PTD | DIS | M0));	/* CAM_XCLKB */
+	MUX_VAL(CP(CAM_WEN), (IEN | PTD | DIS | M4));	/* GPIO_167 */
+	MUX_VAL(CP(CAM_STROBE), (IDIS | PTD | DIS | M0));	/* CAM_STROBE */
+	MUX_VAL(CP(CSI2_DX0), (IEN | PTD | DIS | M0));	/* CSI2_DX0 */
+	MUX_VAL(CP(CSI2_DY0), (IEN | PTD | DIS | M0));	/* CSI2_DY0 */
+	MUX_VAL(CP(CSI2_DX1), (IEN | PTD | DIS | M0));	/* CSI2_DX1 */
+	MUX_VAL(CP(CSI2_DY1), (IEN | PTD | DIS | M0));	/* CSI2_DY1 */
+	/* AUDIO INTERFACE */
+	MUX_VAL(CP(MCBSP2_FSX), (IEN | PTD | DIS | M0));	/* MCBSP2_FSX */
+	/* MCBSP2_CLKX */
+	MUX_VAL(CP(MCBSP2_CLKX), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(MCBSP2_DR), (IEN | PTD | DIS | M0));	/* MCBSP2_DR */
+	MUX_VAL(CP(MCBSP2_DX), (IDIS | PTD | DIS | M0));	/* MCBSP2_DX */
+	/* EXPANSION CARD  */
+	MUX_VAL(CP(MMC1_CLK), (IDIS | PTU | EN | M0));	/* MMC1_CLK */
+	MUX_VAL(CP(MMC1_CMD), (IEN | PTU | EN | M0));	/* MMC1_CMD */
+	MUX_VAL(CP(MMC1_DAT0), (IEN | PTU | EN | M0));	/* MMC1_DAT0 */
+	MUX_VAL(CP(MMC1_DAT1), (IEN | PTU | EN | M0));	/* MMC1_DAT1 */
+	MUX_VAL(CP(MMC1_DAT2), (IEN | PTU | EN | M0));	/* MMC1_DAT2 */
+	MUX_VAL(CP(MMC1_DAT3), (IEN | PTU | EN | M0));	/* MMC1_DAT3 */
+	MUX_VAL(CP(MMC1_DAT4), (IEN | PTU | EN | M0));	/* MMC1_DAT4 */
+	MUX_VAL(CP(MMC1_DAT5), (IEN | PTU | EN | M0));	/* MMC1_DAT5 */
+	MUX_VAL(CP(MMC1_DAT6), (IEN | PTU | EN | M0));	/* MMC1_DAT6 */
+	MUX_VAL(CP(MMC1_DAT7), (IEN | PTU | EN | M0));	/* MMC1_DAT7 */
+	/* WIRELESS LAN */
+	MUX_VAL(CP(MMC2_CLK), (IEN | PTD | DIS | M0));	/* MMC2_CLK */
+	MUX_VAL(CP(MMC2_CMD), (IEN | PTU | EN | M0));	/* MMC2_CMD */
+	MUX_VAL(CP(MMC2_DAT0), (IEN | PTU | EN | M0));	/* MMC2_DAT0 */
+	MUX_VAL(CP(MMC2_DAT1), (IEN | PTU | EN | M0));	/* MMC2_DAT1 */
+	MUX_VAL(CP(MMC2_DAT2), (IEN | PTU | EN | M0));	/* MMC2_DAT2 */
+	MUX_VAL(CP(MMC2_DAT3), (IEN | PTU | EN | M0));	/* MMC2_DAT3 */
+	/* MMC2_DIR_DAT0 */
+	MUX_VAL(CP(MMC2_DAT4), (IDIS | PTD | DIS | M1));
+	/* MMC2_DIR_DAT1 */
+	MUX_VAL(CP(MMC2_DAT5), (IDIS | PTD | DIS | M1));
+	/* MMC2_DIR_CMD */
+	MUX_VAL(CP(MMC2_DAT6), (IDIS | PTD | DIS | M1));
+	/* MMC2_CLKIN */
+	MUX_VAL(CP(MMC2_DAT7), (IEN | PTU | EN | M1));
+	/* BLUETOOTH */
+	/* MCBSP3_DX */
+	MUX_VAL(CP(MCBSP3_DX), (IDIS | PTD | DIS | M0));
+	/* MCBSP3_DR */
+	MUX_VAL(CP(MCBSP3_DR), (IEN | PTD | DIS | M0));
+	/* MCBSP3_CLKX */
+	MUX_VAL(CP(MCBSP3_CLKX), (IEN | PTD | DIS | M0));
+	/* MCBSP3_FSX */
+	MUX_VAL(CP(MCBSP3_FSX), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(UART2_CTS), (IEN | PTU | EN | M0));	/* UART2_CTS */
+	MUX_VAL(CP(UART2_RTS), (IDIS | PTD | DIS | M0));	/* UART2_RTS */
+	MUX_VAL(CP(UART2_TX), (IDIS | PTD | DIS | M0));	/* UART2_TX */
+	MUX_VAL(CP(UART2_RX), (IEN | PTD | DIS | M0));	/* UART2_RX */
+	/* MODEM INTERFACE */
+	MUX_VAL(CP(UART1_TX), (IDIS | PTD | DIS | M0));	/* UART1_TX */
+	MUX_VAL(CP(UART1_RTS), (IDIS | PTD | DIS | M0));	/* UART1_RTS */
+	MUX_VAL(CP(UART1_CTS), (IEN | PTU | DIS | M0));	/* UART1_CTS */
+	MUX_VAL(CP(UART1_RX), (IEN | PTD | DIS | M0));	/* UART1_RX */
+	/* SSI1_DAT_RX */
+	MUX_VAL(CP(MCBSP4_CLKX), (IEN | PTD | DIS | M1));
+	MUX_VAL(CP(MCBSP4_DR), (IEN | PTD | DIS | M1));	/* SSI1_FLAG_RX */
+	MUX_VAL(CP(MCBSP4_DX), (IEN | PTD | DIS | M1));	/* SSI1_RDY_RX  */
+	MUX_VAL(CP(MCBSP4_FSX), (IEN | PTD | DIS | M1));	/* SSI1_WAKE */
+	/* MCBSP1_CLKR  */
+	MUX_VAL(CP(MCBSP1_CLKR), (IEN | PTD | DIS | M0));
+	/* GPIO_157 - BT_WKUP */
+	MUX_VAL(CP(MCBSP1_FSR), (IDIS | PTU | EN | M4));
+	/* MCBSP1_DX */
+	MUX_VAL(CP(MCBSP1_DX), (IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(MCBSP1_DR), (IEN | PTD | DIS | M0));	/* MCBSP1_DR */
+	/* MCBSP_CLKS  */
+	MUX_VAL(CP(MCBSP_CLKS), (IEN | PTU | DIS | M0));
+	/* MCBSP1_FSX */
+	MUX_VAL(CP(MCBSP1_FSX), (IEN | PTD | DIS | M0));
+	/* MCBSP1_CLKX  */
+	MUX_VAL(CP(MCBSP1_CLKX), (IEN | PTD | DIS | M0));
+	/* SERIAL INTERFACE */
+	MUX_VAL(CP(I2C2_SCL), (IEN | PTU | EN | M0));	/* I2C2_SCL */
+	MUX_VAL(CP(I2C2_SDA), (IEN | PTU | EN | M0));	/* I2C2_SDA */
+	MUX_VAL(CP(I2C3_SCL), (IEN | PTU | EN | M0));	/* I2C3_SCL */
+	MUX_VAL(CP(I2C3_SDA), (IEN | PTU | EN | M0));	/* I2C3_SDA */
+	MUX_VAL(CP(I2C4_SCL), (IEN | PTU | EN | M0));	/* I2C4_SCL */
+	MUX_VAL(CP(I2C4_SDA), (IEN | PTU | EN | M0));	/* I2C4_SDA */
+	MUX_VAL(CP(HDQ_SIO), (IEN | PTU | EN | M0));	/* HDQ_SIO */
+	/* MCSPI1_CLK */
+	MUX_VAL(CP(MCSPI1_CLK), (IEN | PTD | DIS | M0));
+	/* MCSPI1_SIMO */
+	MUX_VAL(CP(MCSPI1_SIMO), (IEN | PTD | DIS | M0));
+	/* MCSPI1_SOMI */
+	MUX_VAL(CP(MCSPI1_SOMI), (IEN | PTD | DIS | M0));
+	/* MCSPI1_CS0 */
+	MUX_VAL(CP(MCSPI1_CS0), (IEN | PTD | EN | M0));
+	/* MCSPI1_CS1 */
+	MUX_VAL(CP(MCSPI1_CS1), (IDIS | PTD | EN | M0));
+	/* GPIO_176-NOR_DPD */
+	MUX_VAL(CP(MCSPI1_CS2), (IDIS | PTD | DIS | M4));
+	/* MCSPI1_CS3 */
+	MUX_VAL(CP(MCSPI1_CS3), (IEN | PTD | EN | M0));
+	/* MCSPI2_CLK */
+	MUX_VAL(CP(MCSPI2_CLK), (IEN | PTD | DIS | M0));
+	/* MCSPI2_SIMO */
+	MUX_VAL(CP(MCSPI2_SIMO), (IEN | PTD | DIS | M0));
+	/* MCSPI2_SOMI */
+	MUX_VAL(CP(MCSPI2_SOMI), (IEN | PTD | DIS | M0));
+	/* MCSPI2_CS0 */
+	MUX_VAL(CP(MCSPI2_CS0), (IEN | PTD | EN | M0));
+	/* MCSPI2_CS1 */
+	MUX_VAL(CP(MCSPI2_CS1), (IEN | PTD | EN | M0));
+
+	/* CONTROL AND DEBUG */
+	MUX_VAL(CP(SYS_32K), (IEN | PTD | DIS | M0));	/* SYS_32K */
+	MUX_VAL(CP(SYS_CLKREQ), (IEN | PTD | DIS | M0));	/* SYS_CLKREQ */
+	MUX_VAL(CP(SYS_NIRQ), (IEN | PTU | EN | M0));	/* SYS_NIRQ */
+	MUX_VAL(CP(SYS_BOOT0), (IEN | PTD | DIS | M4));	/* GPIO_2 - PEN_IRQ */
+	MUX_VAL(CP(SYS_BOOT1), (IEN | PTD | DIS | M4));	/* GPIO_3 */
+	MUX_VAL(CP(SYS_BOOT2), (IEN | PTD | DIS | M4));	/* GPIO_4 - MMC1_WP */
+	MUX_VAL(CP(SYS_BOOT3), (IEN | PTD | DIS | M4));	/* GPIO_5 - LCD_ENVDD */
+	MUX_VAL(CP(SYS_BOOT4), (IEN | PTD | DIS | M4));	/* GPIO_6 - LAN_INTR0 */
+	MUX_VAL(CP(SYS_BOOT5), (IEN | PTD | DIS | M4));	/* GPIO_7 - MMC2_WP */
+	/* GPIO_8-LCD_ENBKL */
+	MUX_VAL(CP(SYS_BOOT6), (IDIS | PTD | DIS | M4));
+	/* SYS_OFF_MODE */
+	MUX_VAL(CP(SYS_OFF_MODE), (IEN | PTD | DIS | M0));
+	/* SYS_CLKOUT1  */
+	MUX_VAL(CP(SYS_CLKOUT1), (IEN | PTD | DIS | M0));
+	MUX_VAL(CP(SYS_CLKOUT2), (IEN | PTU | EN | M4));	/* GPIO_186 */
+	MUX_VAL(CP(JTAG_NTRST), (IEN | PTD | DIS | M0));	/* JTAG_NTRST */
+	MUX_VAL(CP(JTAG_TCK), (IEN | PTD | DIS | M0));	/* JTAG_TCK */
+	MUX_VAL(CP(JTAG_TMS), (IEN | PTD | DIS | M0));	/* JTAG_TMS */
+	MUX_VAL(CP(JTAG_TDI), (IEN | PTD | DIS | M0));	/* JTAG_TDI */
+	MUX_VAL(CP(JTAG_EMU0), (IEN | PTD | DIS | M0));	/* JTAG_EMU0 */
+	MUX_VAL(CP(JTAG_EMU1), (IEN | PTD | DIS | M0));	/* JTAG_EMU1 */
+	/* HSUSB1_TLL_STP */
+	MUX_VAL(CP(ETK_CLK_ES2), (IDIS | PTU | EN | M0));
+	/* HSUSB1_TLL_CLK */
+	MUX_VAL(CP(ETK_CTL_ES2), (IDIS | PTD | DIS | M0));
+	/* HSUSB1_TLL_DATA0 */
+	MUX_VAL(CP(ETK_D0_ES2), (IEN | PTD | DIS | M1));
+	/* MCSPI3_CS0 */
+	MUX_VAL(CP(ETK_D1_ES2), (IEN | PTD | DIS | M1));
+	/* HSUSB1_TLL_DATA2 */
+	MUX_VAL(CP(ETK_D2_ES2), (IEN | PTD | EN | M1));
+	/* HSUSB1_TLL_DATA7 */
+	MUX_VAL(CP(ETK_D3_ES2), (IEN | PTD | DIS | M1));
+	/* HSUSB1_TLL_DATA4 */
+	MUX_VAL(CP(ETK_D4_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB1_TLL_DATA5 */
+	MUX_VAL(CP(ETK_D5_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB1_TLL_DATA6 */
+	MUX_VAL(CP(ETK_D6_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB1_TLL_DATA3 */
+	MUX_VAL(CP(ETK_D7_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB1_TLL_DIR */
+	MUX_VAL(CP(ETK_D8_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB1_TLL_NXT */
+	MUX_VAL(CP(ETK_D9_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB2_TLL_CLK */
+	MUX_VAL(CP(ETK_D10_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB2_TLL_STP */
+	MUX_VAL(CP(ETK_D11_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB2_TLL_DIR */
+	MUX_VAL(CP(ETK_D12_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB2_TLL_NXT */
+	MUX_VAL(CP(ETK_D13_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB2_TLL_DATA0 */
+	MUX_VAL(CP(ETK_D14_ES2), (IEN | PTD | DIS | M0));
+	/* HSUSB2_TLL_DATA1 */
+	MUX_VAL(CP(ETK_D15_ES2), (IEN | PTD | DIS | M0));
+
+	/* DIE TO DIE */
+	MUX_VAL(CP(D2D_MCAD0), (IEN | PTD | EN | M0));	/* D2D_MCAD0 */
+	MUX_VAL(CP(D2D_MCAD1), (IEN | PTD | EN | M0));	/* D2D_MCAD1 */
+	MUX_VAL(CP(D2D_MCAD2), (IEN | PTD | EN | M0));	/* D2D_MCAD2 */
+	MUX_VAL(CP(D2D_MCAD3), (IEN | PTD | EN | M0));	/* D2D_MCAD3 */
+	MUX_VAL(CP(D2D_MCAD4), (IEN | PTD | EN | M0));	/* D2D_MCAD4 */
+	MUX_VAL(CP(D2D_MCAD5), (IEN | PTD | EN | M0));	/* D2D_MCAD5 */
+	MUX_VAL(CP(D2D_MCAD6), (IEN | PTD | EN | M0));	/* D2D_MCAD6 */
+	MUX_VAL(CP(D2D_MCAD7), (IEN | PTD | EN | M0));	/* D2D_MCAD7 */
+	MUX_VAL(CP(D2D_MCAD8), (IEN | PTD | EN | M0));	/* D2D_MCAD8 */
+	MUX_VAL(CP(D2D_MCAD9), (IEN | PTD | EN | M0));	/* D2D_MCAD9 */
+	MUX_VAL(CP(D2D_MCAD10), (IEN | PTD | EN | M0));	/* D2D_MCAD10 */
+	MUX_VAL(CP(D2D_MCAD11), (IEN | PTD | EN | M0));	/* D2D_MCAD11 */
+	MUX_VAL(CP(D2D_MCAD12), (IEN | PTD | EN | M0));	/* D2D_MCAD12 */
+	MUX_VAL(CP(D2D_MCAD13), (IEN | PTD | EN | M0));	/* D2D_MCAD13 */
+	MUX_VAL(CP(D2D_MCAD14), (IEN | PTD | EN | M0));	/* D2D_MCAD14 */
+	MUX_VAL(CP(D2D_MCAD15), (IEN | PTD | EN | M0));	/* D2D_MCAD15 */
+	MUX_VAL(CP(D2D_MCAD16), (IEN | PTD | EN | M0));	/* D2D_MCAD16 */
+	MUX_VAL(CP(D2D_MCAD17), (IEN | PTD | EN | M0));	/* D2D_MCAD17 */
+	MUX_VAL(CP(D2D_MCAD18), (IEN | PTD | EN | M0));	/* D2D_MCAD18 */
+	MUX_VAL(CP(D2D_MCAD19), (IEN | PTD | EN | M0));	/* D2D_MCAD19 */
+	MUX_VAL(CP(D2D_MCAD20), (IEN | PTD | EN | M0));	/* D2D_MCAD20 */
+	MUX_VAL(CP(D2D_MCAD21), (IEN | PTD | EN | M0));	/* D2D_MCAD21 */
+	MUX_VAL(CP(D2D_MCAD22), (IEN | PTD | EN | M0));	/* D2D_MCAD22 */
+	MUX_VAL(CP(D2D_MCAD23), (IEN | PTD | EN | M0));	/* D2D_MCAD23 */
+	MUX_VAL(CP(D2D_MCAD24), (IEN | PTD | EN | M0));	/* D2D_MCAD24 */
+	MUX_VAL(CP(D2D_MCAD25), (IEN | PTD | EN | M0));	/* D2D_MCAD25 */
+	MUX_VAL(CP(D2D_MCAD26), (IEN | PTD | EN | M0));	/* D2D_MCAD26 */
+	MUX_VAL(CP(D2D_MCAD27), (IEN | PTD | EN | M0));	/* D2D_MCAD27 */
+	MUX_VAL(CP(D2D_MCAD28), (IEN | PTD | EN | M0));	/* D2D_MCAD28 */
+	MUX_VAL(CP(D2D_MCAD29), (IEN | PTD | EN | M0));	/* D2D_MCAD29 */
+	MUX_VAL(CP(D2D_MCAD30), (IEN | PTD | EN | M0));	/* D2D_MCAD30 */
+	MUX_VAL(CP(D2D_MCAD31), (IEN | PTD | EN | M0));	/* D2D_MCAD31 */
+	MUX_VAL(CP(D2D_MCAD32), (IEN | PTD | EN | M0));	/* D2D_MCAD32 */
+	MUX_VAL(CP(D2D_MCAD33), (IEN | PTD | EN | M0));	/* D2D_MCAD33 */
+	MUX_VAL(CP(D2D_MCAD34), (IEN | PTD | EN | M0));	/* D2D_MCAD34 */
+	MUX_VAL(CP(D2D_MCAD35), (IEN | PTD | EN | M0));	/* D2D_MCAD35 */
+	MUX_VAL(CP(D2D_MCAD36), (IEN | PTD | EN | M0));	/* D2D_MCAD36 */
+	/* D2D_CLK26MI  */
+	MUX_VAL(CP(D2D_CLK26MI), (IEN | PTD | DIS | M0));
+	/* D2D_NRESPWRON */
+	MUX_VAL(CP(D2D_NRESPWRON), (IEN | PTD | EN | M0));
+	/* D2D_NRESWARM */
+	MUX_VAL(CP(D2D_NRESWARM), (IEN | PTU | EN | M0));
+	/* D2D_ARM9NIRQ */
+	MUX_VAL(CP(D2D_ARM9NIRQ), (IEN | PTD | DIS | M0));
+	/* D2D_UMA2P6FIQ */
+	MUX_VAL(CP(D2D_UMA2P6FIQ), (IEN | PTD | DIS | M0));
+	/* D2D_SPINT */
+	MUX_VAL(CP(D2D_SPINT), (IEN | PTD | EN | M0));
+	/* D2D_FRINT */
+	MUX_VAL(CP(D2D_FRINT), (IEN | PTD | EN | M0));
+	/* D2D_DMAREQ0  */
+	MUX_VAL(CP(D2D_DMAREQ0), (IEN | PTD | DIS | M0));
+	/* D2D_DMAREQ1  */
+	MUX_VAL(CP(D2D_DMAREQ1), (IEN | PTD | DIS | M0));
+	/* D2D_DMAREQ2  */
+	MUX_VAL(CP(D2D_DMAREQ2), (IEN | PTD | DIS | M0));
+	/* D2D_DMAREQ3  */
+	MUX_VAL(CP(D2D_DMAREQ3), (IEN | PTD | DIS | M0));
+	/* D2D_N3GTRST  */
+	MUX_VAL(CP(D2D_N3GTRST), (IEN | PTD | DIS | M0));
+	/* D2D_N3GTDI */
+	MUX_VAL(CP(D2D_N3GTDI), (IEN | PTD | DIS | M0));
+	/* D2D_N3GTDO */
+	MUX_VAL(CP(D2D_N3GTDO), (IEN | PTD | DIS | M0));
+	/* D2D_N3GTMS */
+	MUX_VAL(CP(D2D_N3GTMS), (IEN | PTD | DIS | M0));
+	/* D2D_N3GTCK */
+	MUX_VAL(CP(D2D_N3GTCK), (IEN | PTD | DIS | M0));
+	/* D2D_N3GRTCK  */
+	MUX_VAL(CP(D2D_N3GRTCK), (IEN | PTD | DIS | M0));
+	/* D2D_MSTDBY */
+	MUX_VAL(CP(D2D_MSTDBY), (IEN | PTU | EN | M0));
+	/* D2D_SWAKEUP */
+	MUX_VAL(CP(D2D_SWAKEUP), (IEN | PTD | EN | M0));
+	/* D2D_IDLEREQ */
+	MUX_VAL(CP(D2D_IDLEREQ), (IEN | PTD | DIS | M0));
+	/* D2D_IDLEACK */
+	MUX_VAL(CP(D2D_IDLEACK), (IEN | PTU | EN | M0));
+	/* D2D_MWRITE */
+	MUX_VAL(CP(D2D_MWRITE), (IEN | PTD | DIS | M0));
+	/* D2D_SWRITE */
+	MUX_VAL(CP(D2D_SWRITE), (IEN | PTD | DIS | M0));
+	/* D2D_MREAD */
+	MUX_VAL(CP(D2D_MREAD), (IEN | PTD | DIS | M0));
+	/* D2D_SREAD */
+	MUX_VAL(CP(D2D_SREAD), (IEN | PTD | DIS | M0));
+	/* D2D_MBUSFLAG */
+	MUX_VAL(CP(D2D_MBUSFLAG), (IEN | PTD | DIS | M0));
+	/* D2D_SBUSFLAG */
+	MUX_VAL(CP(D2D_SBUSFLAG), (IEN | PTD | DIS | M0));
+	/* SDRC_CKE0 */
+	MUX_VAL(CP(SDRC_CKE0), (IDIS | PTU | EN | M0));
+	/* SDRC_CKE1 NOT USED */
+	MUX_VAL(CP(SDRC_CKE1), (IDIS | PTD | DIS | M7));
+#endif				/* CONFIG_MACH_OMAP_ADVANCED_MUX */
+}
+
+/******************** Board Run Time *******************/
+
+/*-----------------------CONSOLE  Devices -----------------------------------*/
+
+#ifdef CONFIG_DRIVER_SERIAL_NS16550
+
+static struct NS16550_plat serial_plat = {
+	.clock = 48000000,	/* 48MHz (APLL96/2) */
+	.shift = 2,
+};
+
+/**
+ * @brief UART serial port initialization - remember to enable COM clocks in arch
+ *
+ * @return result of device registration
+ */
+static int sdp3430_console_init(void)
+{
+	/* Register the serial port */
+	add_ns16550_device(-1, OMAP_UART3_BASE, 1024, IORESOURCE_MEM_8BIT,
+			   &serial_plat);
+
+	return 0;
+}
+
+console_initcall(sdp3430_console_init);
+#endif				/* CONFIG_DRIVER_SERIAL_NS16550 */
+
+static int sdp3430_mem_init(void)
+{
+	arm_add_mem_device("ram0", 0x80000000, 128 * 1024 * 1024);
+
+	return 0;
+}
+mem_initcall(sdp3430_mem_init);
+
+static int sdp3430_devices_init(void)
+{
+#ifdef CONFIG_OMAP_GPMC
+	/* WP is made high and WAIT1 active Low */
+	gpmc_generic_init(0x10);
+#endif
+
+	return 0;
+}
+
+device_initcall(sdp3430_devices_init);
diff -ruN barebox-2012.02.0/arch/arm/boards/omap343xdsp/config.h barebox-2012.02.0-ccu2/arch/arm/boards/omap343xdsp/config.h
--- barebox-2012.02.0/arch/arm/boards/omap343xdsp/config.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/omap343xdsp/config.h	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,21 @@
+/**
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#endif	/* __CONFIG_H */
diff -ruN barebox-2012.02.0/arch/arm/boards/omap343xdsp/Makefile barebox-2012.02.0-ccu2/arch/arm/boards/omap343xdsp/Makefile
--- barebox-2012.02.0/arch/arm/boards/omap343xdsp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/omap343xdsp/Makefile	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1 @@
+obj-y += board.o
diff -ruN barebox-2012.02.0/arch/arm/boards/omap3evm/board.c barebox-2012.02.0-ccu2/arch/arm/boards/omap3evm/board.c
--- barebox-2012.02.0/arch/arm/boards/omap3evm/board.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/omap3evm/board.c	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,271 @@
+/**
+ * @file
+ * @brief Board Initialization routines for OMAP3EVM.
+ *
+ * FileName: arch/arm/boards/omap/board-omap3evm.c
+ *
+ * This board is based on OMAP3530.
+ * More on OMAP3530 (including documentation can be found here):
+ * http://focus.ti.com/docs/prod/folders/print/omap3530.html
+ *
+ * This file provides initialization in two stages:
+ * @li Boot time initialization - just get SDRAM working.
+ * This is run from SRAM - so no case constructs and global vars can be used.
+ * @li Run time initialization - this is for the rest of the initializations
+ * such as flash, uart etc.
+ *
+ * Boot time initialization includes:
+ * @li SDRAM initialization.
+ * @li Pin Muxing relevant for the EVM.
+ *
+ * Run time initialization includes
+ * @li serial @ref serial_ns16550.c driver device definition
+ *
+ * Originally from arch/arm/boards/omap/board-beagle.c
+ */
+
+/*
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ * Sanjeev Premi <premi@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+#include <console.h>
+#include <init.h>
+#include <driver.h>
+#include <io.h>
+#include <sizes.h>
+#include <ns16550.h>
+#include <asm/armlinux.h>
+#include <mach/silicon.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/control.h>
+#include <mach/omap3-mux.h>
+#include <mach/gpmc.h>
+#include <errno.h>
+#include <generated/mach-types.h>
+
+
+/*
+ * Boot-time initialization(s)
+ */
+
+/**
+ * @brief Initialize the SDRC module
+ *
+ * @return void
+ */
+static void sdrc_init(void)
+{
+	/* SDRAM software reset */
+	/* No idle ack and RESET enable */
+	writel(0x1A, SDRC_REG(SYSCONFIG));
+	sdelay(100);
+	/* No idle ack and RESET disable */
+	writel(0x18, SDRC_REG(SYSCONFIG));
+
+	/* SDRC Sharing register */
+	/* 32-bit SDRAM on data lane [31:0] - CS0 */
+	/* pin tri-stated = 1 */
+	writel(0x00000100, SDRC_REG(SHARING));
+
+	/* ----- SDRC Registers Configuration --------- */
+	/* SDRC_MCFG0 register */
+	writel(0x02584099, SDRC_REG(MCFG_0));
+
+	/* SDRC_RFR_CTRL0 register */
+	writel(0x54601, SDRC_REG(RFR_CTRL_0));
+
+	/* SDRC_ACTIM_CTRLA0 register */
+	writel(0xA29DB4C6, SDRC_REG(ACTIM_CTRLA_0));
+
+	/* SDRC_ACTIM_CTRLB0 register */
+	writel(0x12214, SDRC_REG(ACTIM_CTRLB_0));
+
+	/* Disble Power Down of CKE due to 1 CKE on combo part */
+	writel(0x00000081, SDRC_REG(POWER));
+
+	/* SDRC_MANUAL command register */
+	/* NOP command */
+	writel(0x00000000, SDRC_REG(MANUAL_0));
+	/* Precharge command */
+	writel(0x00000001, SDRC_REG(MANUAL_0));
+	/* Auto-refresh command */
+	writel(0x00000002, SDRC_REG(MANUAL_0));
+	/* Auto-refresh command */
+	writel(0x00000002, SDRC_REG(MANUAL_0));
+
+	/* SDRC MR0 register Burst length=4 */
+	writel(0x00000032, SDRC_REG(MR_0));
+
+	/* SDRC DLLA control register */
+	writel(0x0000000A, SDRC_REG(DLLA_CTRL));
+
+	return;
+}
+
+/**
+ * @brief Do the necessary pin muxing required for OMAP3EVM. Some pins in OMAP3
+ * do not have alternate modes. We don't program these pins.
+ *
+ * See @ref MUX_VAL for description of the muxing mode.
+ *
+ * @return void
+ */
+static void mux_config(void)
+{
+	/*
+	 * SDRC
+	 * - SDRC_D0-SDRC_D31: Default MUX mode is mode0.
+	 */
+
+	/*
+	 * GPMC
+	 * - GPMC_D0-GPMC_D7: Default MUX mode is mode0.
+	 * - GPMC_NADV_ALE: Default MUX mode is mode0.
+	 * - GPMC_NOE: Default MUX mode is mode0.
+	 * - GPMC_NWE: Default MUX mode is mode0.
+	 * - GPMC_WAIT0: Default MUX mode is mode0.
+	 */
+	MUX_VAL(CP(GPMC_A1),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A2),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A3),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A4),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A5),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A6),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A7),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A8),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A9),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_A10),		(IDIS | PTD | DIS | M0));
+
+	MUX_VAL(CP(GPMC_D8),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D9),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D10),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D11),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D12),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D13),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D14),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_D15),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_CLK),		(IDIS | PTD | DIS | M0));
+
+	MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0));
+
+	MUX_VAL(CP(GPMC_WAIT1),		(IEN  | PTU | EN  | M0));
+
+	/*
+	 * Serial Interface
+	 */
+#if defined(CONFIG_OMAP3EVM_UART1)
+	MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART1_CTS),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0));
+#elif defined(CONFIG_OMAP3EVM_UART3)
+	MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0));
+#endif
+}
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+static int omap3_evm_board_init(void)
+{
+	int in_sdram = running_in_sdram();
+
+	omap3_core_init();
+
+	mux_config();
+
+	/* Dont reconfigure SDRAM while running in SDRAM! */
+	if (!in_sdram)
+		sdrc_init();
+
+	return 0;
+}
+pure_initcall(omap3_evm_board_init);
+
+/*
+ * Run-time initialization(s)
+ */
+
+#ifdef CONFIG_DRIVER_SERIAL_NS16550
+
+static struct NS16550_plat serial_plat = {
+	.clock		= 48000000,      /* 48MHz (APLL96/2) */
+	.shift		= 2,
+};
+
+/**
+ * @brief Initialize the serial port to be used as console.
+ *
+ * @return result of device registration
+ */
+static int omap3evm_init_console(void)
+{
+	add_ns16550_device(-1,
+#if defined(CONFIG_OMAP3EVM_UART1)
+			OMAP_UART1_BASE,
+#elif defined(CONFIG_OMAP3EVM_UART3)
+			OMAP_UART3_BASE,
+#endif
+			1024, IORESOURCE_MEM_8BIT, &serial_plat);
+
+	return 0;
+}
+console_initcall(omap3evm_init_console);
+#endif /* CONFIG_DRIVER_SERIAL_NS16550 */
+
+static int omap3evm_mem_init(void)
+{
+	arm_add_mem_device("ram0", 0x80000000, 128 * 1024 * 1024);
+
+	return 0;
+}
+mem_initcall(omap3evm_mem_init);
+
+static int omap3evm_init_devices(void)
+{
+#ifdef CONFIG_OMAP_GPMC
+	/*
+	 * WP is made high and WAIT1 active Low
+	 */
+	gpmc_generic_init(0x10);
+#endif
+#ifdef CONFIG_MCI_OMAP_HSMMC
+	add_generic_device("omap-hsmmc", -1, NULL, OMAP_MMC1_BASE, SZ_4K,
+				IORESOURCE_MEM, NULL);
+#endif
+        armlinux_set_bootparams((void *)0x80000100);
+        armlinux_set_architecture(MACH_TYPE_OMAP3EVM);
+
+	return 0;
+}
+device_initcall(omap3evm_init_devices);
diff -ruN barebox-2012.02.0/arch/arm/boards/omap3evm/config.h barebox-2012.02.0-ccu2/arch/arm/boards/omap3evm/config.h
--- barebox-2012.02.0/arch/arm/boards/omap3evm/config.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/omap3evm/config.h	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,21 @@
+/**
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#endif	/* __CONFIG_H */
diff -ruN barebox-2012.02.0/arch/arm/boards/omap3evm/Makefile barebox-2012.02.0-ccu2/arch/arm/boards/omap3evm/Makefile
--- barebox-2012.02.0/arch/arm/boards/omap3evm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/omap3evm/Makefile	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1 @@
+obj-y += board.o
diff -ruN barebox-2012.02.0/arch/arm/boards/pcm043/pcm043.c barebox-2012.02.0-ccu2/arch/arm/boards/pcm043/pcm043.c
--- barebox-2012.02.0/arch/arm/boards/pcm043/pcm043.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/pcm043/pcm043.c	2013-01-14 12:46:28.000000000 +0100
@@ -29,6 +29,7 @@
 #include <driver.h>
 #include <environment.h>
 #include <fs.h>
+#include <sizes.h>
 #include <mach/imx-regs.h>
 #include <asm/armlinux.h>
 #include <mach/gpio.h>
@@ -56,52 +57,53 @@
 	.flash_bbt = 1,
 };
 
-#ifdef CONFIG_PCM043_DISPLAY_SHARP
-static struct fb_videomode pcm043_fb_mode = {
-	/* 240x320 @ 60 Hz */
-	.name		= "Sharp-LQ035Q7",
-	.refresh	= 60,
-	.xres		= 240,
-	.yres		= 320,
-	.pixclock	= 185925,
-	.left_margin	= 9,
-	.right_margin	= 16,
-	.upper_margin	= 7,
-	.lower_margin	= 9,
-	.hsync_len	= 1,
-	.vsync_len	= 1,
-	.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_SHARP_MODE | FB_SYNC_CLK_INVERT | FB_SYNC_CLK_IDLE_EN,
-	.vmode		= FB_VMODE_NONINTERLACED,
-	.flag		= 0,
+static struct fb_videomode pcm043_fb_mode[] = {
+	{
+		/* 240x320 @ 60 Hz */
+		.name		= "TX090",
+		.refresh	= 60,
+		.xres		= 240,
+		.yres		= 320,
+		.pixclock	= 38255,
+		.left_margin	= 144,
+		.right_margin	= 0,
+		.upper_margin	= 7,
+		.lower_margin	= 40,
+		.hsync_len	= 96,
+		.vsync_len	= 1,
+		.sync		= FB_SYNC_VERT_HIGH_ACT | FB_SYNC_OE_ACT_HIGH,
+		.vmode		= FB_VMODE_NONINTERLACED,
+		.flag		= 0,
+	}, {
+		/* 240x320 @ 60 Hz */
+		.name		= "Sharp-LQ035Q7",
+		.refresh	= 60,
+		.xres		= 240,
+		.yres		= 320,
+		.pixclock	= 185925,
+		.left_margin	= 9,
+		.right_margin	= 16,
+		.upper_margin	= 7,
+		.lower_margin	= 9,
+		.hsync_len	= 1,
+		.vsync_len	= 1,
+		.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_SHARP_MODE | \
+				 FB_SYNC_CLK_INVERT | FB_SYNC_CLK_IDLE_EN,
+		.vmode		= FB_VMODE_NONINTERLACED,
+		.flag		= 0,
+	}
 };
-#else
-static struct fb_videomode pcm043_fb_mode = {
-	/* 240x320 @ 60 Hz */
-	.name		= "TX090",
-	.refresh	= 60,
-	.xres		= 240,
-	.yres		= 320,
-	.pixclock	= 38255,
-	.left_margin	= 144,
-	.right_margin	= 0,
-	.upper_margin	= 7,
-	.lower_margin	= 40,
-	.hsync_len	= 96,
-	.vsync_len	= 1,
-	.sync		= FB_SYNC_VERT_HIGH_ACT | FB_SYNC_OE_ACT_HIGH,
-	.vmode		= FB_VMODE_NONINTERLACED,
-	.flag		= 0,
-};
-#endif
 
 static struct imx_ipu_fb_platform_data ipu_fb_data = {
-	.mode		= &pcm043_fb_mode,
-	.bpp		= 16,
+	.mode			= pcm043_fb_mode,
+	.num_modes		= ARRAY_SIZE(pcm043_fb_mode),
+	.framebuffer_ovl	= (void *) (IMX_SDRAM_CS0 + SZ_128M - SZ_1M),
+	.bpp			= 16,
 };
 
 static int pcm043_mem_init(void)
 {
-	arm_add_mem_device("ram0", IMX_SDRAM_CS0, 128 * 1024 * 1024);
+	arm_add_mem_device("ram0", IMX_SDRAM_CS0, SZ_128M);
 
 	return 0;
 }
diff -ruN barebox-2012.02.0/arch/arm/boards/phycard-a-l1/Makefile barebox-2012.02.0-ccu2/arch/arm/boards/phycard-a-l1/Makefile
--- barebox-2012.02.0/arch/arm/boards/phycard-a-l1/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/phycard-a-l1/Makefile	2013-01-14 12:46:26.000000000 +0100
@@ -18,5 +18,4 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 # MA 02111-1307 USA
 
-obj-$(CONFIG_MACH_DO_LOWLEVEL_INIT) += lowlevel.o
 obj-y += pca-a-l1.o
diff -ruN barebox-2012.02.0/arch/arm/boards/phycard-a-l1/pca-a-l1.c barebox-2012.02.0-ccu2/arch/arm/boards/phycard-a-l1/pca-a-l1.c
--- barebox-2012.02.0/arch/arm/boards/phycard-a-l1/pca-a-l1.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/phycard-a-l1/pca-a-l1.c	2013-01-14 12:46:26.000000000 +0100
@@ -74,8 +74,6 @@
 #include <mach/syslib.h>
 #include <mach/xload.h>
 
-#include "pca-a-l1.h"
-
 #define SMC911X_BASE 0x2c000000
 
 /*
@@ -224,15 +222,20 @@
  *
  * @return void
  */
-void board_init(void)
+static int pcaal1_board_init(void)
 {
 	int in_sdram = running_in_sdram();
 
+	omap3_core_init();
+
 	pcaal1_mux_config();
 	/* Dont reconfigure SDRAM while running in SDRAM! */
 	if (!in_sdram)
 		pcaal1_sdrc_init();
+
+	return 0;
 }
+pure_initcall(pcaal1_board_init);
 
 /*
  * Run-time initialization(s)
diff -ruN barebox-2012.02.0/arch/arm/boards/pm9261/config.h barebox-2012.02.0-ccu2/arch/arm/boards/pm9261/config.h
--- barebox-2012.02.0/arch/arm/boards/pm9261/config.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/pm9261/config.h	2013-01-14 12:46:22.000000000 +0100
@@ -61,15 +61,16 @@
 #define CONFIG_SYS_SDRC_TR_VAL2		1200		/* SDRAM_TR */
 
 /* setup SMC0, CS0 (NOR Flash) - 16-bit, 15 WS */
-#define CONFIG_SYS_SMC0_SETUP0_VAL					\
+#define CONFIG_SYS_SMC_CS	0
+#define CONFIG_SYS_SMC_SETUP_VAL					\
 		(AT91_SMC_NWESETUP_(10) | AT91_SMC_NCS_WRSETUP_(10) |	\
 		 AT91_SMC_NRDSETUP_(10) | AT91_SMC_NCS_RDSETUP_(10))
-#define CONFIG_SYS_SMC0_PULSE0_VAL					\
+#define CONFIG_SYS_SMC_PULSE_VAL					\
 		(AT91_SMC_NWEPULSE_(11) | AT91_SMC_NCS_WRPULSE_(11) |	\
 		 AT91_SMC_NRDPULSE_(11) | AT91_SMC_NCS_RDPULSE_(11))
-#define CONFIG_SYS_SMC0_CYCLE0_VAL	\
+#define CONFIG_SYS_SMC_CYCLE_VAL	\
 		(AT91_SMC_NWECYCLE_(22) | AT91_SMC_NRDCYCLE_(22))
-#define CONFIG_SYS_SMC0_MODE0_VAL				\
+#define CONFIG_SYS_SMC_MODE_VAL					\
 		(AT91_SMC_READMODE | AT91_SMC_WRITEMODE |	\
 		 AT91_SMC_DBW_16 |				\
 		 AT91_SMC_TDFMODE |				\
diff -ruN barebox-2012.02.0/arch/arm/boards/pm9263/config.h barebox-2012.02.0-ccu2/arch/arm/boards/pm9263/config.h
--- barebox-2012.02.0/arch/arm/boards/pm9263/config.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/pm9263/config.h	2013-01-14 12:46:22.000000000 +0100
@@ -76,15 +76,16 @@
 #define CONFIG_SYS_SDRC_TR_VAL2		1200		/* SDRAM_TR */
 
 /* setup SMC0, CS0 (NOR Flash) - 16-bit, 15 WS */
-#define CONFIG_SYS_SMC0_SETUP0_VAL					\
+#define CONFIG_SYS_SMC_CS	0
+#define CONFIG_SYS_SMC_SETUP_VAL					\
 		(AT91_SMC_NWESETUP_(10) | AT91_SMC_NCS_WRSETUP_(10) |	\
 		 AT91_SMC_NRDSETUP_(10) | AT91_SMC_NCS_RDSETUP_(10))
-#define CONFIG_SYS_SMC0_PULSE0_VAL					\
+#define CONFIG_SYS_SMC_PULSE_VAL					\
 		(AT91_SMC_NWEPULSE_(11) | AT91_SMC_NCS_WRPULSE_(11) |	\
 		 AT91_SMC_NRDPULSE_(11) | AT91_SMC_NCS_RDPULSE_(11))
-#define CONFIG_SYS_SMC0_CYCLE0_VAL	\
+#define CONFIG_SYS_SMC_CYCLE_VAL	\
 		(AT91_SMC_NWECYCLE_(22) | AT91_SMC_NRDCYCLE_(22))
-#define CONFIG_SYS_SMC0_MODE0_VAL				\
+#define CONFIG_SYS_SMC_MODE_VAL					\
 		(AT91_SMC_READMODE | AT91_SMC_WRITEMODE |	\
 		 AT91_SMC_DBW_16 |				\
 		 AT91_SMC_TDFMODE |				\
diff -ruN barebox-2012.02.0/arch/arm/boards/tny-a926x/config.h barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/config.h
--- barebox-2012.02.0/arch/arm/boards/tny-a926x/config.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/config.h	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define AT91_MAIN_CLOCK		12000000	/* 12 MHz crystal */
+
+#endif	/* __CONFIG_H */
diff -ruN barebox-2012.02.0/arch/arm/boards/tny-a926x/env/bin/init_board barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/env/bin/init_board
--- barebox-2012.02.0/arch/arm/boards/tny-a926x/env/bin/init_board	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/env/bin/init_board	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+if [ $at91_udc0.vbus != 1 ]
+then
+	echo "No USB Device cable plugged, normal boot"
+	exit
+fi
+
+autoboot_timeout=16
+echo "enable tty over USB Device, increase the boot delay to ${autoboot_timeout}s"
+usbserial
diff -ruN barebox-2012.02.0/arch/arm/boards/tny-a926x/env/config barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/env/config
--- barebox-2012.02.0/arch/arm/boards/tny-a926x/env/config	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/env/config	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,36 @@
+#!/bin/sh
+
+# use 'dhcp' to do dhcp in barebox and in kernel
+# use 'none' if you want to skip kernel ip autoconfiguration
+ip=none
+
+# or set your networking parameters here
+#eth0.ipaddr=a.b.c.d
+#eth0.netmask=a.b.c.d
+#eth0.gateway=a.b.c.d
+#eth0.serverip=a.b.c.d
+
+# can be either 'nfs', 'tftp', 'nor' or 'nand'
+kernel_loc=nand
+# can be either 'net', 'nor', 'nand' or 'initrd'
+rootfs_loc=nand
+
+# can be either 'jffs2' or 'ubifs'
+rootfs_type=ubifs
+rootfsimage=root.$rootfs_type
+
+#kernelimage=zImage
+kernelimage=uImage
+#kernelimage=Image
+#kernelimage=Image.lzo
+
+nand_device=atmel_nand
+nand_parts="128k(at91bootstrap),256k(barebox)ro,128k(bareboxenv),128k(bareboxenv2),4M(kernel),120M(rootfs),-(data)"
+rootfs_mtdblock_nand=5
+
+autoboot_timeout=3
+
+bootargs="console=ttyS0,115200"
+
+# set a fancy prompt (if support is compiled in)
+PS1="\e[1;32mbarebox@\e[1;31m\h:\w\e[0m\n# "
diff -ruN barebox-2012.02.0/arch/arm/boards/tny-a926x/init.c barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/init.c
--- barebox-2012.02.0/arch/arm/boards/tny-a926x/init.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/init.c	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2011 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <common.h>
+#include <net.h>
+#include <init.h>
+#include <environment.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <partition.h>
+#include <fs.h>
+#include <fcntl.h>
+#include <io.h>
+#include <asm/hardware.h>
+#include <nand.h>
+#include <sizes.h>
+#include <linux/mtd/nand.h>
+#include <linux/clk.h>
+#include <mach/board.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/sam9_smc.h>
+#include <gpio.h>
+#include <mach/io.h>
+#include <mach/at91_pmc.h>
+#include <mach/at91_rstc.h>
+#include <spi/eeprom.h>
+
+static void tny_a9260_set_board_type(void)
+{
+	if (machine_is_tny_a9g20())
+		armlinux_set_architecture(MACH_TYPE_TNY_A9G20);
+	else if (machine_is_tny_a9263())
+		armlinux_set_architecture(MACH_TYPE_TNY_A9263);
+	else
+		armlinux_set_architecture(MACH_TYPE_TNY_A9260);
+}
+
+static struct atmel_nand_data nand_pdata = {
+	.ale		= 21,
+	.cle		= 22,
+	.det_pin	= 0,
+	.rdy_pin	= AT91_PIN_PC13,
+	.enable_pin	= AT91_PIN_PC14,
+	.on_flash_bbt	= 1,
+};
+
+static struct sam9_smc_config tny_a9260_nand_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 1,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 1,
+
+	.ncs_read_pulse		= 3,
+	.nrd_pulse		= 3,
+	.ncs_write_pulse	= 3,
+	.nwe_pulse		= 3,
+
+	.read_cycle		= 5,
+	.write_cycle		= 5,
+
+	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | \
+				  AT91_SMC_EXNWMODE_DISABLE | AT91_SMC_DBW_8,
+	.tdf_cycles		= 2,
+};
+
+static struct sam9_smc_config tny_a9g20_nand_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 2,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 2,
+
+	.ncs_read_pulse		= 4,
+	.nrd_pulse		= 4,
+	.ncs_write_pulse	= 4,
+	.nwe_pulse		= 2,
+
+	.read_cycle		= 7,
+	.write_cycle		= 7,
+
+	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | \
+				  AT91_SMC_EXNWMODE_DISABLE | AT91_SMC_DBW_8,
+	.tdf_cycles		= 3,
+};
+
+static void tny_a9260_add_device_nand(void)
+{
+	/* configure chip-select 3 (NAND) */
+	if (machine_is_tny_a9g20())
+		sam9_smc_configure(3, &tny_a9g20_nand_smc_config);
+	else
+		sam9_smc_configure(3, &tny_a9260_nand_smc_config);
+
+	if (machine_is_tny_a9263()) {
+		nand_pdata.rdy_pin	= AT91_PIN_PA22;
+		nand_pdata.enable_pin	= AT91_PIN_PD15;
+	}
+
+	at91_add_device_nand(&nand_pdata);
+}
+
+#ifdef CONFIG_DRIVER_NET_MACB
+static struct at91_ether_platform_data macb_pdata = {
+	.flags		= AT91SAM_ETHER_RMII,
+	.phy_addr	= 0,
+};
+
+static void tny_a9260_phy_reset(void)
+{
+	unsigned long rstc;
+	struct clk *clk = clk_get(NULL, "macb_clk");
+
+	clk_enable(clk);
+
+	at91_set_gpio_input(AT91_PIN_PA14, 0);
+	at91_set_gpio_input(AT91_PIN_PA15, 0);
+	at91_set_gpio_input(AT91_PIN_PA17, 0);
+	at91_set_gpio_input(AT91_PIN_PA25, 0);
+	at91_set_gpio_input(AT91_PIN_PA26, 0);
+	at91_set_gpio_input(AT91_PIN_PA28, 0);
+
+	rstc = at91_sys_read(AT91_RSTC_MR) & AT91_RSTC_ERSTL;
+
+	/* Need to reset PHY -> 500ms reset */
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY |
+				     (AT91_RSTC_ERSTL & (0x0d << 8)) |
+				     AT91_RSTC_URSTEN);
+
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_EXTRST);
+
+	/* Wait for end hardware reset */
+	while (!(at91_sys_read(AT91_RSTC_SR) & AT91_RSTC_NRSTL));
+
+	/* Restore NRST value */
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY |
+				     (rstc) |
+				     AT91_RSTC_URSTEN);
+}
+
+static void __init ek_add_device_macb(void)
+{
+	tny_a9260_phy_reset();
+	at91_add_device_eth(&macb_pdata);
+}
+#else
+static void __init ek_add_device_macb(void) {}
+#endif
+
+/*
+ * USB Device port
+ */
+static struct at91_udc_data __initdata ek_udc_data = {
+	.vbus_pin	= AT91_PIN_PB30,
+	.pullup_pin	= 0,		/* pull-up driven by UDC */
+};
+
+static struct spi_eeprom eeprom = {
+	.name = "at250x0",
+	.size = 8192,
+	.page_size = 32,
+	.flags = EE_ADDR2,	/* 16 bits address */
+};
+
+static struct spi_board_info tny_a9g20_spi_devices[] = {
+	{
+		.name = "at25x",
+		.max_speed_hz = 1 * 1000 * 1000,	/* max spi clock (SCK) speed in HZ */
+		.bus_num = 0,
+		.chip_select = 0,
+		.platform_data = &eeprom,
+	},
+};
+
+static int spi0_standard_cs[] = { AT91_PIN_PC11 };
+struct at91_spi_platform_data spi_pdata = {
+	.chipselect = spi0_standard_cs,
+	.num_chipselect = ARRAY_SIZE(spi0_standard_cs),
+};
+
+static void __init ek_add_device_udc(void)
+{
+	if (machine_is_tny_a9260() || machine_is_tny_a9g20())
+		ek_udc_data.vbus_pin = AT91_PIN_PC5;
+
+	at91_add_device_udc(&ek_udc_data);
+}
+
+static int tny_a9260_mem_init(void)
+{
+	at91_add_device_sdram(64 * 1024 * 1024);
+
+	return 0;
+}
+mem_initcall(tny_a9260_mem_init);
+
+static int tny_a9260_devices_init(void)
+{
+	tny_a9260_add_device_nand();
+	ek_add_device_macb();
+	ek_add_device_udc();
+
+	armlinux_set_bootparams((void *)(AT91_CHIPSELECT_1 + 0x100));
+	tny_a9260_set_board_type();
+
+	if (machine_is_tny_a9260() || machine_is_tny_a9g20()) {
+		spi_register_board_info(tny_a9g20_spi_devices,
+			ARRAY_SIZE(tny_a9g20_spi_devices));
+		at91_add_device_spi(0, &spi_pdata);
+	}
+
+	devfs_add_partition("nand0", 0x00000, SZ_128K, PARTITION_FIXED, "at91bootstrap_raw");
+	dev_add_bb_dev("at91bootstrap_raw", "at91bootstrap");
+	devfs_add_partition("nand0", SZ_128K, SZ_256K, PARTITION_FIXED, "self_raw");
+	dev_add_bb_dev("self_raw", "self0");
+	devfs_add_partition("nand0", SZ_256K + SZ_128K, SZ_128K, PARTITION_FIXED, "env_raw");
+	dev_add_bb_dev("env_raw", "env0");
+	devfs_add_partition("nand0", SZ_512K, SZ_128K, PARTITION_FIXED, "env_raw1");
+	dev_add_bb_dev("env_raw1", "env1");
+
+	return 0;
+}
+device_initcall(tny_a9260_devices_init);
+
+static int tny_a9260_console_init(void)
+{
+	at91_register_uart(0, 0);
+	return 0;
+}
+console_initcall(tny_a9260_console_init);
diff -ruN barebox-2012.02.0/arch/arm/boards/tny-a926x/Makefile barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/Makefile
--- barebox-2012.02.0/arch/arm/boards/tny-a926x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/boards/tny-a926x/Makefile	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1 @@
+obj-y += init.o
diff -ruN barebox-2012.02.0/arch/arm/configs/at91sam9260ek_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/at91sam9260ek_defconfig
--- barebox-2012.02.0/arch/arm/configs/at91sam9260ek_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/at91sam9260ek_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -1,6 +1,8 @@
 CONFIG_ARCH_AT91SAM9260=y
 CONFIG_AEABI=y
+# CONFIG_CMD_ARM_CPUINFO is not set
 CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_EXPERIMENTAL=y
 CONFIG_PROMPT="9260-EK:"
 CONFIG_LONGHELP=y
 CONFIG_GLOB=y
@@ -8,6 +10,8 @@
 CONFIG_HUSH_FANCY_PROMPT=y
 CONFIG_CMDLINE_EDITING=y
 CONFIG_AUTO_COMPLETE=y
+# CONFIG_CONSOLE_ACTIVATE_FIRST is not set
+CONFIG_CONSOLE_ACTIVATE_ALL=y
 CONFIG_DEFAULT_ENVIRONMENT_GENERIC=y
 CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/at91sam9260ek/env"
 CONFIG_CMD_EDIT=y
@@ -24,12 +28,19 @@
 CONFIG_CMD_MTEST_ALTERNATIVE=y
 CONFIG_CMD_FLASH=y
 CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+CONFIG_CMD_UIMAGE=y
+# CONFIG_CMD_BOOTU is not set
 CONFIG_CMD_RESET=y
 CONFIG_CMD_GO=y
 CONFIG_CMD_OFTREE=y
 CONFIG_CMD_TIMEOUT=y
 CONFIG_CMD_PARTITION=y
 CONFIG_CMD_GPIO=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_TRIGGER=y
 CONFIG_NET=y
 CONFIG_NET_DHCP=y
 CONFIG_NET_NFS=y
@@ -40,14 +51,21 @@
 # CONFIG_SPI is not set
 CONFIG_MTD=y
 CONFIG_NAND=y
+# CONFIG_NAND_ECC_HW is not set
+# CONFIG_NAND_ECC_HW_SYNDROME is not set
+# CONFIG_NAND_ECC_HW_NONE is not set
 CONFIG_NAND_ATMEL=y
 CONFIG_UBI=y
 CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DFU=y
+CONFIG_USB_GADGET_SERIAL=y
 CONFIG_MCI=y
 CONFIG_MCI_STARTUP=y
 CONFIG_MCI_ATMEL=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_TRIGGERS=y
 CONFIG_FS_FAT=y
 CONFIG_FS_FAT_WRITE=y
 CONFIG_FS_FAT_LFN=y
 CONFIG_ZLIB=y
-CONFIG_BZLIB=y
diff -ruN barebox-2012.02.0/arch/arm/configs/at91sam9g20ek_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/at91sam9g20ek_defconfig
--- barebox-2012.02.0/arch/arm/configs/at91sam9g20ek_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/at91sam9g20ek_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -1,7 +1,9 @@
 CONFIG_ARCH_AT91SAM9G20=y
 CONFIG_AT91_HAVE_2MMC=y
 CONFIG_AEABI=y
+# CONFIG_CMD_ARM_CPUINFO is not set
 CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_EXPERIMENTAL=y
 CONFIG_PROMPT="9G20-EK:"
 CONFIG_LONGHELP=y
 CONFIG_GLOB=y
@@ -9,6 +11,8 @@
 CONFIG_HUSH_FANCY_PROMPT=y
 CONFIG_CMDLINE_EDITING=y
 CONFIG_AUTO_COMPLETE=y
+# CONFIG_CONSOLE_ACTIVATE_FIRST is not set
+CONFIG_CONSOLE_ACTIVATE_ALL=y
 CONFIG_DEFAULT_ENVIRONMENT_GENERIC=y
 CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/at91sam9260ek/env"
 CONFIG_CMD_EDIT=y
@@ -25,12 +29,19 @@
 CONFIG_CMD_MTEST_ALTERNATIVE=y
 CONFIG_CMD_FLASH=y
 CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+CONFIG_CMD_UIMAGE=y
+# CONFIG_CMD_BOOTU is not set
 CONFIG_CMD_RESET=y
 CONFIG_CMD_GO=y
 CONFIG_CMD_OFTREE=y
 CONFIG_CMD_TIMEOUT=y
 CONFIG_CMD_PARTITION=y
 CONFIG_CMD_GPIO=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_TRIGGER=y
 CONFIG_NET=y
 CONFIG_NET_DHCP=y
 CONFIG_NET_NFS=y
@@ -41,14 +52,21 @@
 # CONFIG_SPI is not set
 CONFIG_MTD=y
 CONFIG_NAND=y
+# CONFIG_NAND_ECC_HW is not set
+# CONFIG_NAND_ECC_HW_SYNDROME is not set
+# CONFIG_NAND_ECC_HW_NONE is not set
 CONFIG_NAND_ATMEL=y
 CONFIG_UBI=y
 CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DFU=y
+CONFIG_USB_GADGET_SERIAL=y
 CONFIG_MCI=y
 CONFIG_MCI_STARTUP=y
 CONFIG_MCI_ATMEL=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_TRIGGERS=y
 CONFIG_FS_FAT=y
 CONFIG_FS_FAT_WRITE=y
 CONFIG_FS_FAT_LFN=y
 CONFIG_ZLIB=y
-CONFIG_BZLIB=y
diff -ruN barebox-2012.02.0/arch/arm/configs/eq3_ccu2_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/eq3_ccu2_defconfig
--- barebox-2012.02.0/arch/arm/configs/eq3_ccu2_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/eq3_ccu2_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -0,0 +1,382 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 2012.02.0 Barebox Configuration
+#
+# CONFIG_BOARD_LINKER_SCRIPT is not set
+CONFIG_GENERIC_LINKER_SCRIPT=y
+CONFIG_ARM=y
+CONFIG_ARM_LINUX=y
+
+#
+# System Type                   
+#
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_IMX is not set
+CONFIG_ARCH_MXS=y
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_S3C24xx is not set
+# CONFIG_ARCH_VERSATILE is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+
+#
+# processor features
+#
+# CONFIG_BOOT_ENDIANNESS_SWITCH is not set
+CONFIG_BOARDINFO="EQ3 CCU2"
+
+#
+# Freescale i.MX System-on-Chip
+#
+# CONFIG_ARCH_IMX23 is not set
+CONFIG_ARCH_IMX28=y
+CONFIG_MX28_DMA=y
+CONFIG_APBH_DMA_BURST8=y
+CONFIG_APBH_DMA_BURST=y
+# CONFIG_MACH_TX28 is not set
+CONFIG_MACH_EQ3_CCU2=y
+# CONFIG_MACH_MX28EVK is not set
+
+#
+# Board specific settings       
+#
+CONFIG_AEABI=y
+
+#
+# Arm specific settings         
+#
+CONFIG_CMD_ARM_CPUINFO=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_EXCEPTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_DEFCONFIG_LIST="$ARCH_DEFCONFIG"
+CONFIG_GREGORIAN_CALENDER=y
+CONFIG_HAS_KALLSYMS=y
+CONFIG_HAS_MODULES=y
+CONFIG_CMD_MEMORY=y
+CONFIG_ENV_HANDLING=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_BLOCK=y
+CONFIG_BLOCK_WRITE=y
+CONFIG_FILETYPE=y
+
+#
+# General Settings              
+#
+CONFIG_LOCALVERSION=".ccu2"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BANNER=y
+CONFIG_ENVIRONMENT_VARIABLES=y
+
+#
+# memory layout                 
+#
+CONFIG_MMU=y
+CONFIG_HAVE_CONFIGURABLE_TEXT_BASE=y
+CONFIG_TEXT_BASE=0x41000000
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0xffffffff
+CONFIG_BAREBOX_MAX_BARE_INIT_SIZE=0xffffffff
+CONFIG_HAVE_CONFIGURABLE_MEMORY_LAYOUT=y
+CONFIG_MEMORY_LAYOUT_DEFAULT=y
+# CONFIG_MEMORY_LAYOUT_FIXED is not set
+CONFIG_STACK_SIZE=0x8000
+CONFIG_MALLOC_SIZE=0x400000
+# CONFIG_BROKEN is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_MALLOC_DLMALLOC=y
+# CONFIG_MALLOC_TLSF is not set
+# CONFIG_MODULES is not set
+# CONFIG_KALLSYMS is not set
+CONFIG_PROMPT="barebox:"
+CONFIG_BAUDRATE=115200
+CONFIG_LONGHELP=y
+CONFIG_CBSIZE=1024
+CONFIG_MAXARGS=16
+CONFIG_SHELL_HUSH=y
+# CONFIG_SHELL_SIMPLE is not set
+CONFIG_GLOB=y
+CONFIG_PROMPT_HUSH_PS2="> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_HUSH_GETOPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+# CONFIG_MENU is not set
+CONFIG_PASSWORD=y
+# CONFIG_PASSWD_SUM_MD5 is not set
+CONFIG_PASSWD_SUM_SHA1=y
+# CONFIG_PASSWD_SUM_SHA256 is not set
+CONFIG_DYNAMIC_CRC_TABLE=y
+CONFIG_ERRNO_MESSAGES=y
+CONFIG_TIMESTAMP=y
+CONFIG_CONSOLE_FULL=y
+CONFIG_CONSOLE_ACTIVATE_FIRST=y
+CONFIG_PARTITION=y
+CONFIG_PARTITION_DISK=y
+# CONFIG_PARTITION_DISK_DOS is not set
+CONFIG_DEFAULT_ENVIRONMENT=y
+CONFIG_DEFAULT_ENVIRONMENT_COMPRESSED=y
+CONFIG_DEFAULT_ENVIRONMENT_COMPRESSED_GZIP=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/eq3-ccu2/env"
+CONFIG_POLLER=y
+
+#
+# Debugging                     
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_ENABLE_FLASH_NOISE is not set
+# CONFIG_ENABLE_PARTITION_NOISE is not set
+# CONFIG_ENABLE_DEVICE_NOISE is not set
+CONFIG_COMMAND_SUPPORT=y
+
+#
+# commands                      
+#
+
+#
+# scripting                     
+#
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TRUE=y
+CONFIG_CMD_FALSE=y
+CONFIG_CMD_LOGIN=y
+CONFIG_CMD_PASSWD=y
+# CONFIG_PASSWD_MODE_HIDE is not set
+CONFIG_PASSWD_MODE_STAR=y
+# CONFIG_PASSWD_MODE_CLEAR is not set
+CONFIG_CMD_TIME=y
+
+#
+# file commands                 
+#
+CONFIG_CMD_LS=y
+CONFIG_CMD_RM=y
+CONFIG_CMD_CAT=y
+CONFIG_CMD_MKDIR=y
+CONFIG_CMD_RMDIR=y
+CONFIG_CMD_CP=y
+CONFIG_CMD_PWD=y
+CONFIG_CMD_CD=y
+CONFIG_CMD_MOUNT=y
+CONFIG_CMD_UMOUNT=y
+CONFIG_CMD_NAND=y
+CONFIG_CMD_NANDTEST=y
+
+#
+# console                       
+#
+CONFIG_CMD_CLEAR=y
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ECHO_E=y
+
+#
+# memory                        
+#
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADY is not set
+# CONFIG_CMD_LOADS is not set
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_DIGEST=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_SHA1SUM=y
+# CONFIG_CMD_SHA256SUM is not set
+# CONFIG_CMD_SHA224SUM is not set
+CONFIG_CMD_MTEST=y
+# CONFIG_CMD_MTEST_ALTERNATIVE is not set
+
+#
+# flash                         
+#
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_UBI=y
+
+#
+# booting                       
+#
+CONFIG_CMD_BOOTM=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_VERBOSE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+# CONFIG_CMD_BOOTM_OFTREE_UIMAGE is not set
+CONFIG_CMD_UIMAGE=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_BOOTU=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_GO=y
+# CONFIG_CMD_OFTREE is not set
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_TEST=y
+CONFIG_CMD_VERSION=y
+CONFIG_CMD_HELP=y
+CONFIG_CMD_MAGICVAR=y
+# CONFIG_CMD_MAGICVAR_HELP is not set
+CONFIG_CMD_DEVINFO=y
+CONFIG_CMD_GPIO=y
+# CONFIG_CMD_UNCOMPRESS is not set
+CONFIG_CMD_I2C=y
+# CONFIG_CMD_LED is not set
+# CONFIG_CMD_LED_TRIGGER is not set
+CONFIG_CMD_FCB=y
+CONFIG_NET=y
+CONFIG_NET_DHCP=y
+# CONFIG_NET_NFS is not set
+CONFIG_NET_PING=y
+CONFIG_NET_TFTP=y
+# CONFIG_NET_TFTP_PUSH is not set
+# CONFIG_NET_NETCONSOLE is not set
+CONFIG_NET_RESOLV=y
+
+#
+# Drivers                       
+#
+
+#
+# serial drivers                
+#
+# CONFIG_DRIVER_SERIAL_ARM_DCC is not set
+CONFIG_DRIVER_SERIAL_IMXAPP=y
+CONFIG_DRIVER_SERIAL_STM378X=y
+# CONFIG_DRIVER_SERIAL_NS16550 is not set
+CONFIG_ARCH_HAS_FEC_IMX=y
+CONFIG_MIIDEV=y
+
+#
+# Network drivers               
+#
+# CONFIG_DRIVER_NET_SMC911X is not set
+# CONFIG_DRIVER_NET_SMC91111 is not set
+CONFIG_DRIVER_NET_FEC_IMX=y
+
+#
+# SPI drivers                   
+#
+CONFIG_SPI=y
+CONFIG_I2C=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# flash drivers                 
+#
+# CONFIG_DRIVER_CFI is not set
+# CONFIG_MTD_M25P80 is not set
+CONFIG_MTD=y
+CONFIG_MTD_WRITE=y
+CONFIG_MTD_OOB_DEVICE=y
+CONFIG_MTD_RAW_DEVICE=y
+
+#
+# Self contained MTD devices
+#
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_NAND=y
+CONFIG_NAND_ECC_SOFT=y
+CONFIG_NAND_ECC_HW=y
+CONFIG_NAND_ECC_HW_SYNDROME=y
+CONFIG_NAND_ECC_HW_NONE=y
+CONFIG_NAND_INFO=y
+CONFIG_NAND_READ_OOB=y
+CONFIG_NAND_BBT=y
+CONFIG_NAND_MXS=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_IDS=y
+CONFIG_UBI=y
+CONFIG_DISK=y
+CONFIG_DISK_WRITE=y
+
+#
+# drive types
+#
+# CONFIG_DISK_ATA is not set
+
+#
+# interface types
+#
+# CONFIG_DISK_INTF_PLATFORM_IDE is not set
+# CONFIG_USB is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_VIDEO is not set
+CONFIG_MCI=y
+
+#
+# --- Feature list ---
+#
+# CONFIG_MCI_STARTUP is not set
+CONFIG_MCI_INFO=y
+CONFIG_MCI_WRITE=y
+
+#
+# --- MCI host drivers ---
+#
+CONFIG_MCI_MXS=y
+# CONFIG_MCI_SPI is not set
+
+#
+# MFD
+#
+# CONFIG_I2C_MC13892 is not set
+# CONFIG_I2C_MC34704 is not set
+# CONFIG_I2C_MC9SDZ60 is not set
+# CONFIG_I2C_LP3972 is not set
+# CONFIG_I2C_TWL6030 is not set
+# CONFIG_DRIVER_SPI_MC13783 is not set
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+# CONFIG_LED_GPIO_RGB is not set
+CONFIG_LED_TRIGGERS=y
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT25=y
+
+#
+# Filesystem support            
+#
+CONFIG_FS_CRAMFS=y
+CONFIG_FS_RAMFS=y
+CONFIG_FS_DEVFS=y
+# CONFIG_FS_FAT is not set
+CONFIG_PARTITION_NEED_MTD=y
+
+#
+# Library routines
+#
+CONFIG_PARAMETER=y
+CONFIG_UNCOMPRESS=y
+CONFIG_ZLIB=y
+# CONFIG_BZLIB is not set
+# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+CONFIG_PROCESS_ESCAPE_SEQUENCE=y
+# CONFIG_LZO_DECOMPRESS is not set
+CONFIG_FDT=y
+CONFIG_OFTREE=y
+CONFIG_CRC32=y
+CONFIG_DIGEST=y
+CONFIG_MD5=y
+CONFIG_SHA1=y
+# CONFIG_SHA224 is not set
+# CONFIG_SHA256 is not set
diff -ruN barebox-2012.02.0/arch/arm/configs/omap3530_beagle_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/omap3530_beagle_defconfig
--- barebox-2012.02.0/arch/arm/configs/omap3530_beagle_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/omap3530_beagle_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -55,6 +55,7 @@
 CONFIG_USB_EHCI_OMAP=y
 CONFIG_USB_TWL4030=y
 CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
 CONFIG_MCI_OMAP_HSMMC=y
 CONFIG_I2C_TWL4030=y
 CONFIG_FS_FAT=y
diff -ruN barebox-2012.02.0/arch/arm/configs/omap3530_beagle_xload_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/omap3530_beagle_xload_defconfig
--- barebox-2012.02.0/arch/arm/configs/omap3530_beagle_xload_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/omap3530_beagle_xload_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -1,5 +1,4 @@
 CONFIG_ARCH_OMAP=y
-# CONFIG_OMAP3_COPY_CLOCK_SRAM is not set
 CONFIG_OMAP_BUILD_IFT=y
 CONFIG_MACH_BEAGLE=y
 CONFIG_AEABI=y
@@ -7,7 +6,8 @@
 # CONFIG_ARM_EXCEPTIONS is not set
 CONFIG_TEXT_BASE=0x40200000
 CONFIG_MEMORY_LAYOUT_FIXED=y
-CONFIG_STACK_BASE=0x87BF7F10
+CONFIG_STACK_BASE=0x4020F000
+CONFIG_STACK_SIZE=0xc00
 CONFIG_MALLOC_BASE=0x87BFFF10
 CONFIG_MALLOC_DUMMY=y
 CONFIG_PROMPT="X-load Beagle>"
diff -ruN barebox-2012.02.0/arch/arm/configs/panda_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/panda_defconfig
--- barebox-2012.02.0/arch/arm/configs/panda_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/panda_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -11,11 +11,9 @@
 CONFIG_LONGHELP=y
 CONFIG_GLOB=y
 CONFIG_HUSH_FANCY_PROMPT=y
-CONFIG_HUSH_GETOPT=y
 CONFIG_CMDLINE_EDITING=y
 CONFIG_AUTO_COMPLETE=y
 # CONFIG_TIMESTAMP is not set
-CONFIG_PARTITION=y
 CONFIG_DEFAULT_ENVIRONMENT_GENERIC=y
 CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/panda/env"
 CONFIG_CMD_EDIT=y
@@ -25,14 +23,24 @@
 CONFIG_CMD_EXPORT=y
 CONFIG_CMD_PRINTENV=y
 CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIME=y
 CONFIG_CMD_ECHO_E=y
 CONFIG_CMD_LOADB=y
+CONFIG_CMD_IOMEM=y
 CONFIG_CMD_FLASH=y
-# CONFIG_CMD_BOOTM is not set
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_VERBOSE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+# CONFIG_CMD_BOOTZ is not set
+# CONFIG_CMD_BOOTU is not set
 CONFIG_CMD_RESET=y
 CONFIG_CMD_GO=y
 CONFIG_CMD_TIMEOUT=y
 CONFIG_CMD_PARTITION=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_UNCOMPRESS=y
 CONFIG_NET=y
@@ -46,10 +54,6 @@
 CONFIG_NET_USB=y
 CONFIG_NET_USB_SMSC95XX=y
 # CONFIG_SPI is not set
-CONFIG_MTD=y
-CONFIG_NAND=y
-CONFIG_NAND_OMAP_GPMC=y
-CONFIG_UBI=y
 CONFIG_USB=y
 CONFIG_USB_EHCI=y
 CONFIG_MCI=y
diff -ruN barebox-2012.02.0/arch/arm/configs/pcm043_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/pcm043_defconfig
--- barebox-2012.02.0/arch/arm/configs/pcm043_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/pcm043_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -10,7 +10,7 @@
 CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
 CONFIG_ARM_UNWIND=y
 CONFIG_MMU=y
-CONFIG_TEXT_BASE=0x87F00000
+CONFIG_TEXT_BASE=0x87E00000
 CONFIG_MALLOC_SIZE=0x1000000
 CONFIG_MALLOC_TLSF=y
 CONFIG_KALLSYMS=y
diff -ruN barebox-2012.02.0/arch/arm/configs/phycard_a_l1_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/phycard_a_l1_defconfig
--- barebox-2012.02.0/arch/arm/configs/phycard_a_l1_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/phycard_a_l1_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -13,7 +13,6 @@
 CONFIG_OMAP3_COPY_CLOCK_SRAM=n
 CONFIG_OMAP_GPMC=y
 CONFIG_MACH_PCAAL1=y
-CONFIG_HAS_OMAP_NAND=y
 CONFIG_AEABI=y
 CONFIG_CMD_ARM_CPUINFO=y
 CONFIG_ARM_EXCEPTIONS=y
diff -ruN barebox-2012.02.0/arch/arm/configs/tny_a9260_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/tny_a9260_defconfig
--- barebox-2012.02.0/arch/arm/configs/tny_a9260_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/tny_a9260_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -0,0 +1,71 @@
+CONFIG_ARCH_AT91SAM9260=y
+CONFIG_MACH_TNY_A9260=y
+CONFIG_AEABI=y
+# CONFIG_CMD_ARM_CPUINFO is not set
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x40000
+CONFIG_EXPERIMENTAL=y
+CONFIG_MALLOC_TLSF=y
+CONFIG_PROMPT="TNY-9260:"
+CONFIG_LONGHELP=y
+CONFIG_GLOB=y
+CONFIG_PROMPT_HUSH_PS2="y"
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_CONSOLE_ACTIVATE_FIRST is not set
+CONFIG_CONSOLE_ACTIVATE_ALL=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/tny-a926x/env"
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENU_MANAGEMENT=y
+CONFIG_CMD_PASSWD=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_CMD_SHA256SUM=y
+CONFIG_CMD_MTEST=y
+CONFIG_CMD_MTEST_ALTERNATIVE=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+CONFIG_CMD_UIMAGE=y
+# CONFIG_CMD_BOOTZ is not set
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_RESET=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_GPIO=y
+CONFIG_NET=y
+CONFIG_NET_DHCP=y
+CONFIG_NET_NFS=y
+CONFIG_NET_PING=y
+CONFIG_NET_TFTP=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_DRIVER_NET_MACB=y
+CONFIG_DRIVER_SPI_ATMEL=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+# CONFIG_NAND_ECC_HW is not set
+# CONFIG_NAND_ECC_HW_SYNDROME is not set
+# CONFIG_NAND_ECC_HW_NONE is not set
+CONFIG_NAND_ATMEL=y
+CONFIG_UBI=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_EEPROM_AT25=y
+CONFIG_ZLIB=y
diff -ruN barebox-2012.02.0/arch/arm/configs/tny_a9263_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/tny_a9263_defconfig
--- barebox-2012.02.0/arch/arm/configs/tny_a9263_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/tny_a9263_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -0,0 +1,71 @@
+CONFIG_ARCH_AT91SAM9263=y
+CONFIG_MACH_TNY_A9263=y
+CONFIG_AEABI=y
+# CONFIG_CMD_ARM_CPUINFO is not set
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x40000
+CONFIG_EXPERIMENTAL=y
+CONFIG_MALLOC_TLSF=y
+CONFIG_PROMPT="TNY-9263:"
+CONFIG_LONGHELP=y
+CONFIG_GLOB=y
+CONFIG_PROMPT_HUSH_PS2="y"
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_CONSOLE_ACTIVATE_FIRST is not set
+CONFIG_CONSOLE_ACTIVATE_ALL=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/tny-a926x/env"
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENU_MANAGEMENT=y
+CONFIG_CMD_PASSWD=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_CMD_SHA256SUM=y
+CONFIG_CMD_MTEST=y
+CONFIG_CMD_MTEST_ALTERNATIVE=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+CONFIG_CMD_UIMAGE=y
+# CONFIG_CMD_BOOTZ is not set
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_RESET=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_GPIO=y
+CONFIG_NET=y
+CONFIG_NET_DHCP=y
+CONFIG_NET_NFS=y
+CONFIG_NET_PING=y
+CONFIG_NET_TFTP=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_DRIVER_NET_MACB=y
+CONFIG_DRIVER_SPI_ATMEL=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+# CONFIG_NAND_ECC_HW is not set
+# CONFIG_NAND_ECC_HW_SYNDROME is not set
+# CONFIG_NAND_ECC_HW_NONE is not set
+CONFIG_NAND_ATMEL=y
+CONFIG_UBI=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_EEPROM_AT25=y
+CONFIG_ZLIB=y
diff -ruN barebox-2012.02.0/arch/arm/configs/tny_a9g20_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/tny_a9g20_defconfig
--- barebox-2012.02.0/arch/arm/configs/tny_a9g20_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/tny_a9g20_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -0,0 +1,71 @@
+CONFIG_ARCH_AT91SAM9G20=y
+CONFIG_MACH_TNY_A9G20=y
+CONFIG_AEABI=y
+# CONFIG_CMD_ARM_CPUINFO is not set
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x40000
+CONFIG_EXPERIMENTAL=y
+CONFIG_MALLOC_TLSF=y
+CONFIG_PROMPT="TNY-9G20:"
+CONFIG_LONGHELP=y
+CONFIG_GLOB=y
+CONFIG_PROMPT_HUSH_PS2="y"
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_CONSOLE_ACTIVATE_FIRST is not set
+CONFIG_CONSOLE_ACTIVATE_ALL=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/tny-a926x/env"
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENU_MANAGEMENT=y
+CONFIG_CMD_PASSWD=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_CMD_SHA256SUM=y
+CONFIG_CMD_MTEST=y
+CONFIG_CMD_MTEST_ALTERNATIVE=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+CONFIG_CMD_UIMAGE=y
+# CONFIG_CMD_BOOTZ is not set
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_RESET=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_GPIO=y
+CONFIG_NET=y
+CONFIG_NET_DHCP=y
+CONFIG_NET_NFS=y
+CONFIG_NET_PING=y
+CONFIG_NET_TFTP=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_DRIVER_NET_MACB=y
+CONFIG_DRIVER_SPI_ATMEL=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+# CONFIG_NAND_ECC_HW is not set
+# CONFIG_NAND_ECC_HW_SYNDROME is not set
+# CONFIG_NAND_ECC_HW_NONE is not set
+CONFIG_NAND_ATMEL=y
+CONFIG_UBI=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_EEPROM_AT25=y
+CONFIG_ZLIB=y
diff -ruN barebox-2012.02.0/arch/arm/configs/usb_a9260_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9260_defconfig
--- barebox-2012.02.0/arch/arm/configs/usb_a9260_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9260_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -3,6 +3,7 @@
 CONFIG_AEABI=y
 # CONFIG_CMD_ARM_CPUINFO is not set
 CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x40000
 CONFIG_EXPERIMENTAL=y
 CONFIG_PROMPT="USB-9G20:"
 CONFIG_LONGHELP=y
diff -ruN barebox-2012.02.0/arch/arm/configs/usb_a9263_128mib_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9263_128mib_defconfig
--- barebox-2012.02.0/arch/arm/configs/usb_a9263_128mib_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9263_128mib_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -4,6 +4,7 @@
 # CONFIG_CMD_ARM_CPUINFO is not set
 CONFIG_AT91_HAVE_SRAM_128M=y
 CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x40000
 CONFIG_EXPERIMENTAL=y
 CONFIG_PROMPT="USB-9G20:"
 CONFIG_LONGHELP=y
diff -ruN barebox-2012.02.0/arch/arm/configs/usb_a9263_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9263_defconfig
--- barebox-2012.02.0/arch/arm/configs/usb_a9263_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9263_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -3,6 +3,7 @@
 CONFIG_AEABI=y
 # CONFIG_CMD_ARM_CPUINFO is not set
 CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x40000
 CONFIG_EXPERIMENTAL=y
 CONFIG_PROMPT="USB-9G20:"
 CONFIG_LONGHELP=y
diff -ruN barebox-2012.02.0/arch/arm/configs/usb_a9g20_128mib_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9g20_128mib_defconfig
--- barebox-2012.02.0/arch/arm/configs/usb_a9g20_128mib_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9g20_128mib_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -4,6 +4,7 @@
 # CONFIG_CMD_ARM_CPUINFO is not set
 CONFIG_AT91_HAVE_SRAM_128M=y
 CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x40000
 CONFIG_EXPERIMENTAL=y
 CONFIG_PROMPT="USB-9G20:"
 CONFIG_LONGHELP=y
diff -ruN barebox-2012.02.0/arch/arm/configs/usb_a9g20_defconfig barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9g20_defconfig
--- barebox-2012.02.0/arch/arm/configs/usb_a9g20_defconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/configs/usb_a9g20_defconfig	2013-01-14 12:46:19.000000000 +0100
@@ -3,6 +3,7 @@
 CONFIG_AEABI=y
 # CONFIG_CMD_ARM_CPUINFO is not set
 CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x40000
 CONFIG_EXPERIMENTAL=y
 CONFIG_PROMPT="USB-9G20:"
 CONFIG_LONGHELP=y
diff -ruN barebox-2012.02.0/arch/arm/cpu/cache-armv7.S barebox-2012.02.0-ccu2/arch/arm/cpu/cache-armv7.S
--- barebox-2012.02.0/arch/arm/cpu/cache-armv7.S	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/cpu/cache-armv7.S	2013-01-14 12:46:19.000000000 +0100
@@ -22,6 +22,7 @@
 		movne	r1, #-1
 		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
 #endif
+		mcr	p15, 0, r0, c7, c5, 4	@ ISB
 		mcr	p15, 0, r0, c1, c0, 0	@ load control register
 		mrc	p15, 0, r0, c1, c0, 0	@ and read it back
 		mov	r0, #0
diff -ruN barebox-2012.02.0/arch/arm/cpu/interrupts.c barebox-2012.02.0-ccu2/arch/arm/cpu/interrupts.c
--- barebox-2012.02.0/arch/arm/cpu/interrupts.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/cpu/interrupts.c	2013-01-14 12:46:19.000000000 +0100
@@ -73,6 +73,13 @@
 #endif
 }
 
+#ifdef CONFIG_ARM_UNWIND
+void dump_stack(void)
+{
+	unwind_backtrace(NULL);
+}
+#endif
+
 static void __noreturn do_exception(struct pt_regs *pt_regs)
 {
 	show_regs(pt_regs);
diff -ruN barebox-2012.02.0/arch/arm/include/asm/barebox.h barebox-2012.02.0-ccu2/arch/arm/include/asm/barebox.h
--- barebox-2012.02.0/arch/arm/include/asm/barebox.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/include/asm/barebox.h	2013-01-14 12:46:19.000000000 +0100
@@ -1,41 +1,8 @@
-/*
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Alex Zuepke <azu@sysgo.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- *
- ********************************************************************
- * NOTE: This header file defines an interface to barebox. Including
- * this (unmodified) header file in another file is considered normal
- * use of barebox, and does *not* fall under the heading of "derived
- * work".
- ********************************************************************
- */
-
 #ifndef _BAREBOX_H_
 #define _BAREBOX_H_	1
 
-//typedef struct bd_info {} bd_t;
+#ifdef CONFIG_ARM_UNWIND
+#define ARCH_HAS_STACK_DUMP
+#endif
 
 #endif	/* _BAREBOX_H_ */
diff -ruN barebox-2012.02.0/arch/arm/lib/barebox.lds.S barebox-2012.02.0-ccu2/arch/arm/lib/barebox.lds.S
--- barebox-2012.02.0/arch/arm/lib/barebox.lds.S	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/lib/barebox.lds.S	2013-01-14 12:46:22.000000000 +0100
@@ -44,9 +44,12 @@
 	  . = 0x1000;
 	  LONG(0x53555243) /* 'CRUS' */
 #endif
+		__bare_init_start = .;
 		*(.text_bare_init*)
+		__bare_init_end = .;
 		*(.text*)
 	}
+	BAREBOX_BARE_INIT_SIZE
 
 	. = ALIGN(4);
 	.rodata : { *(.rodata*) }
diff -ruN barebox-2012.02.0/arch/arm/lib/div0.c barebox-2012.02.0-ccu2/arch/arm/lib/div0.c
--- barebox-2012.02.0/arch/arm/lib/div0.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/lib/div0.c	2013-01-14 12:46:22.000000000 +0100
@@ -27,5 +27,5 @@
 /* Replacement (=dummy) for GNU/Linux division-by zero handler */
 void __div0 (void)
 {
-	hang();
+	panic("division by zero\n");
 }
diff -ruN barebox-2012.02.0/arch/arm/lib/.gitignore barebox-2012.02.0-ccu2/arch/arm/lib/.gitignore
--- barebox-2012.02.0/arch/arm/lib/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/lib/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-barebox.lds
diff -ruN barebox-2012.02.0/arch/arm/mach-at91/at91rm9200_devices.c barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91rm9200_devices.c
--- barebox-2012.02.0/arch/arm/mach-at91/at91rm9200_devices.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91rm9200_devices.c	2013-01-14 12:46:19.000000000 +0100
@@ -154,6 +154,50 @@
 #endif
 
 /* --------------------------------------------------------------------
+ *  SPI
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_DRIVER_SPI_ATMEL)
+static const unsigned spi_standard_cs[4] = { AT91_PIN_PA3, AT91_PIN_PA4, AT91_PIN_PA5, AT91_PIN_PA6 };
+
+static struct at91_spi_platform_data spi_pdata[] = {
+	[0] = {
+		.chipselect = spi_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi_standard_cs),
+	},
+};
+
+void at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata)
+{
+	int i;
+	int cs_pin;
+
+	BUG_ON(spi_id > 0);
+
+	if (!pdata)
+		pdata = &spi_pdata[spi_id];
+
+	for (i = 0; i < pdata->num_chipselect; i++) {
+		cs_pin = pdata->chipselect[i];
+
+		/* enable chip-select pin */
+		if (cs_pin > 0)
+			at91_set_gpio_output(cs_pin, 1);
+	}
+
+	at91_set_A_periph(AT91_PIN_PA0, 0);	/* MISO */
+	at91_set_A_periph(AT91_PIN_PA1, 0);	/* MOSI */
+	at91_set_A_periph(AT91_PIN_PA2, 0);	/* SPCK */
+
+	add_generic_device("atmel_spi", spi_id, NULL, AT91RM9200_BASE_SPI,
+			   SZ_16K, IORESOURCE_MEM, pdata);
+}
+#else
+void __init at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata) {}
+#endif
+
+
+/* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
 
diff -ruN barebox-2012.02.0/arch/arm/mach-at91/at91sam9260_devices.c barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam9260_devices.c
--- barebox-2012.02.0/arch/arm/mach-at91/at91sam9260_devices.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam9260_devices.c	2013-01-14 12:46:19.000000000 +0100
@@ -26,15 +26,11 @@
 {
 	arm_add_mem_device("ram0", AT91_CHIPSELECT_1, size);
 	if (cpu_is_at91sam9g20()) {
-		add_mem_device("sram0", AT91SAM9G20_SRAM0_BASE,
-			AT91SAM9G20_SRAM0_SIZE, IORESOURCE_MEM_WRITEABLE);
-		add_mem_device("sram1", AT91SAM9G20_SRAM1_BASE,
-			AT91SAM9G20_SRAM1_SIZE, IORESOURCE_MEM_WRITEABLE);
+		add_mem_device("sram0", AT91SAM9G20_SRAM_BASE,
+			AT91SAM9G20_SRAM_SIZE, IORESOURCE_MEM_WRITEABLE);
 	} else {
-		add_mem_device("sram0", AT91SAM9260_SRAM0_BASE,
-			AT91SAM9260_SRAM0_SIZE, IORESOURCE_MEM_WRITEABLE);
-		add_mem_device("sram1", AT91SAM9260_SRAM1_BASE,
-			AT91SAM9260_SRAM1_SIZE, IORESOURCE_MEM_WRITEABLE);
+		add_mem_device("sram0", AT91SAM9260_SRAM_BASE,
+			AT91SAM9260_SRAM_SIZE, IORESOURCE_MEM_WRITEABLE);
 	}
 }
 
@@ -154,6 +150,68 @@
 void at91_add_device_nand(struct atmel_nand_data *data) {}
 #endif
 
+/* --------------------------------------------------------------------
+ *  SPI
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_DRIVER_SPI_ATMEL)
+static int spi0_standard_cs[4] = { AT91_PIN_PA3, AT91_PIN_PC11, AT91_PIN_PC16, AT91_PIN_PC17 };
+
+static int spi1_standard_cs[4] = { AT91_PIN_PB3, AT91_PIN_PC5, AT91_PIN_PC4, AT91_PIN_PC3 };
+
+static struct at91_spi_platform_data spi_pdata[] = {
+	[0] = {
+		.chipselect = spi0_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi0_standard_cs),
+	},
+	[1] = {
+		.chipselect = spi1_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi1_standard_cs),
+	},
+};
+
+void __init at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata)
+{
+	int i;
+	int cs_pin;
+	resource_size_t start = ~0;
+
+	BUG_ON(spi_id > 1);
+
+	if (!pdata)
+		pdata = &spi_pdata[spi_id];
+
+	for (i = 0; i < pdata->num_chipselect; i++) {
+		cs_pin = pdata->chipselect[i];
+
+		/* enable chip-select pin */
+		if (cs_pin > 0)
+			at91_set_gpio_output(cs_pin, 1);
+	}
+
+	/* Configure SPI bus(es) */
+	switch (spi_id) {
+	case 0:
+		start = AT91SAM9260_BASE_SPI0;
+		at91_set_A_periph(AT91_PIN_PA0, 0);	/* SPI0_MISO */
+		at91_set_A_periph(AT91_PIN_PA1, 0);	/* SPI0_MOSI */
+		at91_set_A_periph(AT91_PIN_PA2, 0);	/* SPI1_SPCK */
+		break;
+	case 1:
+		start = AT91SAM9260_BASE_SPI1;
+		at91_set_A_periph(AT91_PIN_PB0, 0);	/* SPI1_MISO */
+		at91_set_A_periph(AT91_PIN_PB1, 0);	/* SPI1_MOSI */
+		at91_set_A_periph(AT91_PIN_PB2, 0);	/* SPI1_SPCK */
+		break;
+	}
+
+	add_generic_device("atmel_spi", spi_id, NULL, start, SZ_16K,
+			   IORESOURCE_MEM, pdata);
+}
+#else
+void __init at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata) {}
+#endif
+
 static inline void configure_dbgu_pins(void)
 {
 	at91_set_A_periph(AT91_PIN_PB14, 0);		/* DRXD */
diff -ruN barebox-2012.02.0/arch/arm/mach-at91/at91sam9261_devices.c barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam9261_devices.c
--- barebox-2012.02.0/arch/arm/mach-at91/at91sam9261_devices.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam9261_devices.c	2013-01-14 12:46:19.000000000 +0100
@@ -102,6 +102,68 @@
 void at91_add_device_nand(struct atmel_nand_data *data) {}
 #endif
 
+/* --------------------------------------------------------------------
+ *  SPI
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_DRIVER_SPI_ATMEL)
+static const unsigned spi0_standard_cs[4] = { AT91_PIN_PA3, AT91_PIN_PA4, AT91_PIN_PA5, AT91_PIN_PA6 };
+
+static const unsigned spi1_standard_cs[4] = { AT91_PIN_PB28, AT91_PIN_PA24, AT91_PIN_PA25, AT91_PIN_PA26 };
+
+static struct at91_spi_platform_data spi_pdata[] = {
+	[0] = {
+		.chipselect = spi0_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi0_standard_cs),
+	},
+	[1] = {
+		.chipselect = spi1_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi1_standard_cs),
+	},
+};
+
+void at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata)
+{
+	int i;
+	int cs_pin;
+	resource_size_t start = ~0;
+
+	BUG_ON(spi_id > 1);
+
+	if (!pdata)
+		pdata = &spi_pdata[spi_id];
+
+	for (i = 0; i < pdata->num_chipselect; i++) {
+		cs_pin = pdata->chipselect[i];
+
+		/* enable chip-select pin */
+		if (cs_pin > 0)
+			at91_set_gpio_output(cs_pin, 1);
+	}
+
+	/* Configure SPI bus(es) */
+	switch (spi_id) {
+	case 0:
+		start = AT91SAM9261_BASE_SPI0;
+		at91_set_A_periph(AT91_PIN_PA0, 0);	/* SPI0_MISO */
+		at91_set_A_periph(AT91_PIN_PA1, 0);	/* SPI0_MOSI */
+		at91_set_A_periph(AT91_PIN_PA2, 0);	/* SPI0_SPCK */
+		break;
+	case 1:
+		start = AT91SAM9213_BASE_SPI1;
+		at91_set_A_periph(AT91_PIN_PB30, 0);	/* SPI1_MISO */
+		at91_set_A_periph(AT91_PIN_PB31, 0);	/* SPI1_MOSI */
+		at91_set_A_periph(AT91_PIN_PB29, 0);	/* SPI1_SPCK */
+		break;
+	}
+
+	add_generic_device("atmel_spi", spi_id, NULL, start, SZ_16K,
+			   IORESOURCE_MEM, pdata);
+}
+#else
+void __init at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata) {}
+#endif
+
 static inline void configure_dbgu_pins(void)
 {
 	at91_set_A_periph(AT91_PIN_PA9, 0);		/* DRXD */
diff -ruN barebox-2012.02.0/arch/arm/mach-at91/at91sam9263_devices.c barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam9263_devices.c
--- barebox-2012.02.0/arch/arm/mach-at91/at91sam9263_devices.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam9263_devices.c	2013-01-14 12:46:19.000000000 +0100
@@ -152,6 +152,68 @@
 void at91_add_device_nand(struct atmel_nand_data *data) {}
 #endif
 
+/* --------------------------------------------------------------------
+ *  SPI
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_DRIVER_SPI_ATMEL)
+static int spi0_standard_cs[4] = { AT91_PIN_PA5, AT91_PIN_PA3, AT91_PIN_PA4, AT91_PIN_PB11 };
+
+static int spi1_standard_cs[4] = { AT91_PIN_PB15, AT91_PIN_PB16, AT91_PIN_PB17, AT91_PIN_PB18 };
+
+static struct at91_spi_platform_data spi_pdata[] = {
+	[0] = {
+		.chipselect = spi0_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi0_standard_cs),
+	},
+	[1] = {
+		.chipselect = spi1_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi1_standard_cs),
+	},
+};
+
+void at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata)
+{
+	int i;
+	int cs_pin;
+	resource_size_t start = ~0;
+
+	BUG_ON(spi_id > 1);
+
+	if (!pdata)
+		pdata = &spi_pdata[spi_id];
+
+	for (i = 0; i < pdata->num_chipselect; i++) {
+		cs_pin = pdata->chipselect[i];
+
+		/* enable chip-select pin */
+		if (cs_pin > 0)
+			at91_set_gpio_output(cs_pin, 1);
+	}
+
+	/* Configure SPI bus(es) */
+	switch (spi_id) {
+	case 0:
+		start = AT91SAM9263_BASE_SPI0;
+		at91_set_B_periph(AT91_PIN_PA0, 0);	/* SPI0_MISO */
+		at91_set_B_periph(AT91_PIN_PA1, 0);	/* SPI0_MOSI */
+		at91_set_B_periph(AT91_PIN_PA2, 0);	/* SPI0_SPCK */
+		break;
+	case 1:
+		start = AT91SAM9263_BASE_SPI1;
+		at91_set_A_periph(AT91_PIN_PB12, 0);	/* SPI1_MISO */
+		at91_set_A_periph(AT91_PIN_PB13, 0);	/* SPI1_MOSI */
+		at91_set_A_periph(AT91_PIN_PB14, 0);	/* SPI1_SPCK */
+		break;
+	}
+
+	add_generic_device("atmel_spi", spi_id, NULL, start, SZ_16K,
+			   IORESOURCE_MEM, pdata);
+}
+#else
+void __init at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata) {}
+#endif
+
 static inline void configure_dbgu_pins(void)
 {
 	at91_set_A_periph(AT91_PIN_PC30, 0);		/* DRXD */
@@ -309,3 +371,4 @@
 #else
 void at91_add_device_mci(short mmc_id, struct atmel_mci_platform_data *data) {}
 #endif
+
diff -ruN barebox-2012.02.0/arch/arm/mach-at91/at91sam926x_lowlevel_init.c barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam926x_lowlevel_init.c
--- barebox-2012.02.0/arch/arm/mach-at91/at91sam926x_lowlevel_init.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam926x_lowlevel_init.c	2013-01-14 12:46:19.000000000 +0100
@@ -57,13 +57,13 @@
 #endif
 
 	/* flash */
-	at91_sys_write(AT91_SMC_MODE(0), CONFIG_SYS_SMC0_MODE0_VAL);
+	at91_sys_write(AT91_SMC_MODE(CONFIG_SYS_SMC_CS), CONFIG_SYS_SMC_MODE_VAL);
 
-	at91_sys_write(AT91_SMC_CYCLE(0), CONFIG_SYS_SMC0_CYCLE0_VAL);
+	at91_sys_write(AT91_SMC_CYCLE(CONFIG_SYS_SMC_CS), CONFIG_SYS_SMC_CYCLE_VAL);
 
-	at91_sys_write(AT91_SMC_PULSE(0), CONFIG_SYS_SMC0_PULSE0_VAL);
+	at91_sys_write(AT91_SMC_PULSE(CONFIG_SYS_SMC_CS), CONFIG_SYS_SMC_PULSE_VAL);
 
-	at91_sys_write(AT91_SMC_SETUP(0), CONFIG_SYS_SMC0_SETUP0_VAL);
+	at91_sys_write(AT91_SMC_SETUP(CONFIG_SYS_SMC_CS), CONFIG_SYS_SMC_SETUP_VAL);
 
 	/*
 	 * PMC Check if the PLL is already initialized
diff -ruN barebox-2012.02.0/arch/arm/mach-at91/at91sam9g45_devices.c barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam9g45_devices.c
--- barebox-2012.02.0/arch/arm/mach-at91/at91sam9g45_devices.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-at91/at91sam9g45_devices.c	2013-01-14 12:46:19.000000000 +0100
@@ -296,11 +296,31 @@
 
 #if defined(CONFIG_DRIVER_SPI_ATMEL)
 /* SPI */
+static const unsigned spi0_standard_cs[4] = { AT91_PIN_PB3, AT91_PIN_PB18, AT91_PIN_PB19, AT91_PIN_PD27 };
+
+static const unsigned spi1_standard_cs[4] = { AT91_PIN_PB17, AT91_PIN_PD28, AT91_PIN_PD18, AT91_PIN_PD19 };
+
+static struct at91_spi_platform_data spi_pdata[] = {
+	[0] = {
+		.chipselect = spi0_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi0_standard_cs),
+	},
+	[1] = {
+		.chipselect = spi1_standard_cs,
+		.num_chipselect = ARRAY_SIZE(spi1_standard_cs),
+	},
+};
+
 void at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata)
 {
 	int i;
 	int cs_pin;
-	resource_size_t start;
+	resource_size_t start = ~0;
+
+	BUG_ON(spi_id > 1);
+
+	if (!pdata)
+		pdata = &spi_pdata[spi_id];
 
 	for (i = 0; i < pdata->num_chipselect; i++) {
 		cs_pin = pdata->chipselect[i];
@@ -311,27 +331,24 @@
 	}
 
 	/* Configure SPI bus(es) */
-	if (spi_id == 0) {
+	switch (spi_id) {
+	case 0:
 		start = AT91SAM9G45_BASE_SPI0;
 		at91_set_A_periph(AT91_PIN_PB0, 0);	/* SPI0_MISO */
 		at91_set_A_periph(AT91_PIN_PB1, 0);	/* SPI0_MOSI */
 		at91_set_A_periph(AT91_PIN_PB2, 0);	/* SPI0_SPCK */
-
-		add_generic_device("atmel_spi", spi_id, NULL, start, SZ_16K,
-			   IORESOURCE_MEM, pdata);
-	}
-
-	else if (spi_id == 1) {
+		break;
+	case 1:
 		start = AT91SAM9G45_BASE_SPI1;
 		at91_set_A_periph(AT91_PIN_PB14, 0);	/* SPI1_MISO */
 		at91_set_A_periph(AT91_PIN_PB15, 0);	/* SPI1_MOSI */
 		at91_set_A_periph(AT91_PIN_PB16, 0);	/* SPI1_SPCK */
+		break;
+	}
 
-		add_generic_device("atmel_spi", spi_id, NULL, start, SZ_16K,
+	add_generic_device("atmel_spi", spi_id, NULL, start, SZ_16K,
 			   IORESOURCE_MEM, pdata);
-	}
 }
-
 #else
 void at91_add_device_spi(int spi_id, struct at91_spi_platform_data *pdata) {}
 #endif
diff -ruN barebox-2012.02.0/arch/arm/mach-at91/include/mach/at91sam9260.h barebox-2012.02.0-ccu2/arch/arm/mach-at91/include/mach/at91sam9260.h
--- barebox-2012.02.0/arch/arm/mach-at91/include/mach/at91sam9260.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-at91/include/mach/at91sam9260.h	2013-01-14 12:46:19.000000000 +0100
@@ -121,6 +121,8 @@
 #define AT91SAM9260_SRAM0_SIZE	SZ_4K		/* Internal SRAM 0 size (4Kb) */
 #define AT91SAM9260_SRAM1_BASE	0x00300000	/* Internal SRAM 1 base address */
 #define AT91SAM9260_SRAM1_SIZE	SZ_4K		/* Internal SRAM 1 size (4Kb) */
+#define AT91SAM9260_SRAM_BASE	0x002FF000	/* Internal SRAM base address */
+#define AT91SAM9260_SRAM_SIZE	SZ_8K		/* Internal SRAM size (8Kb) */
 
 #define AT91SAM9260_UHP_BASE	0x00500000	/* USB Host controller */
 
@@ -134,6 +136,8 @@
 #define AT91SAM9G20_SRAM0_SIZE	SZ_16K		/* Internal SRAM 0 size (16Kb) */
 #define AT91SAM9G20_SRAM1_BASE	0x00300000	/* Internal SRAM 1 base address */
 #define AT91SAM9G20_SRAM1_SIZE	SZ_16K		/* Internal SRAM 1 size (16Kb) */
+#define AT91SAM9G20_SRAM_BASE	0x002FC000	/* Internal SRAM base address */
+#define AT91SAM9G20_SRAM_SIZE	SZ_32K		/* Internal SRAM size (32Kb) */
 
 #define AT91SAM9G20_UHP_BASE	0x00500000	/* USB Host controller */
 
diff -ruN barebox-2012.02.0/arch/arm/mach-at91/Kconfig barebox-2012.02.0-ccu2/arch/arm/mach-at91/Kconfig
--- barebox-2012.02.0/arch/arm/mach-at91/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-at91/Kconfig	2013-01-14 12:46:19.000000000 +0100
@@ -21,6 +21,9 @@
 	default "Ronetix PM9263" if MACH_PM9263
 	default "Ronetix PM9G45" if MACH_PM9G45
 	default "Aizo dSS11" if MACH_DSS11
+	default "Calao TNY-A9260" if MACH_TNY_A9260
+	default "Calao TNY-A9263" if MACH_TNY_A9263
+	default "Calao TNY-A9G20" if MACH_TNY_A9G20
 
 config HAVE_NAND_ATMEL_BUSWIDTH_16
 	bool
@@ -80,6 +83,16 @@
 
 endchoice
 
+config ARCH_BAREBOX_MAX_BARE_INIT_SIZE
+	hex
+	default 0x1000 if ARCH_AT91SAM9260
+	default 0x270000 if ARCH_AT91SAM9261
+	default 0x12000 if ARCH_AT91SAM9263
+	default 0x4000 if ARCH_AT91SAM9G20
+	default 0x3000 if ARCH_AT91SAM9G10
+	default 0xF000 if ARCH_AT91SAM9G45
+	default 0xffffffff
+
 # ----------------------------------------------------------
 
 if ARCH_AT91RM9200
@@ -112,6 +125,12 @@
 	help
 	  Say y here if you are using Atmel's AT91SAM9260-EK Evaluation board
 
+config MACH_TNY_A9260
+	bool "CALAO TNY-A9260"
+	help
+	  Select this if you are using a Calao Systems TNY-A9260.
+	  <http://www.calao-systems.com>
+
 config MACH_USB_A9260
 	bool "CALAO USB-A9260"
 	help
@@ -182,6 +201,12 @@
 	  Select this if you are using Atmel's AT91SAM9G20-EK Evaluation Kit
 	  that embeds only one SD/MMC slot.
 
+config MACH_TNY_A9G20
+	bool "CALAO TNY-A9G20"
+	help
+	  Select this if you are using a Calao Systems TNY-A9G20.
+	  <http://www.calao-systems.com>
+
 config MACH_USB_A9G20
 	bool "CALAO USB-A9G20"
 	help
@@ -224,6 +249,12 @@
 	help
 	  Say y here if you are using the Ronetix PM9263 Board
 
+config MACH_TNY_A9263
+	bool "CALAO TNY-A9263"
+	help
+	  Select this if you are using a Calao Systems TNY-A9263.
+	  <http://www.calao-systems.com>
+
 config MACH_USB_A9263
 	bool "CALAO USB-A9263"
 	help
diff -ruN barebox-2012.02.0/arch/arm/mach-imx/include/mach/imx-ipu-fb.h barebox-2012.02.0-ccu2/arch/arm/mach-imx/include/mach/imx-ipu-fb.h
--- barebox-2012.02.0/arch/arm/mach-imx/include/mach/imx-ipu-fb.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-imx/include/mach/imx-ipu-fb.h	2013-01-14 12:46:22.000000000 +0100
@@ -27,7 +27,9 @@
 struct imx_ipu_fb_platform_data {
 	struct fb_videomode	*mode;
 	unsigned char		bpp;
+	u_int			num_modes;
 	void __iomem		*framebuffer;
+	void __iomem		*framebuffer_ovl;
 	/** hook to enable backlight and stuff */
 	void			(*enable)(int enable);
 };
diff -ruN barebox-2012.02.0/arch/arm/mach-imx/Kconfig barebox-2012.02.0-ccu2/arch/arm/mach-imx/Kconfig
--- barebox-2012.02.0/arch/arm/mach-imx/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-imx/Kconfig	2013-01-14 12:46:22.000000000 +0100
@@ -405,16 +405,6 @@
 
 menu "Board specific settings       "
 
-if MACH_PCM043
-choice
-	prompt "Display type"
-config PCM043_DISPLAY_SHARP
-	bool "Sharp LQ035Q7"
-config PCM043_DISPLAY_TY090
-	bool "TX090"
-endchoice
-endif
-
 if MACH_PCM037
 choice
 	prompt "SDRAM Bank0"
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/dma-imx28.c barebox-2012.02.0-ccu2/arch/arm/mach-mxs/dma-imx28.c
--- barebox-2012.02.0/arch/arm/mach-mxs/dma-imx28.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/dma-imx28.c	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,640 @@
+/*
+ * Freescale i.MX28 APBH DMA driver
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#define xDEBUG	1
+
+#include <linux/list.h>
+
+#include <common.h>
+#include <malloc.h>
+#include <init.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/mmu.h>
+#include <mach/clock.h>
+#include <mach/imx-regs.h>
+#include <mach/dma.h>
+#include <mach/regs-apbh.h>
+#include <mach/generic.h>
+
+static struct mxs_dma_chan mxs_dma_channels[MXS_MAX_DMA_CHANNELS];
+
+static void mxs_nand_dump_dma(char const *prefix,
+			      unsigned int chan)
+{
+	struct mx28_apbh_regs	* const r = (void *)MXS_APBH_BASE;
+
+#ifndef DEBUG
+	return;
+#endif
+
+	printk(KERN_DEBUG
+	       "%sCTRL=[%08x,%08x,%08x], CMDAR=%08x->%08x, CMD=%08x, BAR=%08x, SEMA=%08x, DEBUG=[%08x,%08x]\n",
+	       prefix,
+	       readl(&r->hw_apbh_ctrl0),
+	       readl(&r->hw_apbh_ctrl1),
+	       readl(&r->hw_apbh_ctrl2),
+
+	       readl(&r->ch[chan].hw_apbh_ch_curcmdar),
+	       readl(&r->ch[chan].hw_apbh_ch_nxtcmdar),
+	       readl(&r->ch[chan].hw_apbh_ch_cmd),
+	       readl(&r->ch[chan].hw_apbh_ch_bar),
+	       readl(&r->ch[chan].hw_apbh_ch_sema),
+
+	       readl(&r->ch[chan].hw_apbh_ch_debug1),
+	       readl(&r->ch[chan].hw_apbh_ch_debug2));
+}
+
+/*
+ * Test is the DMA channel is valid channel
+ */
+int mxs_dma_validate_chan(int channel)
+{
+	struct mxs_dma_chan *pchan;
+
+	if ((channel < 0) || (channel >= MXS_MAX_DMA_CHANNELS))
+		return -EINVAL;
+
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return -EINVAL;
+
+	return 0;
+}
+
+static void mxs_dma_flush_desc(struct mxs_dma_desc *desc)
+{
+	dma_flush_range(virt_to_phys(&desc->cmd),
+			virt_to_phys(&desc->cmd + 1));
+}
+
+/*
+ * Return the address of the command within a descriptor.
+ */
+static unsigned int mxs_dma_cmd_address(struct mxs_dma_desc *desc)
+{
+	return desc->address + offsetof(struct mxs_dma_desc, cmd);
+}
+
+/*
+ * Read a DMA channel's hardware semaphore.
+ *
+ * As used by the MXS platform's DMA software, the DMA channel's hardware
+ * semaphore reflects the number of DMA commands the hardware will process, but
+ * has not yet finished. This is a volatile value read directly from hardware,
+ * so it must be be viewed as immediately stale.
+ *
+ * If the channel is not marked busy, or has finished processing all its
+ * commands, this value should be zero.
+ *
+ * See mxs_dma_append() for details on how DMA command blocks must be configured
+ * to maintain the expected behavior of the semaphore's value.
+ */
+static int mxs_dma_read_semaphore(int channel)
+{
+	struct mx28_apbh_regs *apbh_regs =
+		(struct mx28_apbh_regs *)MXS_APBH_BASE;
+	uint32_t tmp;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	tmp = readl(&apbh_regs->ch[channel].hw_apbh_ch_sema);
+
+	tmp &= APBH_CHn_SEMA_PHORE_MASK;
+	tmp >>= APBH_CHn_SEMA_PHORE_OFFSET;
+
+	return tmp;
+}
+
+/*
+ * Enable a DMA channel.
+ *
+ * If the given channel has any DMA descriptors on its active list, this
+ * function causes the DMA hardware to begin processing them.
+ *
+ * This function marks the DMA channel as "busy," whether or not there are any
+ * descriptors to process.
+ */
+static int mxs_dma_enable(int channel)
+{
+	struct mx28_apbh_regs *apbh_regs =
+		(struct mx28_apbh_regs *)MXS_APBH_BASE;
+	unsigned int sem;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_desc *pdesc;
+	struct mxs_dma_desc *last_desc;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	pchan = mxs_dma_channels + channel;
+
+	if (pchan->pending_num == 0) {
+		pchan->flags |= MXS_DMA_FLAGS_BUSY;
+		return 0;
+	}
+
+	pdesc = list_first_entry(&pchan->active, struct mxs_dma_desc, node);
+	if (pdesc == NULL)
+		return -EFAULT;
+
+	last_desc = list_entry(pchan->active.prev, struct mxs_dma_desc,
+			       node);
+
+	mxs_dma_flush_desc(last_desc);
+
+	if (pchan->flags & MXS_DMA_FLAGS_BUSY) {
+		if (!(pdesc->cmd.data & MXS_DMA_DESC_CHAIN))
+			return 0;
+
+		sem = mxs_dma_read_semaphore(channel);
+		if (sem == 0)
+			return 0;
+
+		if (sem == 1) {
+			pdesc = list_entry(pdesc->node.next,
+					   struct mxs_dma_desc, node);
+			writel(mxs_dma_cmd_address(pdesc),
+				&apbh_regs->ch[channel].hw_apbh_ch_nxtcmdar);
+		}
+		writel(pchan->pending_num,
+			&apbh_regs->ch[channel].hw_apbh_ch_sema);
+		pchan->active_num += pchan->pending_num;
+		pchan->pending_num = 0;
+	} else {
+		pchan->active_num += pchan->pending_num;
+		pchan->pending_num = 0;
+		writel(mxs_dma_cmd_address(pdesc),
+			&apbh_regs->ch[channel].hw_apbh_ch_nxtcmdar);
+		writel(pchan->active_num,
+			&apbh_regs->ch[channel].hw_apbh_ch_sema);
+		writel(1 << (channel + APBH_CTRL0_CLKGATE_CHANNEL_OFFSET),
+			&apbh_regs->hw_apbh_ctrl0_clr);
+	}
+
+	pchan->flags |= MXS_DMA_FLAGS_BUSY;
+	return 0;
+}
+
+/*
+ * Disable a DMA channel.
+ *
+ * This function shuts down a DMA channel and marks it as "not busy." Any
+ * descriptors on the active list are immediately moved to the head of the
+ * "done" list, whether or not they have actually been processed by the
+ * hardware. The "ready" flags of these descriptors are NOT cleared, so they
+ * still appear to be active.
+ *
+ * This function immediately shuts down a DMA channel's hardware, aborting any
+ * I/O that may be in progress, potentially leaving I/O hardware in an undefined
+ * state. It is unwise to call this function if there is ANY chance the hardware
+ * is still processing a command.
+ */
+static int mxs_dma_disable(int channel)
+{
+	struct mxs_dma_chan *pchan;
+	struct mx28_apbh_regs *apbh_regs =
+		(struct mx28_apbh_regs *)MXS_APBH_BASE;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	pchan = mxs_dma_channels + channel;
+
+	if (!(pchan->flags & MXS_DMA_FLAGS_BUSY))
+		return -EINVAL;
+
+	writel(1 << (channel + APBH_CTRL0_CLKGATE_CHANNEL_OFFSET),
+		&apbh_regs->hw_apbh_ctrl0_set);
+
+	pchan->flags &= ~MXS_DMA_FLAGS_BUSY;
+	pchan->active_num = 0;
+	pchan->pending_num = 0;
+	list_splice_init(&pchan->active, &pchan->done);
+
+	return 0;
+}
+
+/*
+ * Resets the DMA channel hardware.
+ */
+static int mxs_dma_reset(int channel)
+{
+	struct mx28_apbh_regs *apbh_regs =
+		(struct mx28_apbh_regs *)MXS_APBH_BASE;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	writel(1 << (channel + APBH_CHANNEL_CTRL_RESET_CHANNEL_OFFSET),
+		&apbh_regs->hw_apbh_channel_ctrl_set);
+
+	return 0;
+}
+
+/*
+ * Enable or disable DMA interrupt.
+ *
+ * This function enables the given DMA channel to interrupt the CPU.
+ */
+static int mxs_dma_enable_irq(int channel, int enable)
+{
+	struct mx28_apbh_regs *apbh_regs =
+		(struct mx28_apbh_regs *)MXS_APBH_BASE;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	if (enable)
+		writel(1 << (channel + APBH_CTRL1_CH_CMDCMPLT_IRQ_EN_OFFSET),
+			&apbh_regs->hw_apbh_ctrl1_set);
+	else
+		writel(1 << (channel + APBH_CTRL1_CH_CMDCMPLT_IRQ_EN_OFFSET),
+			&apbh_regs->hw_apbh_ctrl1_clr);
+
+	return 0;
+}
+
+/*
+ * Clear DMA interrupt.
+ *
+ * The software that is using the DMA channel must register to receive its
+ * interrupts and, when they arrive, must call this function to clear them.
+ */
+static int mxs_dma_ack_irq(int channel)
+{
+	struct mx28_apbh_regs *apbh_regs =
+		(struct mx28_apbh_regs *)MXS_APBH_BASE;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	writel(1 << channel, &apbh_regs->hw_apbh_ctrl1_clr);
+	writel(1 << channel, &apbh_regs->hw_apbh_ctrl2_clr);
+
+	return 0;
+}
+
+/*
+ * Request to reserve a DMA channel
+ */
+static int mxs_dma_request(int channel)
+{
+	struct mxs_dma_chan *pchan;
+
+	if ((channel < 0) || (channel >= MXS_MAX_DMA_CHANNELS))
+		return -EINVAL;
+
+	pchan = mxs_dma_channels + channel;
+	if ((pchan->flags & MXS_DMA_FLAGS_VALID) != MXS_DMA_FLAGS_VALID)
+		return -ENODEV;
+
+	if (pchan->flags & MXS_DMA_FLAGS_ALLOCATED)
+		return -EBUSY;
+
+	pchan->flags |= MXS_DMA_FLAGS_ALLOCATED;
+	pchan->active_num = 0;
+	pchan->pending_num = 0;
+
+	INIT_LIST_HEAD(&pchan->active);
+	INIT_LIST_HEAD(&pchan->done);
+
+	return 0;
+}
+
+/*
+ * Release a DMA channel.
+ *
+ * This function releases a DMA channel from its current owner.
+ *
+ * The channel will NOT be released if it's marked "busy" (see
+ * mxs_dma_enable()).
+ */
+static int mxs_dma_release(int channel)
+{
+	struct mxs_dma_chan *pchan;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	pchan = mxs_dma_channels + channel;
+
+	if (pchan->flags & MXS_DMA_FLAGS_BUSY)
+		return -EBUSY;
+
+	pchan->dev = 0;
+	pchan->active_num = 0;
+	pchan->pending_num = 0;
+	pchan->flags &= ~MXS_DMA_FLAGS_ALLOCATED;
+
+	return 0;
+}
+
+/*
+ * Allocate DMA descriptor
+ */
+struct mxs_dma_desc *mxs_dma_desc_alloc(void)
+{
+	struct mxs_dma_desc *pdesc;
+
+	pdesc = memalign(MXS_DMA_ALIGNMENT, sizeof(struct mxs_dma_desc));
+
+	if (pdesc == NULL)
+		return NULL;
+
+	memset(pdesc, 0, sizeof(*pdesc));
+	pdesc->address = (dma_addr_t)pdesc;
+
+	return pdesc;
+};
+
+/*
+ * Free DMA descriptor
+ */
+void mxs_dma_desc_free(struct mxs_dma_desc *pdesc)
+{
+	if (pdesc == NULL)
+		return;
+
+	free(pdesc);
+}
+EXPORT_SYMBOL(mxs_dma_desc_free);
+
+/*
+ * Add a DMA descriptor to a channel.
+ *
+ * If the descriptor list for this channel is not empty, this function sets the
+ * CHAIN bit and the NEXTCMD_ADDR fields in the last descriptor's DMA command so
+ * it will chain to the new descriptor's command.
+ *
+ * Then, this function marks the new descriptor as "ready," adds it to the end
+ * of the active descriptor list, and increments the count of pending
+ * descriptors.
+ *
+ * The MXS platform DMA software imposes some rules on DMA commands to maintain
+ * important invariants. These rules are NOT checked, but they must be carefully
+ * applied by software that uses MXS DMA channels.
+ *
+ * Invariant:
+ *     The DMA channel's hardware semaphore must reflect the number of DMA
+ *     commands the hardware will process, but has not yet finished.
+ *
+ * Explanation:
+ *     A DMA channel begins processing commands when its hardware semaphore is
+ *     written with a value greater than zero, and it stops processing commands
+ *     when the semaphore returns to zero.
+ *
+ *     When a channel finishes a DMA command, it will decrement its semaphore if
+ *     the DECREMENT_SEMAPHORE bit is set in that command's flags bits.
+ *
+ *     In principle, it's not necessary for the DECREMENT_SEMAPHORE to be set,
+ *     unless it suits the purposes of the software. For example, one could
+ *     construct a series of five DMA commands, with the DECREMENT_SEMAPHORE
+ *     bit set only in the last one. Then, setting the DMA channel's hardware
+ *     semaphore to one would cause the entire series of five commands to be
+ *     processed. However, this example would violate the invariant given above.
+ *
+ * Rule:
+ *    ALL DMA commands MUST have the DECREMENT_SEMAPHORE bit set so that the DMA
+ *    channel's hardware semaphore will be decremented EVERY time a command is
+ *    processed.
+ */
+int mxs_dma_desc_append(int channel, struct mxs_dma_desc *pdesc)
+{
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_desc *last;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	pchan = mxs_dma_channels + channel;
+
+	pdesc->cmd.next = mxs_dma_cmd_address(pdesc);
+	pdesc->flags |= MXS_DMA_DESC_FIRST | MXS_DMA_DESC_LAST;
+
+	if (!list_empty(&pchan->active)) {
+		last = list_entry(pchan->active.prev, struct mxs_dma_desc,
+					node);
+
+		pdesc->flags &= ~MXS_DMA_DESC_FIRST;
+		last->flags &= ~MXS_DMA_DESC_LAST;
+
+		last->cmd.next = mxs_dma_cmd_address(pdesc);
+		last->cmd.data |= MXS_DMA_DESC_CHAIN;
+
+		mxs_dma_flush_desc(last);
+	}
+	pdesc->flags |= MXS_DMA_DESC_READY;
+	if (pdesc->flags & MXS_DMA_DESC_FIRST)
+		pchan->pending_num++;
+	list_add_tail(&pdesc->node, &pchan->active);
+
+	return ret;
+}
+EXPORT_SYMBOL(mxs_dma_desc_append);
+
+/*
+ * Clean up processed DMA descriptors.
+ *
+ * This function removes processed DMA descriptors from the "active" list. Pass
+ * in a non-NULL list head to get the descriptors moved to your list. Pass NULL
+ * to get the descriptors moved to the channel's "done" list. Descriptors on
+ * the "done" list can be retrieved with mxs_dma_get_finished().
+ *
+ * This function marks the DMA channel as "not busy" if no unprocessed
+ * descriptors remain on the "active" list.
+ */
+static int mxs_dma_finish(int channel, struct list_head *head)
+{
+	int sem;
+	struct mxs_dma_chan *pchan;
+	struct list_head *p, *q;
+	struct mxs_dma_desc *pdesc;
+	int ret;
+
+	ret = mxs_dma_validate_chan(channel);
+	if (ret)
+		return ret;
+
+	pchan = mxs_dma_channels + channel;
+
+	sem = mxs_dma_read_semaphore(channel);
+	if (sem < 0)
+		return sem;
+
+	if (sem == pchan->active_num)
+		return 0;
+
+	list_for_each_safe(p, q, &pchan->active) {
+		if ((pchan->active_num) <= sem)
+			break;
+
+		pdesc = list_entry(p, struct mxs_dma_desc, node);
+		pdesc->flags &= ~MXS_DMA_DESC_READY;
+
+		if (head)
+			list_move_tail(p, head);
+		else
+			list_move_tail(p, &pchan->done);
+
+		if (pdesc->flags & MXS_DMA_DESC_LAST)
+			pchan->active_num--;
+	}
+
+	if (sem == 0)
+		pchan->flags &= ~MXS_DMA_FLAGS_BUSY;
+
+	return 0;
+}
+
+/*
+ * Wait for DMA channel to complete
+ */
+static int mxs_dma_wait_complete(uint32_t timeout, unsigned int chan)
+{
+	struct mx28_apbh_regs *apbh_regs =
+		(struct mx28_apbh_regs *)MXS_APBH_BASE;
+	int ret;
+
+	ret = mxs_dma_validate_chan(chan);
+	if (ret)
+		return ret;
+
+	if (mx28_wait_mask_set(&apbh_regs->hw_apbh_ctrl1_reg,
+				1 << chan, timeout)) {
+		mxs_nand_dump_dma("  DMA/err:", chan);
+		ret = -ETIMEDOUT;
+		mxs_dma_reset(chan);
+	}
+
+	return ret;
+}
+
+/*
+ * Execute the DMA channel
+ */
+int mxs_dma_go(int chan)
+{
+	uint32_t timeout = 10000;
+	int ret;
+
+	LIST_HEAD(tmp_desc_list);
+
+	ret = mxs_dma_validate_chan(chan);
+	if (ret)
+		return ret;
+
+	timeout *= (mxs_dma_channels[chan].active_num +
+		    mxs_dma_channels[chan].pending_num);
+	timeout += 1000;
+
+	mxs_dma_enable_irq(chan, 1);
+	mxs_dma_enable(chan);
+
+	/* Wait for DMA to finish. */
+	ret = mxs_dma_wait_complete(timeout, chan);
+
+	/* Clear out the descriptors we just ran. */
+	mxs_dma_finish(chan, &tmp_desc_list);
+
+	/* Shut the DMA channel down. */
+	mxs_dma_ack_irq(chan);
+	mxs_dma_reset(chan);
+	mxs_dma_enable_irq(chan, 0);
+	mxs_dma_disable(chan);
+
+	return ret;
+}
+EXPORT_SYMBOL(mxs_dma_go);
+
+/*
+ * Initialize the DMA hardware
+ */
+static int __init mxs_dma_init(void)
+{
+	struct mx28_apbh_regs *apbh_regs =
+		(struct mx28_apbh_regs *)MXS_APBH_BASE;
+	struct mxs_dma_chan *pchan;
+	int ret, channel;
+
+	mx28_reset_block(&apbh_regs->hw_apbh_ctrl0_reg, 0);
+
+#ifdef CONFIG_APBH_DMA_BURST8
+	writel(APBH_CTRL0_AHB_BURST8_EN,
+		&apbh_regs->hw_apbh_ctrl0_set);
+#else
+	writel(APBH_CTRL0_AHB_BURST8_EN,
+		&apbh_regs->hw_apbh_ctrl0_clr);
+#endif
+
+#ifdef CONFIG_APBH_DMA_BURST
+	writel(APBH_CTRL0_APB_BURST_EN,
+		&apbh_regs->hw_apbh_ctrl0_set);
+#else
+	writel(APBH_CTRL0_APB_BURST_EN,
+		&apbh_regs->hw_apbh_ctrl0_clr);
+#endif
+
+	for (channel = 0; channel < MXS_MAX_DMA_CHANNELS; channel++) {
+		pchan = mxs_dma_channels + channel;
+		pchan->flags = MXS_DMA_FLAGS_VALID;
+
+		ret = mxs_dma_request(channel);
+
+		if (ret) {
+			printf("MXS DMA: Can't acquire DMA channel %i\n",
+				channel);
+
+			goto err;
+		}
+
+		mxs_dma_reset(channel);
+		mxs_dma_ack_irq(channel);
+	}
+
+	return 0;
+
+err:
+	while (--channel >= 0)
+		mxs_dma_release(channel);
+	return ret;
+}
+coredevice_initcall(mxs_dma_init);
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/clock-imx28.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/clock-imx28.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/clock-imx28.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/clock-imx28.h	2013-01-14 12:46:28.000000000 +0100
@@ -18,6 +18,7 @@
 unsigned imx_get_ioclk(unsigned);
 unsigned imx_get_armclk(void);
 unsigned imx_get_hclk(void);
+unsigned int imx_set_hclk(unsigned int);
 unsigned imx_get_xclk(void);
 unsigned imx_get_sspclk(unsigned);
 unsigned imx_set_sspclk(unsigned, unsigned, int);
@@ -25,7 +26,12 @@
 unsigned imx_set_lcdifclk(unsigned);
 unsigned imx_get_lcdifclk(void);
 unsigned imx_get_fecclk(void);
+
+unsigned int imx_get_gpmiclk(void);
+unsigned int imx_set_gpmiclk(unsigned int nc, int use_ioclk);
+
 void imx_enable_enetclk(void);
+void imx_dump_clocks(void);
 
 #endif /* MACH_CLOCK_IMX28_H */
 
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/debug_ll.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/debug_ll.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/debug_ll.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/debug_ll.h	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,22 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_MACH_MXS_DEBUG_LL
+#define H_MACH_MXS_DEBUG_LL
+
+void putc(char c);
+
+#endif	/* H_MACH_MXS_DEBUG_LL */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/dma.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/dma.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/dma.h	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,144 @@
+/*
+ * Freescale i.MX28 APBH DMA
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __DMA_H__
+#define __DMA_H__
+
+#include <linux/list.h>
+
+#ifndef	CONFIG_ARCH_DMA_PIO_WORDS
+#define	DMA_PIO_WORDS		15
+#else
+#define	DMA_PIO_WORDS		CONFIG_ARCH_DMA_PIO_WORDS
+#endif
+
+#define MXS_DMA_ALIGNMENT	32
+
+/*
+ * MXS DMA channels
+ */
+enum {
+	MXS_DMA_CHANNEL_AHB_APBH_SSP0 = 0,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP2,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI0,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI1,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI2,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI4,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI5,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI6,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI7,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP,
+	MXS_MAX_DMA_CHANNELS,
+};
+
+/*
+ * MXS DMA hardware command.
+ *
+ * This structure describes the in-memory layout of an entire DMA command,
+ * including space for the maximum number of PIO accesses. See the appropriate
+ * reference manual for a detailed description of what these fields mean to the
+ * DMA hardware.
+ */
+#define	MXS_DMA_DESC_COMMAND_MASK	0x3
+#define	MXS_DMA_DESC_COMMAND_OFFSET	0
+#define	MXS_DMA_DESC_COMMAND_NO_DMAXFER	0x0
+#define	MXS_DMA_DESC_COMMAND_DMA_WRITE	0x1
+#define	MXS_DMA_DESC_COMMAND_DMA_READ	0x2
+#define	MXS_DMA_DESC_COMMAND_DMA_SENSE	0x3
+#define	MXS_DMA_DESC_CHAIN		(1 << 2)
+#define	MXS_DMA_DESC_IRQ		(1 << 3)
+#define	MXS_DMA_DESC_NAND_LOCK		(1 << 4)
+#define	MXS_DMA_DESC_NAND_WAIT_4_READY	(1 << 5)
+#define	MXS_DMA_DESC_DEC_SEM		(1 << 6)
+#define	MXS_DMA_DESC_WAIT4END		(1 << 7)
+#define	MXS_DMA_DESC_HALT_ON_TERMINATE	(1 << 8)
+#define	MXS_DMA_DESC_TERMINATE_FLUSH	(1 << 9)
+#define	MXS_DMA_DESC_PIO_WORDS_MASK	(0xf << 12)
+#define	MXS_DMA_DESC_PIO_WORDS_OFFSET	12
+#define	MXS_DMA_DESC_BYTES_MASK		(0xffff << 16)
+#define	MXS_DMA_DESC_BYTES_OFFSET	16
+
+struct mxs_dma_cmd {
+	unsigned long		next;
+	unsigned long		data;
+	union {
+		dma_addr_t	address;
+		unsigned long	alternate;
+	};
+	unsigned long		pio_words[DMA_PIO_WORDS];
+};
+
+/*
+ * MXS DMA command descriptor.
+ *
+ * This structure incorporates an MXS DMA hardware command structure, along
+ * with metadata.
+ */
+#define	MXS_DMA_DESC_FIRST	(1 << 0)
+#define	MXS_DMA_DESC_LAST	(1 << 1)
+#define	MXS_DMA_DESC_READY	(1 << 31)
+
+struct mxs_dma_desc {
+	struct mxs_dma_cmd	cmd;
+	unsigned int		flags;
+	dma_addr_t		address;
+	void			*buffer;
+	struct list_head	node;
+};
+
+/**
+ * MXS DMA channel
+ *
+ * This structure represents a single DMA channel. The MXS platform code
+ * maintains an array of these structures to represent every DMA channel in the
+ * system (see mxs_dma_channels).
+ */
+#define	MXS_DMA_FLAGS_IDLE	0
+#define	MXS_DMA_FLAGS_BUSY	(1 << 0)
+#define	MXS_DMA_FLAGS_FREE	0
+#define	MXS_DMA_FLAGS_ALLOCATED	(1 << 16)
+#define	MXS_DMA_FLAGS_VALID	(1 << 31)
+
+struct mxs_dma_chan {
+	const char *name;
+	unsigned long dev;
+	struct mxs_dma_device *dma;
+	unsigned int flags;
+	unsigned int active_num;
+	unsigned int pending_num;
+	struct list_head active;
+	struct list_head done;
+};
+
+struct mxs_dma_desc *mxs_dma_desc_alloc(void);
+void mxs_dma_desc_free(struct mxs_dma_desc *);
+int mxs_dma_desc_append(int channel, struct mxs_dma_desc *pdesc);
+
+int mxs_dma_go(int chan);
+
+#endif	/* __DMA_H__ */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/generic.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/generic.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/generic.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/generic.h	2013-01-14 12:46:28.000000000 +0100
@@ -28,3 +28,8 @@
 #else
 # define cpu_is_mx28()	(0)
 #endif
+
+#ifdef CONFIG_ARCH_IMX28
+int mx28_reset_block(void __iomem *reset_addr, int just_enable);
+int mx28_wait_mask_set(void __iomem *reg, uint32_t mask, int timeout);
+#endif
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/gpmi.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/gpmi.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/gpmi.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/gpmi.h	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,42 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_BAREBOX_ARCH_ARM_MACH_MXS_GPMI_H
+#define H_BAREBOX_ARCH_ARM_MACH_MXS_GPMI_H
+
+struct mxs_nand_platform_data {
+	unsigned int	ns_data_setup;
+	unsigned int	ns_data_hold;
+	unsigned int	ns_address_setup;
+	unsigned int	ns_busy_timeout;
+};
+
+struct mxs_nand_fcb_params {
+	unsigned int	timing0;
+	unsigned int	timing1;
+	unsigned int	page_data_size;
+	unsigned int	total_page_size;
+	unsigned int	pages_per_block;
+	unsigned int	ecc_type[2];
+	unsigned int	block_size[2];
+	unsigned int	num_ecc_blocks;
+	unsigned int	metadata_bytes;
+	unsigned int	bad_block_bit;
+};
+
+struct mxs_nand_fcb_params const *mxs_nand_get_fcb_params(struct device_d *dev);
+
+#endif	/* H_BAREBOX_ARCH_ARM_MACH_MXS_GPMI_H */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/imx28-regs.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/imx28-regs.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/imx28-regs.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/imx28-regs.h	2013-01-14 12:46:28.000000000 +0100
@@ -44,4 +44,8 @@
 #define IMX_FEC0_BASE		0x800F0000
 #define IMX_FEC1_BASE		0x800F4000
 
+#define MXS_APBH_BASE		0x80004000
+#define MXS_BCH_BASE		0x8000A000
+#define MXS_GPMI_BASE		0x8000C000
+
 #endif /* __ASM_ARCH_MX28_REGS_H */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/iomux-imx28.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/iomux-imx28.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/iomux-imx28.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/iomux-imx28.h	2013-01-14 12:46:28.000000000 +0100
@@ -242,6 +242,42 @@
 
 /* TODO */
 
+#define SSP2_SCK		(FUNC(0) | PORTF(2,16) | SE | VE | BK)
+#define SSP2_SCK_AUART2_RX	(FUNC(1) | PORTF(2,16) | SE | VE | BK)
+#define SSP2_SCK_SAIF0_SDATA1	(FUNC(2) | PORTF(2,16) | SE | VE | BK)
+#define SSP2_SCK_GPIO		(FUNC(3) | PORTF(2,16) | SE | VE | BK)
+
+#define SSP2_MOSI		(FUNC(0) | PORTF(2,17) | SE | VE | PE)
+#define SSP2_MOSI_SSP2_CMD	(FUNC(0) | PORTF(2,17) | SE | VE | PE)
+#define SSP2_MOSI_AUART2_TX	(FUNC(1) | PORTF(2,17) | SE | VE | PE)
+#define SSP2_MOSI_SAIF0_SDATA2	(FUNC(2) | PORTF(2,17) | SE | VE | PE)
+#define SSP2_MOSI_GPIO		(FUNC(3) | PORTF(2,17) | SE | VE | PE)
+
+#define SSP2_MISO		(FUNC(0) | PORTF(2,18) | SE | VE | PE)
+#define SSP2_MISO_SSP2_D0	(FUNC(0) | PORTF(2,18) | SE | VE | PE)
+#define SSP2_MISO_AUART3_RX	(FUNC(1) | PORTF(2,18) | SE | VE | PE)
+#define SSP2_MISO_SAIF1_SDATA1	(FUNC(2) | PORTF(2,18) | SE | VE | PE)
+#define SSP2_MISO_GPIO		(FUNC(3) | PORTF(2,18) | SE | VE | PE)
+
+#define SSP2_SS0		(FUNC(0) | PORTF(2,19) | SE | VE | PE)
+#define SSP2_SS0_SSP2_D3	(FUNC(0) | PORTF(2,19) | SE | VE | PE)
+#define SSP2_SS0_AUART3_TX	(FUNC(1) | PORTF(2,19) | SE | VE | PE)
+#define SSP2_SS0_SAIF1_SDATA2	(FUNC(2) | PORTF(2,19) | SE | VE | PE)
+#define SSP2_SS0_GPIO		(FUNC(3) | PORTF(2,19) | SE | VE | PE)
+
+#define SSP2_SS1		(FUNC(0) | PORTF(2,20) | SE | VE | PE)
+#define SSP2_SS1_SSP2_D4	(FUNC(0) | PORTF(2,20) | SE | VE | PE)
+#define SSP2_SS1_SSP2_D1	(FUNC(1) | PORTF(2,20) | SE | VE | PE)
+#define SSP2_SS1_USB1_OC	(FUNC(2) | PORTF(2,20) | SE | VE | PE)
+#define SSP2_SS1_GPIO		(FUNC(3) | PORTF(2,20) | SE | VE | PE)
+
+#define SSP2_SS2		(FUNC(0) | PORTF(2,21) | SE | VE | PE)
+#define SSP2_SS2_SSP2_D5	(FUNC(0) | PORTF(2,21) | SE | VE | PE)
+#define SSP2_SS2_SSP2_D2	(FUNC(1) | PORTF(2,21) | SE | VE | PE)
+#define SSP2_SS2_USB0_OC	(FUNC(2) | PORTF(2,21) | SE | VE | PE)
+#define SSP2_SS2_GPIO		(FUNC(3) | PORTF(2,21) | SE | VE | PE)
+
+
 /* Bank 2, GPIO pins 64 ... 95 */
 
 /* TODO */
@@ -294,20 +330,60 @@
 #define LCD_RESET		(FUNC(0) | PORTF(3, 30))
 #define LCD_RESET_LCD_VSYNC	(FUNC(1) | PORTF(3, 30))
 #define LCD_RESET_GPIO		(FUNC(3) | PORTF(3, 30))
-#define PWM4			(FUNC(0) | PORTF(3, 29))
-#define PWM4_GPIO		(FUNC(3) | PORTF(3, 29))
-#define PWM3			(FUNC(0) | PORTF(3 28))
-#define PWM3_GPIO		(FUNC(3) | PORTF(3, 28))
+#define PWM4			(FUNC(0) | PORTF(3, 29) | SE | VE | BK)
+#define PWM4_GPIO		(FUNC(3) | PORTF(3, 29) | SE | VE | BK)
 
-#define PWM2			(FUNC(0) | PORTF(3, 18))
+#define PWM3			(FUNC(0) | PORTF(3, 28) | SE | VE | BK)
+#define PWM3_GPIO		(FUNC(3) | PORTF(3, 28) | SE | VE | BK)
+
+#define I2C0_SCL		(FUNC(0) | PORTF(3, 24) | SE | VE | BK)
+#define I2C0_SCL_ROTARYA	(FUNC(1) | PORTF(3, 24) | SE | VE | BK)
+#define I2C0_SCL_DUART_RX	(FUNC(2) | PORTF(3, 24) | SE | VE | BK)
+#define I2C0_SCL_GPIO		(FUNC(3) | PORTF(3, 24) | SE | VE | BK)
+
+#define I2C0_SDA		(FUNC(0) | PORTF(3, 25) | SE | VE | BK)
+#define I2C0_SDA_ROTARYB	(FUNC(1) | PORTF(3, 25) | SE | VE | BK)
+#define I2C0_SDA_DUART_TX	(FUNC(2) | PORTF(3, 25) | SE | VE | BK)
+#define I2C0_SDA_GPIO		(FUNC(3) | PORTF(3, 25) | SE | VE | BK)
+
+#define SAIF0_MCLK		(FUNC(0) | PORTF(3, 20) | SE | VE | BK)
+#define SAIF0_MCLK_PWM3		(FUNC(1) | PORTF(3, 20) | SE | VE | BK)
+#define SAIF0_MCLK_AUART4_CTS	(FUNC(2) | PORTF(3, 20) | SE | VE | BK)
+#define SAIF0_MCLK_GPIO		(FUNC(3) | PORTF(3, 20) | SE | VE | BK)
+
+#define SAIF0_LRCLK		(FUNC(0) | PORTF(3, 21) | SE | VE | BK)
+#define SAIF0_LRCLK_PWM4	(FUNC(1) | PORTF(3, 21) | SE | VE | BK)
+#define SAIF0_LRCLK_AUART4_RTS	(FUNC(2) | PORTF(3, 21) | SE | VE | BK)
+#define SAIF0_LRCLK_GPIO	(FUNC(3) | PORTF(3, 21) | SE | VE | BK)
+
+#define SAIF0_BITCLK		(FUNC(0) | PORTF(3, 22) | SE | VE | BK)
+#define SAIF0_BITCLK_PWM5	(FUNC(1) | PORTF(3, 22) | SE | VE | BK)
+#define SAIF0_BITCLK_AUART4_RX	(FUNC(2) | PORTF(3, 22) | SE | VE | BK)
+#define SAIF0_BITCLK_GPIO	(FUNC(3) | PORTF(3, 22) | SE | VE | BK)
+
+#define SAIF0_SDATA0		(FUNC(0) | PORTF(3, 23) | SE | VE | BK)
+#define SAIF0_SDATA0_PWM6	(FUNC(1) | PORTF(3, 23) | SE | VE | BK)
+#define SAIF0_SDATA0_AUART4_TX	(FUNC(2) | PORTF(3, 23) | SE | VE | BK)
+#define SAIF0_SDATA0_GPIO	(FUNC(3) | PORTF(3, 23) | SE | VE | BK)
+
+#define SAIF1_SDATA0		(FUNC(0) | PORTF(3, 26) | SE | VE | BK)
+#define SAIF1_SDATA0_PWM7	(FUNC(1) | PORTF(3, 26) | SE | VE | BK)
+#define SAIF1_SDATA0_SAIF0_SDATA1 (FUNC(2) | PORTF(3, 26) | SE | VE | BK)
+#define SAIF1_SDATA0_GPIO	(FUNC(3) | PORTF(3, 26) | SE | VE | BK)
+
+#define PWM2			(FUNC(0) | PORTF(3, 18) | SE | VE | PE)
+#define PWM2_USB0_ID		(FUNC(1) | PORTF(3, 18) | SE | VE | PE)
+#define PWM2_USB1_OC		(FUNC(2) | PORTF(3, 18) | SE | VE | PE)
+#define PWM2_GPIO		(FUNC(3) | PORTF(3, 18) | SE | VE | PE)
 
 #define PWM1			(FUNC(0) | PORTF(3, 17))
 #define PWM1_DUART_TX		(FUNC(2) | PORTF(3, 17))
 
-#define PWM0			(FUNC(0) | PORTF(3, 16))
-#define PWM0_I2C1_SCL		(FUNC(1) | PORTF(3, 16))
-#define PWM0_DUART_RX		(FUNC(2) | PORTF(3, 16))
-#define PWM0_GPIO		(FUNC(3) | PORTF(3, 16))
+#define PWM0			(FUNC(0) | PORTF(3, 16) | SE | VE | BK)
+#define PWM0_I2C1_SCL		(FUNC(1) | PORTF(3, 16) | SE | VE | BK)
+#define PWM0_DUART_RX		(FUNC(2) | PORTF(3, 16) | SE | VE | BK)
+#define PWM0_GPIO		(FUNC(3) | PORTF(3, 16) | SE | VE | BK)
+
 #define AUART3_RTS		(FUNC(0) | PORTF(3, 15) | SE | VE | BK)
 #define AUART3_RTS_CAN1_RX	(FUNC(1) | PORTF(3, 15) | SE | VE | BK)
 #define AUART3_RTS_ENET0_1588_EVENT1_IN	(FUNC(2) | PORTF(3, 15) | SE | VE | BK)
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/regs-apbh.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/regs-apbh.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/regs-apbh.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/regs-apbh.h	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,466 @@
+/*
+ * Freescale i.MX28 APBH Register Definitions
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __REGS_APBH_H__
+#define __REGS_APBH_H__
+
+#include <mach/regs-common.h>
+
+#ifndef	__ASSEMBLY__
+struct mx28_apbh_regs {
+	mx28_reg(hw_apbh_ctrl0)
+	mx28_reg(hw_apbh_ctrl1)
+	mx28_reg(hw_apbh_ctrl2)
+	mx28_reg(hw_apbh_channel_ctrl)
+	mx28_reg(hw_apbh_devsel)
+	mx28_reg(hw_apbh_dma_burst_size)
+	mx28_reg(hw_apbh_debug)
+
+	uint32_t	reserved[36];
+
+	union {
+	struct {
+		mx28_reg(hw_apbh_ch_curcmdar)
+		mx28_reg(hw_apbh_ch_nxtcmdar)
+		mx28_reg(hw_apbh_ch_cmd)
+		mx28_reg(hw_apbh_ch_bar)
+		mx28_reg(hw_apbh_ch_sema)
+		mx28_reg(hw_apbh_ch_debug1)
+		mx28_reg(hw_apbh_ch_debug2)
+	} ch[16];
+	struct {
+		mx28_reg(hw_apbh_ch0_curcmdar)
+		mx28_reg(hw_apbh_ch0_nxtcmdar)
+		mx28_reg(hw_apbh_ch0_cmd)
+		mx28_reg(hw_apbh_ch0_bar)
+		mx28_reg(hw_apbh_ch0_sema)
+		mx28_reg(hw_apbh_ch0_debug1)
+		mx28_reg(hw_apbh_ch0_debug2)
+		mx28_reg(hw_apbh_ch1_curcmdar)
+		mx28_reg(hw_apbh_ch1_nxtcmdar)
+		mx28_reg(hw_apbh_ch1_cmd)
+		mx28_reg(hw_apbh_ch1_bar)
+		mx28_reg(hw_apbh_ch1_sema)
+		mx28_reg(hw_apbh_ch1_debug1)
+		mx28_reg(hw_apbh_ch1_debug2)
+		mx28_reg(hw_apbh_ch2_curcmdar)
+		mx28_reg(hw_apbh_ch2_nxtcmdar)
+		mx28_reg(hw_apbh_ch2_cmd)
+		mx28_reg(hw_apbh_ch2_bar)
+		mx28_reg(hw_apbh_ch2_sema)
+		mx28_reg(hw_apbh_ch2_debug1)
+		mx28_reg(hw_apbh_ch2_debug2)
+		mx28_reg(hw_apbh_ch3_curcmdar)
+		mx28_reg(hw_apbh_ch3_nxtcmdar)
+		mx28_reg(hw_apbh_ch3_cmd)
+		mx28_reg(hw_apbh_ch3_bar)
+		mx28_reg(hw_apbh_ch3_sema)
+		mx28_reg(hw_apbh_ch3_debug1)
+		mx28_reg(hw_apbh_ch3_debug2)
+		mx28_reg(hw_apbh_ch4_curcmdar)
+		mx28_reg(hw_apbh_ch4_nxtcmdar)
+		mx28_reg(hw_apbh_ch4_cmd)
+		mx28_reg(hw_apbh_ch4_bar)
+		mx28_reg(hw_apbh_ch4_sema)
+		mx28_reg(hw_apbh_ch4_debug1)
+		mx28_reg(hw_apbh_ch4_debug2)
+		mx28_reg(hw_apbh_ch5_curcmdar)
+		mx28_reg(hw_apbh_ch5_nxtcmdar)
+		mx28_reg(hw_apbh_ch5_cmd)
+		mx28_reg(hw_apbh_ch5_bar)
+		mx28_reg(hw_apbh_ch5_sema)
+		mx28_reg(hw_apbh_ch5_debug1)
+		mx28_reg(hw_apbh_ch5_debug2)
+		mx28_reg(hw_apbh_ch6_curcmdar)
+		mx28_reg(hw_apbh_ch6_nxtcmdar)
+		mx28_reg(hw_apbh_ch6_cmd)
+		mx28_reg(hw_apbh_ch6_bar)
+		mx28_reg(hw_apbh_ch6_sema)
+		mx28_reg(hw_apbh_ch6_debug1)
+		mx28_reg(hw_apbh_ch6_debug2)
+		mx28_reg(hw_apbh_ch7_curcmdar)
+		mx28_reg(hw_apbh_ch7_nxtcmdar)
+		mx28_reg(hw_apbh_ch7_cmd)
+		mx28_reg(hw_apbh_ch7_bar)
+		mx28_reg(hw_apbh_ch7_sema)
+		mx28_reg(hw_apbh_ch7_debug1)
+		mx28_reg(hw_apbh_ch7_debug2)
+		mx28_reg(hw_apbh_ch8_curcmdar)
+		mx28_reg(hw_apbh_ch8_nxtcmdar)
+		mx28_reg(hw_apbh_ch8_cmd)
+		mx28_reg(hw_apbh_ch8_bar)
+		mx28_reg(hw_apbh_ch8_sema)
+		mx28_reg(hw_apbh_ch8_debug1)
+		mx28_reg(hw_apbh_ch8_debug2)
+		mx28_reg(hw_apbh_ch9_curcmdar)
+		mx28_reg(hw_apbh_ch9_nxtcmdar)
+		mx28_reg(hw_apbh_ch9_cmd)
+		mx28_reg(hw_apbh_ch9_bar)
+		mx28_reg(hw_apbh_ch9_sema)
+		mx28_reg(hw_apbh_ch9_debug1)
+		mx28_reg(hw_apbh_ch9_debug2)
+		mx28_reg(hw_apbh_ch10_curcmdar)
+		mx28_reg(hw_apbh_ch10_nxtcmdar)
+		mx28_reg(hw_apbh_ch10_cmd)
+		mx28_reg(hw_apbh_ch10_bar)
+		mx28_reg(hw_apbh_ch10_sema)
+		mx28_reg(hw_apbh_ch10_debug1)
+		mx28_reg(hw_apbh_ch10_debug2)
+		mx28_reg(hw_apbh_ch11_curcmdar)
+		mx28_reg(hw_apbh_ch11_nxtcmdar)
+		mx28_reg(hw_apbh_ch11_cmd)
+		mx28_reg(hw_apbh_ch11_bar)
+		mx28_reg(hw_apbh_ch11_sema)
+		mx28_reg(hw_apbh_ch11_debug1)
+		mx28_reg(hw_apbh_ch11_debug2)
+		mx28_reg(hw_apbh_ch12_curcmdar)
+		mx28_reg(hw_apbh_ch12_nxtcmdar)
+		mx28_reg(hw_apbh_ch12_cmd)
+		mx28_reg(hw_apbh_ch12_bar)
+		mx28_reg(hw_apbh_ch12_sema)
+		mx28_reg(hw_apbh_ch12_debug1)
+		mx28_reg(hw_apbh_ch12_debug2)
+		mx28_reg(hw_apbh_ch13_curcmdar)
+		mx28_reg(hw_apbh_ch13_nxtcmdar)
+		mx28_reg(hw_apbh_ch13_cmd)
+		mx28_reg(hw_apbh_ch13_bar)
+		mx28_reg(hw_apbh_ch13_sema)
+		mx28_reg(hw_apbh_ch13_debug1)
+		mx28_reg(hw_apbh_ch13_debug2)
+		mx28_reg(hw_apbh_ch14_curcmdar)
+		mx28_reg(hw_apbh_ch14_nxtcmdar)
+		mx28_reg(hw_apbh_ch14_cmd)
+		mx28_reg(hw_apbh_ch14_bar)
+		mx28_reg(hw_apbh_ch14_sema)
+		mx28_reg(hw_apbh_ch14_debug1)
+		mx28_reg(hw_apbh_ch14_debug2)
+		mx28_reg(hw_apbh_ch15_curcmdar)
+		mx28_reg(hw_apbh_ch15_nxtcmdar)
+		mx28_reg(hw_apbh_ch15_cmd)
+		mx28_reg(hw_apbh_ch15_bar)
+		mx28_reg(hw_apbh_ch15_sema)
+		mx28_reg(hw_apbh_ch15_debug1)
+		mx28_reg(hw_apbh_ch15_debug2)
+	};
+	};
+	mx28_reg(hw_apbh_version)
+};
+#endif
+
+#define	APBH_CTRL0_SFTRST				(1 << 31)
+#define	APBH_CTRL0_CLKGATE				(1 << 30)
+#define	APBH_CTRL0_AHB_BURST8_EN			(1 << 29)
+#define	APBH_CTRL0_APB_BURST_EN				(1 << 28)
+#define	APBH_CTRL0_RSVD0_MASK				(0xfff << 16)
+#define	APBH_CTRL0_RSVD0_OFFSET				16
+#define	APBH_CTRL0_CLKGATE_CHANNEL_MASK			0xffff
+#define	APBH_CTRL0_CLKGATE_CHANNEL_OFFSET		0
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP0			0x0001
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP1			0x0002
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP2			0x0004
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP3			0x0008
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND0		0x0010
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND1		0x0020
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND2		0x0040
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND3		0x0080
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND4		0x0100
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND5		0x0200
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND6		0x0400
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND7		0x0800
+#define	APBH_CTRL0_CLKGATE_CHANNEL_HSADC		0x1000
+#define	APBH_CTRL0_CLKGATE_CHANNEL_LCDIF		0x2000
+
+#define	APBH_CTRL1_CH15_CMDCMPLT_IRQ_EN			(1 << 31)
+#define	APBH_CTRL1_CH14_CMDCMPLT_IRQ_EN			(1 << 30)
+#define	APBH_CTRL1_CH13_CMDCMPLT_IRQ_EN			(1 << 29)
+#define	APBH_CTRL1_CH12_CMDCMPLT_IRQ_EN			(1 << 28)
+#define	APBH_CTRL1_CH11_CMDCMPLT_IRQ_EN			(1 << 27)
+#define	APBH_CTRL1_CH10_CMDCMPLT_IRQ_EN			(1 << 26)
+#define	APBH_CTRL1_CH9_CMDCMPLT_IRQ_EN			(1 << 25)
+#define	APBH_CTRL1_CH8_CMDCMPLT_IRQ_EN			(1 << 24)
+#define	APBH_CTRL1_CH7_CMDCMPLT_IRQ_EN			(1 << 23)
+#define	APBH_CTRL1_CH6_CMDCMPLT_IRQ_EN			(1 << 22)
+#define	APBH_CTRL1_CH5_CMDCMPLT_IRQ_EN			(1 << 21)
+#define	APBH_CTRL1_CH4_CMDCMPLT_IRQ_EN			(1 << 20)
+#define	APBH_CTRL1_CH3_CMDCMPLT_IRQ_EN			(1 << 19)
+#define	APBH_CTRL1_CH2_CMDCMPLT_IRQ_EN			(1 << 18)
+#define	APBH_CTRL1_CH1_CMDCMPLT_IRQ_EN			(1 << 17)
+#define	APBH_CTRL1_CH0_CMDCMPLT_IRQ_EN			(1 << 16)
+#define	APBH_CTRL1_CH_CMDCMPLT_IRQ_EN_OFFSET		16
+#define	APBH_CTRL1_CH_CMDCMPLT_IRQ_EN_MASK		(0xffff << 16)
+#define	APBH_CTRL1_CH15_CMDCMPLT_IRQ			(1 << 15)
+#define	APBH_CTRL1_CH14_CMDCMPLT_IRQ			(1 << 14)
+#define	APBH_CTRL1_CH13_CMDCMPLT_IRQ			(1 << 13)
+#define	APBH_CTRL1_CH12_CMDCMPLT_IRQ			(1 << 12)
+#define	APBH_CTRL1_CH11_CMDCMPLT_IRQ			(1 << 11)
+#define	APBH_CTRL1_CH10_CMDCMPLT_IRQ			(1 << 10)
+#define	APBH_CTRL1_CH9_CMDCMPLT_IRQ			(1 << 9)
+#define	APBH_CTRL1_CH8_CMDCMPLT_IRQ			(1 << 8)
+#define	APBH_CTRL1_CH7_CMDCMPLT_IRQ			(1 << 7)
+#define	APBH_CTRL1_CH6_CMDCMPLT_IRQ			(1 << 6)
+#define	APBH_CTRL1_CH5_CMDCMPLT_IRQ			(1 << 5)
+#define	APBH_CTRL1_CH4_CMDCMPLT_IRQ			(1 << 4)
+#define	APBH_CTRL1_CH3_CMDCMPLT_IRQ			(1 << 3)
+#define	APBH_CTRL1_CH2_CMDCMPLT_IRQ			(1 << 2)
+#define	APBH_CTRL1_CH1_CMDCMPLT_IRQ			(1 << 1)
+#define	APBH_CTRL1_CH0_CMDCMPLT_IRQ			(1 << 0)
+
+#define	APBH_CTRL2_CH15_ERROR_STATUS			(1 << 31)
+#define	APBH_CTRL2_CH14_ERROR_STATUS			(1 << 30)
+#define	APBH_CTRL2_CH13_ERROR_STATUS			(1 << 29)
+#define	APBH_CTRL2_CH12_ERROR_STATUS			(1 << 28)
+#define	APBH_CTRL2_CH11_ERROR_STATUS			(1 << 27)
+#define	APBH_CTRL2_CH10_ERROR_STATUS			(1 << 26)
+#define	APBH_CTRL2_CH9_ERROR_STATUS			(1 << 25)
+#define	APBH_CTRL2_CH8_ERROR_STATUS			(1 << 24)
+#define	APBH_CTRL2_CH7_ERROR_STATUS			(1 << 23)
+#define	APBH_CTRL2_CH6_ERROR_STATUS			(1 << 22)
+#define	APBH_CTRL2_CH5_ERROR_STATUS			(1 << 21)
+#define	APBH_CTRL2_CH4_ERROR_STATUS			(1 << 20)
+#define	APBH_CTRL2_CH3_ERROR_STATUS			(1 << 19)
+#define	APBH_CTRL2_CH2_ERROR_STATUS			(1 << 18)
+#define	APBH_CTRL2_CH1_ERROR_STATUS			(1 << 17)
+#define	APBH_CTRL2_CH0_ERROR_STATUS			(1 << 16)
+#define	APBH_CTRL2_CH15_ERROR_IRQ			(1 << 15)
+#define	APBH_CTRL2_CH14_ERROR_IRQ			(1 << 14)
+#define	APBH_CTRL2_CH13_ERROR_IRQ			(1 << 13)
+#define	APBH_CTRL2_CH12_ERROR_IRQ			(1 << 12)
+#define	APBH_CTRL2_CH11_ERROR_IRQ			(1 << 11)
+#define	APBH_CTRL2_CH10_ERROR_IRQ			(1 << 10)
+#define	APBH_CTRL2_CH9_ERROR_IRQ			(1 << 9)
+#define	APBH_CTRL2_CH8_ERROR_IRQ			(1 << 8)
+#define	APBH_CTRL2_CH7_ERROR_IRQ			(1 << 7)
+#define	APBH_CTRL2_CH6_ERROR_IRQ			(1 << 6)
+#define	APBH_CTRL2_CH5_ERROR_IRQ			(1 << 5)
+#define	APBH_CTRL2_CH4_ERROR_IRQ			(1 << 4)
+#define	APBH_CTRL2_CH3_ERROR_IRQ			(1 << 3)
+#define	APBH_CTRL2_CH2_ERROR_IRQ			(1 << 2)
+#define	APBH_CTRL2_CH1_ERROR_IRQ			(1 << 1)
+#define	APBH_CTRL2_CH0_ERROR_IRQ			(1 << 0)
+
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_MASK		(0xffff << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_OFFSET		16
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP0		(0x0001 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP1		(0x0002 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP2		(0x0004 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP3		(0x0008 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND0		(0x0010 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND1		(0x0020 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND2		(0x0040 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND3		(0x0080 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND4		(0x0100 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND5		(0x0200 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND6		(0x0400 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND7		(0x0800 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_HSADC		(0x1000 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_LCDIF		(0x2000 << 16)
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_MASK		0xffff
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_OFFSET		0
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP0		0x0001
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP1		0x0002
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP2		0x0004
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP3		0x0008
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND0		0x0010
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND1		0x0020
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND2		0x0040
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND3		0x0080
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND4		0x0100
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND5		0x0200
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND6		0x0400
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND7		0x0800
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_HSADC		0x1000
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_LCDIF		0x2000
+
+#define	APBH_DEVSEL_CH15_MASK				(0x3 << 30)
+#define	APBH_DEVSEL_CH15_OFFSET				30
+#define	APBH_DEVSEL_CH14_MASK				(0x3 << 28)
+#define	APBH_DEVSEL_CH14_OFFSET				28
+#define	APBH_DEVSEL_CH13_MASK				(0x3 << 26)
+#define	APBH_DEVSEL_CH13_OFFSET				26
+#define	APBH_DEVSEL_CH12_MASK				(0x3 << 24)
+#define	APBH_DEVSEL_CH12_OFFSET				24
+#define	APBH_DEVSEL_CH11_MASK				(0x3 << 22)
+#define	APBH_DEVSEL_CH11_OFFSET				22
+#define	APBH_DEVSEL_CH10_MASK				(0x3 << 20)
+#define	APBH_DEVSEL_CH10_OFFSET				20
+#define	APBH_DEVSEL_CH9_MASK				(0x3 << 18)
+#define	APBH_DEVSEL_CH9_OFFSET				18
+#define	APBH_DEVSEL_CH8_MASK				(0x3 << 16)
+#define	APBH_DEVSEL_CH8_OFFSET				16
+#define	APBH_DEVSEL_CH7_MASK				(0x3 << 14)
+#define	APBH_DEVSEL_CH7_OFFSET				14
+#define	APBH_DEVSEL_CH6_MASK				(0x3 << 12)
+#define	APBH_DEVSEL_CH6_OFFSET				12
+#define	APBH_DEVSEL_CH5_MASK				(0x3 << 10)
+#define	APBH_DEVSEL_CH5_OFFSET				10
+#define	APBH_DEVSEL_CH4_MASK				(0x3 << 8)
+#define	APBH_DEVSEL_CH4_OFFSET				8
+#define	APBH_DEVSEL_CH3_MASK				(0x3 << 6)
+#define	APBH_DEVSEL_CH3_OFFSET				6
+#define	APBH_DEVSEL_CH2_MASK				(0x3 << 4)
+#define	APBH_DEVSEL_CH2_OFFSET				4
+#define	APBH_DEVSEL_CH1_MASK				(0x3 << 2)
+#define	APBH_DEVSEL_CH1_OFFSET				2
+#define	APBH_DEVSEL_CH0_MASK				(0x3 << 0)
+#define	APBH_DEVSEL_CH0_OFFSET				0
+
+#define	APBH_DMA_BURST_SIZE_CH15_MASK			(0x3 << 30)
+#define	APBH_DMA_BURST_SIZE_CH15_OFFSET			30
+#define	APBH_DMA_BURST_SIZE_CH14_MASK			(0x3 << 28)
+#define	APBH_DMA_BURST_SIZE_CH14_OFFSET			28
+#define	APBH_DMA_BURST_SIZE_CH13_MASK			(0x3 << 26)
+#define	APBH_DMA_BURST_SIZE_CH13_OFFSET			26
+#define	APBH_DMA_BURST_SIZE_CH12_MASK			(0x3 << 24)
+#define	APBH_DMA_BURST_SIZE_CH12_OFFSET			24
+#define	APBH_DMA_BURST_SIZE_CH11_MASK			(0x3 << 22)
+#define	APBH_DMA_BURST_SIZE_CH11_OFFSET			22
+#define	APBH_DMA_BURST_SIZE_CH10_MASK			(0x3 << 20)
+#define	APBH_DMA_BURST_SIZE_CH10_OFFSET			20
+#define	APBH_DMA_BURST_SIZE_CH9_MASK			(0x3 << 18)
+#define	APBH_DMA_BURST_SIZE_CH9_OFFSET			18
+#define	APBH_DMA_BURST_SIZE_CH8_MASK			(0x3 << 16)
+#define	APBH_DMA_BURST_SIZE_CH8_OFFSET			16
+#define	APBH_DMA_BURST_SIZE_CH8_BURST0			(0x0 << 16)
+#define	APBH_DMA_BURST_SIZE_CH8_BURST4			(0x1 << 16)
+#define	APBH_DMA_BURST_SIZE_CH8_BURST8			(0x2 << 16)
+#define	APBH_DMA_BURST_SIZE_CH7_MASK			(0x3 << 14)
+#define	APBH_DMA_BURST_SIZE_CH7_OFFSET			14
+#define	APBH_DMA_BURST_SIZE_CH6_MASK			(0x3 << 12)
+#define	APBH_DMA_BURST_SIZE_CH6_OFFSET			12
+#define	APBH_DMA_BURST_SIZE_CH5_MASK			(0x3 << 10)
+#define	APBH_DMA_BURST_SIZE_CH5_OFFSET			10
+#define	APBH_DMA_BURST_SIZE_CH4_MASK			(0x3 << 8)
+#define	APBH_DMA_BURST_SIZE_CH4_OFFSET			8
+#define	APBH_DMA_BURST_SIZE_CH3_MASK			(0x3 << 6)
+#define	APBH_DMA_BURST_SIZE_CH3_OFFSET			6
+#define	APBH_DMA_BURST_SIZE_CH3_BURST0			(0x0 << 6)
+#define	APBH_DMA_BURST_SIZE_CH3_BURST4			(0x1 << 6)
+#define	APBH_DMA_BURST_SIZE_CH3_BURST8			(0x2 << 6)
+
+#define	APBH_DMA_BURST_SIZE_CH2_MASK			(0x3 << 4)
+#define	APBH_DMA_BURST_SIZE_CH2_OFFSET			4
+#define	APBH_DMA_BURST_SIZE_CH2_BURST0			(0x0 << 4)
+#define	APBH_DMA_BURST_SIZE_CH2_BURST4			(0x1 << 4)
+#define	APBH_DMA_BURST_SIZE_CH2_BURST8			(0x2 << 4)
+#define	APBH_DMA_BURST_SIZE_CH1_MASK			(0x3 << 2)
+#define	APBH_DMA_BURST_SIZE_CH1_OFFSET			2
+#define	APBH_DMA_BURST_SIZE_CH1_BURST0			(0x0 << 2)
+#define	APBH_DMA_BURST_SIZE_CH1_BURST4			(0x1 << 2)
+#define	APBH_DMA_BURST_SIZE_CH1_BURST8			(0x2 << 2)
+
+#define	APBH_DMA_BURST_SIZE_CH0_MASK			0x3
+#define	APBH_DMA_BURST_SIZE_CH0_OFFSET			0
+#define	APBH_DMA_BURST_SIZE_CH0_BURST0			0x0
+#define	APBH_DMA_BURST_SIZE_CH0_BURST4			0x1
+#define	APBH_DMA_BURST_SIZE_CH0_BURST8			0x2
+
+#define	APBH_DEBUG_GPMI_ONE_FIFO			(1 << 0)
+
+#define	APBH_CHn_CURCMDAR_CMD_ADDR_MASK			0xffffffff
+#define	APBH_CHn_CURCMDAR_CMD_ADDR_OFFSET		0
+
+#define	APBH_CHn_NXTCMDAR_CMD_ADDR_MASK			0xffffffff
+#define	APBH_CHn_NXTCMDAR_CMD_ADDR_OFFSET		0
+
+#define	APBH_CHn_CMD_XFER_COUNT_MASK			(0xffff << 16)
+#define	APBH_CHn_CMD_XFER_COUNT_OFFSET			16
+#define	APBH_CHn_CMD_CMDWORDS_MASK			(0xf << 12)
+#define	APBH_CHn_CMD_CMDWORDS_OFFSET			12
+#define	APBH_CHn_CMD_HALTONTERMINATE			(1 << 8)
+#define	APBH_CHn_CMD_WAIT4ENDCMD			(1 << 7)
+#define	APBH_CHn_CMD_SEMAPHORE				(1 << 6)
+#define	APBH_CHn_CMD_NANDWAIT4READY			(1 << 5)
+#define	APBH_CHn_CMD_NANDLOCK				(1 << 4)
+#define	APBH_CHn_CMD_IRQONCMPLT				(1 << 3)
+#define	APBH_CHn_CMD_CHAIN				(1 << 2)
+#define	APBH_CHn_CMD_COMMAND_MASK			0x3
+#define	APBH_CHn_CMD_COMMAND_OFFSET			0
+#define	APBH_CHn_CMD_COMMAND_NO_DMA_XFER		0x0
+#define	APBH_CHn_CMD_COMMAND_DMA_WRITE			0x1
+#define	APBH_CHn_CMD_COMMAND_DMA_READ			0x2
+#define	APBH_CHn_CMD_COMMAND_DMA_SENSE			0x3
+
+#define	APBH_CHn_BAR_ADDRESS_MASK			0xffffffff
+#define	APBH_CHn_BAR_ADDRESS_OFFSET			0
+
+#define	APBH_CHn_SEMA_RSVD2_MASK			(0xff << 24)
+#define	APBH_CHn_SEMA_RSVD2_OFFSET			24
+#define	APBH_CHn_SEMA_PHORE_MASK			(0xff << 16)
+#define	APBH_CHn_SEMA_PHORE_OFFSET			16
+#define	APBH_CHn_SEMA_RSVD1_MASK			(0xff << 8)
+#define	APBH_CHn_SEMA_RSVD1_OFFSET			8
+#define	APBH_CHn_SEMA_INCREMENT_SEMA_MASK		(0xff << 0)
+#define	APBH_CHn_SEMA_INCREMENT_SEMA_OFFSET		0
+
+#define	APBH_CHn_DEBUG1_REQ				(1 << 31)
+#define	APBH_CHn_DEBUG1_BURST				(1 << 30)
+#define	APBH_CHn_DEBUG1_KICK				(1 << 29)
+#define	APBH_CHn_DEBUG1_END				(1 << 28)
+#define	APBH_CHn_DEBUG1_SENSE				(1 << 27)
+#define	APBH_CHn_DEBUG1_READY				(1 << 26)
+#define	APBH_CHn_DEBUG1_LOCK				(1 << 25)
+#define	APBH_CHn_DEBUG1_NEXTCMDADDRVALID		(1 << 24)
+#define	APBH_CHn_DEBUG1_RD_FIFO_EMPTY			(1 << 23)
+#define	APBH_CHn_DEBUG1_RD_FIFO_FULL			(1 << 22)
+#define	APBH_CHn_DEBUG1_WR_FIFO_EMPTY			(1 << 21)
+#define	APBH_CHn_DEBUG1_WR_FIFO_FULL			(1 << 20)
+#define	APBH_CHn_DEBUG1_RSVD1_MASK			(0x7fff << 5)
+#define	APBH_CHn_DEBUG1_RSVD1_OFFSET			5
+#define	APBH_CHn_DEBUG1_STATEMACHINE_MASK		0x1f
+#define	APBH_CHn_DEBUG1_STATEMACHINE_OFFSET		0
+#define	APBH_CHn_DEBUG1_STATEMACHINE_IDLE		0x00
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD1		0x01
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD3		0x02
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD2		0x03
+#define	APBH_CHn_DEBUG1_STATEMACHINE_XFER_DECODE	0x04
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_WAIT		0x05
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD4		0x06
+#define	APBH_CHn_DEBUG1_STATEMACHINE_PIO_REQ		0x07
+#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_FLUSH		0x08
+#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_WAIT		0x09
+#define	APBH_CHn_DEBUG1_STATEMACHINE_WRITE		0x0c
+#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_REQ		0x0d
+#define	APBH_CHn_DEBUG1_STATEMACHINE_CHECK_CHAIN	0x0e
+#define	APBH_CHn_DEBUG1_STATEMACHINE_XFER_COMPLETE	0x0f
+#define	APBH_CHn_DEBUG1_STATEMACHINE_TERMINATE		0x14
+#define	APBH_CHn_DEBUG1_STATEMACHINE_WAIT_END		0x15
+#define	APBH_CHn_DEBUG1_STATEMACHINE_WRITE_WAIT		0x1c
+#define	APBH_CHn_DEBUG1_STATEMACHINE_HALT_AFTER_TERM	0x1d
+#define	APBH_CHn_DEBUG1_STATEMACHINE_CHECK_WAIT		0x1e
+#define	APBH_CHn_DEBUG1_STATEMACHINE_WAIT_READY		0x1f
+
+#define	APBH_CHn_DEBUG2_APB_BYTES_MASK			(0xffff << 16)
+#define	APBH_CHn_DEBUG2_APB_BYTES_OFFSET		16
+#define	APBH_CHn_DEBUG2_AHB_BYTES_MASK			0xffff
+#define	APBH_CHn_DEBUG2_AHB_BYTES_OFFSET		0
+
+#define	APBH_VERSION_MAJOR_MASK				(0xff << 24)
+#define	APBH_VERSION_MAJOR_OFFSET			24
+#define	APBH_VERSION_MINOR_MASK				(0xff << 16)
+#define	APBH_VERSION_MINOR_OFFSET			16
+#define	APBH_VERSION_STEP_MASK				0xffff
+#define	APBH_VERSION_STEP_OFFSET			0
+
+#endif	/* __REGS_APBH_H__ */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/regs-bch.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/regs-bch.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/regs-bch.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/regs-bch.h	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,230 @@
+/*
+ * Freescale i.MX28 BCH Register Definitions
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __MX28_REGS_BCH_H__
+#define __MX28_REGS_BCH_H__
+
+#include <mach/regs-common.h>
+
+#ifndef	__ASSEMBLY__
+struct mx28_bch_regs {
+	mx28_reg(hw_bch_ctrl)
+	mx28_reg(hw_bch_status0)
+	mx28_reg(hw_bch_mode)
+	mx28_reg(hw_bch_encodeptr)
+	mx28_reg(hw_bch_dataptr)
+	mx28_reg(hw_bch_metaptr)
+
+	uint32_t	reserved[4];
+
+	mx28_reg(hw_bch_layoutselect)
+	mx28_reg(hw_bch_flash0layout0)
+	mx28_reg(hw_bch_flash0layout1)
+	mx28_reg(hw_bch_flash1layout0)
+	mx28_reg(hw_bch_flash1layout1)
+	mx28_reg(hw_bch_flash2layout0)
+	mx28_reg(hw_bch_flash2layout1)
+	mx28_reg(hw_bch_flash3layout0)
+	mx28_reg(hw_bch_flash3layout1)
+	mx28_reg(hw_bch_dbgkesread)
+	mx28_reg(hw_bch_dbgcsferead)
+	mx28_reg(hw_bch_dbgsyndegread)
+	mx28_reg(hw_bch_dbgahbmread)
+	mx28_reg(hw_bch_blockname)
+	mx28_reg(hw_bch_version)
+};
+#endif
+
+#define	BCH_CTRL_SFTRST					(1 << 31)
+#define	BCH_CTRL_CLKGATE				(1 << 30)
+#define	BCH_CTRL_DEBUGSYNDROME				(1 << 22)
+#define	BCH_CTRL_M2M_LAYOUT_MASK			(0x3 << 18)
+#define	BCH_CTRL_M2M_LAYOUT_OFFSET			18
+#define	BCH_CTRL_M2M_ENCODE				(1 << 17)
+#define	BCH_CTRL_M2M_ENABLE				(1 << 16)
+#define	BCH_CTRL_DEBUG_STALL_IRQ_EN			(1 << 10)
+#define	BCH_CTRL_COMPLETE_IRQ_EN			(1 << 8)
+#define	BCH_CTRL_BM_ERROR_IRQ				(1 << 3)
+#define	BCH_CTRL_DEBUG_STALL_IRQ			(1 << 2)
+#define	BCH_CTRL_COMPLETE_IRQ				(1 << 0)
+
+#define	BCH_STATUS0_HANDLE_MASK				(0xfff << 20)
+#define	BCH_STATUS0_HANDLE_OFFSET			20
+#define	BCH_STATUS0_COMPLETED_CE_MASK			(0xf << 16)
+#define	BCH_STATUS0_COMPLETED_CE_OFFSET			16
+#define	BCH_STATUS0_STATUS_BLK0_MASK			(0xff << 8)
+#define	BCH_STATUS0_STATUS_BLK0_OFFSET			8
+#define	BCH_STATUS0_STATUS_BLK0_ZERO			(0x00 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERROR1			(0x01 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERROR2			(0x02 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERROR3			(0x03 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERROR4			(0x04 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_UNCORRECTABLE		(0xfe << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERASED			(0xff << 8)
+#define	BCH_STATUS0_ALLONES				(1 << 4)
+#define	BCH_STATUS0_CORRECTED				(1 << 3)
+#define	BCH_STATUS0_UNCORRECTABLE			(1 << 2)
+
+#define	BCH_MODE_ERASE_THRESHOLD_MASK			0xff
+#define	BCH_MODE_ERASE_THRESHOLD_OFFSET			0
+
+#define	BCH_ENCODEPTR_ADDR_MASK				0xffffffff
+#define	BCH_ENCODEPTR_ADDR_OFFSET			0
+
+#define	BCH_DATAPTR_ADDR_MASK				0xffffffff
+#define	BCH_DATAPTR_ADDR_OFFSET				0
+
+#define	BCH_METAPTR_ADDR_MASK				0xffffffff
+#define	BCH_METAPTR_ADDR_OFFSET				0
+
+#define	BCH_LAYOUTSELECT_CS15_SELECT_MASK		(0x3 << 30)
+#define	BCH_LAYOUTSELECT_CS15_SELECT_OFFSET		30
+#define	BCH_LAYOUTSELECT_CS14_SELECT_MASK		(0x3 << 28)
+#define	BCH_LAYOUTSELECT_CS14_SELECT_OFFSET		28
+#define	BCH_LAYOUTSELECT_CS13_SELECT_MASK		(0x3 << 26)
+#define	BCH_LAYOUTSELECT_CS13_SELECT_OFFSET		26
+#define	BCH_LAYOUTSELECT_CS12_SELECT_MASK		(0x3 << 24)
+#define	BCH_LAYOUTSELECT_CS12_SELECT_OFFSET		24
+#define	BCH_LAYOUTSELECT_CS11_SELECT_MASK		(0x3 << 22)
+#define	BCH_LAYOUTSELECT_CS11_SELECT_OFFSET		22
+#define	BCH_LAYOUTSELECT_CS10_SELECT_MASK		(0x3 << 20)
+#define	BCH_LAYOUTSELECT_CS10_SELECT_OFFSET		20
+#define	BCH_LAYOUTSELECT_CS9_SELECT_MASK		(0x3 << 18)
+#define	BCH_LAYOUTSELECT_CS9_SELECT_OFFSET		18
+#define	BCH_LAYOUTSELECT_CS8_SELECT_MASK		(0x3 << 16)
+#define	BCH_LAYOUTSELECT_CS8_SELECT_OFFSET		16
+#define	BCH_LAYOUTSELECT_CS7_SELECT_MASK		(0x3 << 14)
+#define	BCH_LAYOUTSELECT_CS7_SELECT_OFFSET		14
+#define	BCH_LAYOUTSELECT_CS6_SELECT_MASK		(0x3 << 12)
+#define	BCH_LAYOUTSELECT_CS6_SELECT_OFFSET		12
+#define	BCH_LAYOUTSELECT_CS5_SELECT_MASK		(0x3 << 10)
+#define	BCH_LAYOUTSELECT_CS5_SELECT_OFFSET		10
+#define	BCH_LAYOUTSELECT_CS4_SELECT_MASK		(0x3 << 8)
+#define	BCH_LAYOUTSELECT_CS4_SELECT_OFFSET		8
+#define	BCH_LAYOUTSELECT_CS3_SELECT_MASK		(0x3 << 6)
+#define	BCH_LAYOUTSELECT_CS3_SELECT_OFFSET		6
+#define	BCH_LAYOUTSELECT_CS2_SELECT_MASK		(0x3 << 4)
+#define	BCH_LAYOUTSELECT_CS2_SELECT_OFFSET		4
+#define	BCH_LAYOUTSELECT_CS1_SELECT_MASK		(0x3 << 2)
+#define	BCH_LAYOUTSELECT_CS1_SELECT_OFFSET		2
+#define	BCH_LAYOUTSELECT_CS0_SELECT_MASK		(0x3 << 0)
+#define	BCH_LAYOUTSELECT_CS0_SELECT_OFFSET		0
+
+#define	BCH_FLASHLAYOUT0_NBLOCKS_MASK			(0xff << 24)
+#define	BCH_FLASHLAYOUT0_NBLOCKS_OFFSET			24
+#define	BCH_FLASHLAYOUT0_META_SIZE_MASK			(0xff << 16)
+#define	BCH_FLASHLAYOUT0_META_SIZE_OFFSET		16
+#define	BCH_FLASHLAYOUT0_ECC0_MASK			(0xf << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_OFFSET			12
+#define	BCH_FLASHLAYOUT0_ECC0_NONE			(0x0 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC2			(0x1 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC4			(0x2 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC6			(0x3 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC8			(0x4 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC10			(0x5 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC12			(0x6 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC14			(0x7 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC16			(0x8 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC18			(0x9 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC20			(0xa << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC22			(0xb << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC24			(0xc << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC26			(0xd << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC28			(0xe << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC30			(0xf << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC32			(0x10 << 12)
+#define	BCH_FLASHLAYOUT0_GF13_0_GF14_1			(1 << 10)
+#define	BCH_FLASHLAYOUT0_DATA0_SIZE_MASK		0xfff
+#define	BCH_FLASHLAYOUT0_DATA0_SIZE_OFFSET		0
+
+#define	BCH_FLASHLAYOUT1_PAGE_SIZE_MASK			(0xffff << 16)
+#define	BCH_FLASHLAYOUT1_PAGE_SIZE_OFFSET		16
+#define	BCH_FLASHLAYOUT1_ECCN_MASK			(0xf << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_OFFSET			12
+#define	BCH_FLASHLAYOUT1_ECCN_NONE			(0x0 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC2			(0x1 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC4			(0x2 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC6			(0x3 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC8			(0x4 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC10			(0x5 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC12			(0x6 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC14			(0x7 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC16			(0x8 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC18			(0x9 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC20			(0xa << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC22			(0xb << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC24			(0xc << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC26			(0xd << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC28			(0xe << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC30			(0xf << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC32			(0x10 << 12)
+#define	BCH_FLASHLAYOUT1_GF13_0_GF14_1			(1 << 10)
+#define	BCH_FLASHLAYOUT1_DATAN_SIZE_MASK		0xfff
+#define	BCH_FLASHLAYOUT1_DATAN_SIZE_OFFSET		0
+
+#define	BCH_DEBUG0_RSVD1_MASK				(0x1f << 27)
+#define	BCH_DEBUG0_RSVD1_OFFSET				27
+#define	BCH_DEBUG0_ROM_BIST_ENABLE			(1 << 26)
+#define	BCH_DEBUG0_ROM_BIST_COMPLETE			(1 << 25)
+#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_MASK	(0x1ff << 16)
+#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_OFFSET	16
+#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_NORMAL	(0x0 << 16)
+#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_TEST_MODE	(0x1 << 16)
+#define	BCH_DEBUG0_KES_DEBUG_SHIFT_SYND			(1 << 15)
+#define	BCH_DEBUG0_KES_DEBUG_PAYLOAD_FLAG		(1 << 14)
+#define	BCH_DEBUG0_KES_DEBUG_MODE4K			(1 << 13)
+#define	BCH_DEBUG0_KES_DEBUG_KICK			(1 << 12)
+#define	BCH_DEBUG0_KES_STANDALONE			(1 << 11)
+#define	BCH_DEBUG0_KES_DEBUG_STEP			(1 << 10)
+#define	BCH_DEBUG0_KES_DEBUG_STALL			(1 << 9)
+#define	BCH_DEBUG0_BM_KES_TEST_BYPASS			(1 << 8)
+#define	BCH_DEBUG0_RSVD0_MASK				(0x3 << 6)
+#define	BCH_DEBUG0_RSVD0_OFFSET				6
+#define	BCH_DEBUG0_DEBUG_REG_SELECT_MASK		0x3f
+#define	BCH_DEBUG0_DEBUG_REG_SELECT_OFFSET		0
+
+#define	BCH_DBGKESREAD_VALUES_MASK			0xffffffff
+#define	BCH_DBGKESREAD_VALUES_OFFSET			0
+
+#define	BCH_DBGCSFEREAD_VALUES_MASK			0xffffffff
+#define	BCH_DBGCSFEREAD_VALUES_OFFSET			0
+
+#define	BCH_DBGSYNDGENREAD_VALUES_MASK			0xffffffff
+#define	BCH_DBGSYNDGENREAD_VALUES_OFFSET		0
+
+#define	BCH_DBGAHBMREAD_VALUES_MASK			0xffffffff
+#define	BCH_DBGAHBMREAD_VALUES_OFFSET			0
+
+#define	BCH_BLOCKNAME_NAME_MASK				0xffffffff
+#define	BCH_BLOCKNAME_NAME_OFFSET			0
+
+#define	BCH_VERSION_MAJOR_MASK				(0xff << 24)
+#define	BCH_VERSION_MAJOR_OFFSET			24
+#define	BCH_VERSION_MINOR_MASK				(0xff << 16)
+#define	BCH_VERSION_MINOR_OFFSET			16
+#define	BCH_VERSION_STEP_MASK				0xffff
+#define	BCH_VERSION_STEP_OFFSET				0
+
+#endif	/* __MX28_REGS_BCH_H__ */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/regs-common.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/regs-common.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/regs-common.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/regs-common.h	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,66 @@
+/*
+ * Freescale i.MX28 Register Accessors
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __MX28_REGS_COMMON_H__
+#define __MX28_REGS_COMMON_H__
+
+/*
+ * The i.MX28 has interesting feature when it comes to register access. There
+ * are four kinds of access to one particular register. Those are:
+ *
+ * 1) Common read/write access. To use this mode, just write to the address of
+ *    the register.
+ * 2) Set bits only access. To set bits, write which bits you want to set to the
+ *    address of the register + 0x4.
+ * 3) Clear bits only access. To clear bits, write which bits you want to clear
+ *    to the address of the register + 0x8.
+ * 4) Toggle bits only access. To toggle bits, write which bits you want to
+ *    toggle to the address of the register + 0xc.
+ *
+ * IMPORTANT NOTE: Not all registers support accesses 2-4! Also, not all bits
+ * can be set/cleared by pure write as in access type 1, some need to be
+ * explicitly set/cleared by using access type 2-3.
+ *
+ * The following macros and structures allow the user to either access the
+ * register in all aforementioned modes (by accessing reg_name, reg_name_set,
+ * reg_name_clr, reg_name_tog) or pass the register structure further into
+ * various functions with correct type information (by accessing reg_name_reg).
+ *
+ */
+
+#define	__mx28_reg(name)		\
+	uint32_t name;			\
+	uint32_t name##_set;		\
+	uint32_t name##_clr;		\
+	uint32_t name##_tog;
+
+struct mx28_register {
+	__mx28_reg(reg)
+};
+
+#define	mx28_reg(name)					\
+	union {						\
+		struct { __mx28_reg(name) };		\
+		struct mx28_register name##_reg;	\
+	};
+
+#endif	/* __MX28_REGS_COMMON_H__ */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/regs-gpmi.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/regs-gpmi.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/regs-gpmi.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/regs-gpmi.h	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,222 @@
+/*
+ * Freescale i.MX28 GPMI Register Definitions
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __MX28_REGS_GPMI_H__
+#define __MX28_REGS_GPMI_H__
+
+#include <mach/regs-common.h>
+
+#ifndef	__ASSEMBLY__
+struct mx28_gpmi_regs {
+	mx28_reg(hw_gpmi_ctrl0)
+	mx28_reg(hw_gpmi_compare)
+	mx28_reg(hw_gpmi_eccctrl)
+	mx28_reg(hw_gpmi_ecccount)
+	mx28_reg(hw_gpmi_payload)
+	mx28_reg(hw_gpmi_auxiliary)
+	mx28_reg(hw_gpmi_ctrl1)
+	mx28_reg(hw_gpmi_timing0)
+	mx28_reg(hw_gpmi_timing1)
+
+	uint32_t	reserved[4];
+
+	mx28_reg(hw_gpmi_data)
+	mx28_reg(hw_gpmi_stat)
+	mx28_reg(hw_gpmi_debug)
+	mx28_reg(hw_gpmi_version)
+};
+#endif
+
+#define	GPMI_CTRL0_SFTRST				(1 << 31)
+#define	GPMI_CTRL0_CLKGATE				(1 << 30)
+#define	GPMI_CTRL0_RUN					(1 << 29)
+#define	GPMI_CTRL0_DEV_IRQ_EN				(1 << 28)
+#define	GPMI_CTRL0_LOCK_CS				(1 << 27)
+#define	GPMI_CTRL0_UDMA					(1 << 26)
+#define	GPMI_CTRL0_COMMAND_MODE_MASK			(0x3 << 24)
+#define	GPMI_CTRL0_COMMAND_MODE_OFFSET			24
+#define	GPMI_CTRL0_COMMAND_MODE_WRITE			(0x0 << 24)
+#define	GPMI_CTRL0_COMMAND_MODE_READ			(0x1 << 24)
+#define	GPMI_CTRL0_COMMAND_MODE_READ_AND_COMPARE	(0x2 << 24)
+#define	GPMI_CTRL0_COMMAND_MODE_WAIT_FOR_READY		(0x3 << 24)
+#define	GPMI_CTRL0_WORD_LENGTH				(1 << 23)
+#define	GPMI_CTRL0_CS_MASK				(0x7 << 20)
+#define	GPMI_CTRL0_CS_OFFSET				20
+#define	GPMI_CTRL0_ADDRESS_MASK				(0x7 << 17)
+#define	GPMI_CTRL0_ADDRESS_OFFSET			17
+#define	GPMI_CTRL0_ADDRESS_NAND_DATA			(0x0 << 17)
+#define	GPMI_CTRL0_ADDRESS_NAND_CLE			(0x1 << 17)
+#define	GPMI_CTRL0_ADDRESS_NAND_ALE			(0x2 << 17)
+#define	GPMI_CTRL0_ADDRESS_INCREMENT			(1 << 16)
+#define	GPMI_CTRL0_XFER_COUNT_MASK			0xffff
+#define	GPMI_CTRL0_XFER_COUNT_OFFSET			0
+
+#define	GPMI_COMPARE_MASK_MASK				(0xffff << 16)
+#define	GPMI_COMPARE_MASK_OFFSET			16
+#define	GPMI_COMPARE_REFERENCE_MASK			0xffff
+#define	GPMI_COMPARE_REFERENCE_OFFSET			0
+
+#define	GPMI_ECCCTRL_HANDLE_MASK			(0xffff << 16)
+#define	GPMI_ECCCTRL_HANDLE_OFFSET			16
+#define	GPMI_ECCCTRL_ECC_CMD_MASK			(0x3 << 13)
+#define	GPMI_ECCCTRL_ECC_CMD_OFFSET			13
+#define	GPMI_ECCCTRL_ECC_CMD_DECODE			(0x0 << 13)
+#define	GPMI_ECCCTRL_ECC_CMD_ENCODE			(0x1 << 13)
+#define	GPMI_ECCCTRL_ENABLE_ECC				(1 << 12)
+#define	GPMI_ECCCTRL_BUFFER_MASK_MASK			0x1ff
+#define	GPMI_ECCCTRL_BUFFER_MASK_OFFSET			0
+#define	GPMI_ECCCTRL_BUFFER_MASK_BCH_AUXONLY		0x100
+#define	GPMI_ECCCTRL_BUFFER_MASK_BCH_PAGE		0x1ff
+
+#define	GPMI_ECCCOUNT_COUNT_MASK			0xffff
+#define	GPMI_ECCCOUNT_COUNT_OFFSET			0
+
+#define	GPMI_PAYLOAD_ADDRESS_MASK			(0x3fffffff << 2)
+#define	GPMI_PAYLOAD_ADDRESS_OFFSET			2
+
+#define	GPMI_AUXILIARY_ADDRESS_MASK			(0x3fffffff << 2)
+#define	GPMI_AUXILIARY_ADDRESS_OFFSET			2
+
+#define	GPMI_CTRL1_DECOUPLE_CS				(1 << 24)
+#define	GPMI_CTRL1_WRN_DLY_SEL_MASK			(0x3 << 22)
+#define	GPMI_CTRL1_WRN_DLY_SEL_OFFSET			22
+#define	GPMI_CTRL1_TIMEOUT_IRQ_EN			(1 << 20)
+#define	GPMI_CTRL1_GANGED_RDYBUSY			(1 << 19)
+#define	GPMI_CTRL1_BCH_MODE				(1 << 18)
+#define	GPMI_CTRL1_DLL_ENABLE				(1 << 17)
+#define	GPMI_CTRL1_HALF_PERIOD				(1 << 16)
+#define	GPMI_CTRL1_RDN_DELAY_MASK			(0xf << 12)
+#define	GPMI_CTRL1_RDN_DELAY_OFFSET			12
+#define	GPMI_CTRL1_DMA2ECC_MODE				(1 << 11)
+#define	GPMI_CTRL1_DEV_IRQ				(1 << 10)
+#define	GPMI_CTRL1_TIMEOUT_IRQ				(1 << 9)
+#define	GPMI_CTRL1_BURST_EN				(1 << 8)
+#define	GPMI_CTRL1_ABORT_WAIT_REQUEST			(1 << 7)
+#define	GPMI_CTRL1_ABORT_WAIT_FOR_READY_CHANNEL_MASK	(0x7 << 4)
+#define	GPMI_CTRL1_ABORT_WAIT_FOR_READY_CHANNEL_OFFSET	4
+#define	GPMI_CTRL1_DEV_RESET				(1 << 3)
+#define	GPMI_CTRL1_ATA_IRQRDY_POLARITY			(1 << 2)
+#define	GPMI_CTRL1_CAMERA_MODE				(1 << 1)
+#define	GPMI_CTRL1_GPMI_MODE				(1 << 0)
+
+#define	GPMI_TIMING0_ADDRESS_SETUP_MASK			(0xff << 16)
+#define	GPMI_TIMING0_ADDRESS_SETUP_OFFSET		16
+#define	GPMI_TIMING0_DATA_HOLD_MASK			(0xff << 8)
+#define	GPMI_TIMING0_DATA_HOLD_OFFSET			8
+#define	GPMI_TIMING0_DATA_SETUP_MASK			0xff
+#define	GPMI_TIMING0_DATA_SETUP_OFFSET			0
+
+#define	GPMI_TIMING1_DEVICE_BUSY_TIMEOUT_MASK		(0xffff << 16)
+#define	GPMI_TIMING1_DEVICE_BUSY_TIMEOUT_OFFSET		16
+
+#define	GPMI_TIMING2_UDMA_TRP_MASK			(0xff << 24)
+#define	GPMI_TIMING2_UDMA_TRP_OFFSET			24
+#define	GPMI_TIMING2_UDMA_ENV_MASK			(0xff << 16)
+#define	GPMI_TIMING2_UDMA_ENV_OFFSET			16
+#define	GPMI_TIMING2_UDMA_HOLD_MASK			(0xff << 8)
+#define	GPMI_TIMING2_UDMA_HOLD_OFFSET			8
+#define	GPMI_TIMING2_UDMA_SETUP_MASK			0xff
+#define	GPMI_TIMING2_UDMA_SETUP_OFFSET			0
+
+#define	GPMI_DATA_DATA_MASK				0xffffffff
+#define	GPMI_DATA_DATA_OFFSET				0
+
+#define	GPMI_STAT_READY_BUSY_MASK			(0xff << 24)
+#define	GPMI_STAT_READY_BUSY_OFFSET			24
+#define	GPMI_STAT_RDY_TIMEOUT_MASK			(0xff << 16)
+#define	GPMI_STAT_RDY_TIMEOUT_OFFSET			16
+#define	GPMI_STAT_DEV7_ERROR				(1 << 15)
+#define	GPMI_STAT_DEV6_ERROR				(1 << 14)
+#define	GPMI_STAT_DEV5_ERROR				(1 << 13)
+#define	GPMI_STAT_DEV4_ERROR				(1 << 12)
+#define	GPMI_STAT_DEV3_ERROR				(1 << 11)
+#define	GPMI_STAT_DEV2_ERROR				(1 << 10)
+#define	GPMI_STAT_DEV1_ERROR				(1 << 9)
+#define	GPMI_STAT_DEV0_ERROR				(1 << 8)
+#define	GPMI_STAT_ATA_IRQ				(1 << 4)
+#define	GPMI_STAT_INVALID_BUFFER_MASK			(1 << 3)
+#define	GPMI_STAT_FIFO_EMPTY				(1 << 2)
+#define	GPMI_STAT_FIFO_FULL				(1 << 1)
+#define	GPMI_STAT_PRESENT				(1 << 0)
+
+#define	GPMI_DEBUG_WAIT_FOR_READY_END_MASK		(0xff << 24)
+#define	GPMI_DEBUG_WAIT_FOR_READY_END_OFFSET		24
+#define	GPMI_DEBUG_DMA_SENSE_MASK			(0xff << 16)
+#define	GPMI_DEBUG_DMA_SENSE_OFFSET			16
+#define	GPMI_DEBUG_DMAREQ_MASK				(0xff << 8)
+#define	GPMI_DEBUG_DMAREQ_OFFSET			8
+#define	GPMI_DEBUG_CMD_END_MASK				0xff
+#define	GPMI_DEBUG_CMD_END_OFFSET			0
+
+#define	GPMI_VERSION_MAJOR_MASK				(0xff << 24)
+#define	GPMI_VERSION_MAJOR_OFFSET			24
+#define	GPMI_VERSION_MINOR_MASK				(0xff << 16)
+#define	GPMI_VERSION_MINOR_OFFSET			16
+#define	GPMI_VERSION_STEP_MASK				0xffff
+#define	GPMI_VERSION_STEP_OFFSET			0
+
+#define	GPMI_DEBUG2_UDMA_STATE_MASK			(0xf << 24)
+#define	GPMI_DEBUG2_UDMA_STATE_OFFSET			24
+#define	GPMI_DEBUG2_BUSY				(1 << 23)
+#define	GPMI_DEBUG2_PIN_STATE_MASK			(0x7 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_OFFSET			20
+#define	GPMI_DEBUG2_PIN_STATE_PSM_IDLE			(0x0 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_BYTCNT		(0x1 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_ADDR			(0x2 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_STALL			(0x3 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_STROBE		(0x4 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_ATARDY		(0x5 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_DHOLD			(0x6 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_DONE			(0x7 << 20)
+#define	GPMI_DEBUG2_MAIN_STATE_MASK			(0xf << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_OFFSET			16
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_IDLE			(0x0 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_BYTCNT		(0x1 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFE		(0x2 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFR		(0x3 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_DMAREQ		(0x4 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_DMAACK		(0x5 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFF		(0x6 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_LDFIFO		(0x7 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_LDDMAR		(0x8 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_RDCMP		(0x9 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_DONE			(0xa << 16)
+#define	GPMI_DEBUG2_SYND2GPMI_BE_MASK			(0xf << 12)
+#define	GPMI_DEBUG2_SYND2GPMI_BE_OFFSET			12
+#define	GPMI_DEBUG2_GPMI2SYND_VALID			(1 << 11)
+#define	GPMI_DEBUG2_GPMI2SYND_READY			(1 << 10)
+#define	GPMI_DEBUG2_SYND2GPMI_VALID			(1 << 9)
+#define	GPMI_DEBUG2_SYND2GPMI_READY			(1 << 8)
+#define	GPMI_DEBUG2_VIEW_DELAYED_RDN			(1 << 7)
+#define	GPMI_DEBUG2_UPDATE_WINDOW			(1 << 6)
+#define	GPMI_DEBUG2_RDN_TAP_MASK			0x3f
+#define	GPMI_DEBUG2_RDN_TAP_OFFSET			0
+
+#define	GPMI_DEBUG3_APB_WORD_CNTR_MASK			(0xffff << 16)
+#define	GPMI_DEBUG3_APB_WORD_CNTR_OFFSET		16
+#define	GPMI_DEBUG3_DEV_WORD_CNTR_MASK			0xffff
+#define	GPMI_DEBUG3_DEV_WORD_CNTR_OFFSET		0
+
+#endif	/* __MX28_REGS_GPMI_H__ */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/include/mach/watchdog.h barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/watchdog.h
--- barebox-2012.02.0/arch/arm/mach-mxs/include/mach/watchdog.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/include/mach/watchdog.h	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,24 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_BAREBOX_ARCH_ARM_MACH_MXS_MACH_WATCHDOG_H
+#define H_BAREBOX_ARCH_ARM_MACH_MXS_MACH_WATCHDOG_H
+
+void watchdog_prepare(void);
+int watchdog_off(void);
+int watchdog_trigger(unsigned long tm_ms);
+
+#endif	/* H_BAREBOX_ARCH_ARM_MACH_MXS_MACH_WATCHDOG_H */
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/Kconfig barebox-2012.02.0-ccu2/arch/arm/mach-mxs/Kconfig
--- barebox-2012.02.0/arch/arm/mach-mxs/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/Kconfig	2013-01-14 12:46:28.000000000 +0100
@@ -10,6 +10,7 @@
 config BOARDINFO
 	default "Freescale i.MX23-EVK" if MACH_MX23EVK
 	default "Chumby Falconwing" if MACH_CHUMBY
+	default "EQ3 CCU2" if MACH_EQ3_CCU2
 	default "Karo TX28" if MACH_TX28
 	default "Freescale i.MX28-EVK" if MACH_MX28EVK
 
@@ -51,6 +52,19 @@
 
 if ARCH_IMX28
 
+config MX28_DMA
+        bool
+
+config APBH_DMA_BURST8
+        bool "Enable AHB 8 beat bursts"
+	depends on MX28_DMA
+	default y
+
+config APBH_DMA_BURST
+        bool "Enable AHB bursts"
+	depends on MX28_DMA
+	default y
+
 choice
 	prompt "i.MX28 Board Type"
 
@@ -59,6 +73,11 @@
 	help
 	  Say Y here if you are using the KARO TX28 CPU module.
 
+config MACH_EQ3_CCU2
+	bool "EQ3 CCU2"
+	help
+	  Say Y here if you are using the EQ3 CCU2 CPU module.
+
 config MACH_MX28EVK
 	bool "mx28-evk"
 	help
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/Makefile barebox-2012.02.0-ccu2/arch/arm/mach-mxs/Makefile
--- barebox-2012.02.0/arch/arm/mach-mxs/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/Makefile	2013-01-14 12:46:28.000000000 +0100
@@ -1,4 +1,5 @@
 obj-y += imx.o iomux-imx.o reset-imx.o
 obj-$(CONFIG_DRIVER_VIDEO_STM) += imx_lcd_clk.o
 obj-$(CONFIG_ARCH_IMX23) += speed-imx23.o clocksource-imx23.o usb.o
-obj-$(CONFIG_ARCH_IMX28) += speed-imx28.o clocksource-imx28.o
+obj-$(CONFIG_ARCH_IMX28) += speed-imx28.o clocksource-imx28.o system-imx28.o
+obj-$(CONFIG_MX28_DMA) += dma-imx28.o
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/reset-imx.c barebox-2012.02.0-ccu2/arch/arm/mach-mxs/reset-imx.c
--- barebox-2012.02.0/arch/arm/mach-mxs/reset-imx.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/reset-imx.c	2013-01-14 12:46:28.000000000 +0100
@@ -23,6 +23,8 @@
 #include <mach/imx-regs.h>
 #include <io.h>
 
+#include <mach/watchdog.h>
+
 #define HW_RTC_CTRL     0x000
 # define BM_RTC_CTRL_WATCHDOGEN (1 << 4)
 #define HW_RTC_CTRL_SET 0x004
@@ -38,10 +40,50 @@
 
 #define HW_RTC_PERSISTENT1     0x070
 # define BV_RTC_PERSISTENT1_GENERAL__RTC_FORCE_UPDATER 0x80000000
+# define BV_RTC_PERSISTENT1_GENERAL__WDOG_ERROR        0x40000000
 #define HW_RTC_PERSISTENT1_SET 0x074
 #define HW_RTC_PERSISTENT1_CLR 0x078
 #define HW_RTC_PERSISTENT1_TOG 0x07C
 
+#define HW_RTC_PERSISTENT2     0x080
+
+volatile unsigned int	watchdog_magic     = 0x0;
+volatile unsigned int	watchdog_magic_rev = ~0x0u + 1;
+
+void watchdog_prepare(void)
+{
+	--watchdog_magic_rev;
+}
+
+int watchdog_off(void)
+{
+	if ((watchdog_magic ^ watchdog_magic_rev) != ~0u) {
+		writel(BV_RTC_PERSISTENT1_GENERAL__WDOG_ERROR,
+		       IMX_WDT_BASE + HW_RTC_PERSISTENT1 + 0x04);
+		reset_cpu(0);
+	}
+
+	++watchdog_magic;
+	writel(BM_RTC_CTRL_WATCHDOGEN, IMX_WDT_BASE + HW_RTC_CTRL_CLR);
+
+	return 0;
+}
+
+int watchdog_trigger(unsigned long tm_ms)
+{
+	if ((watchdog_magic ^ watchdog_magic_rev) != ~0u) {
+		writel(BV_RTC_PERSISTENT1_GENERAL__WDOG_ERROR,
+		       IMX_WDT_BASE + HW_RTC_PERSISTENT1 + 0x04);
+		reset_cpu(0);
+	}
+
+	++watchdog_magic;
+	writel(tm_ms, IMX_WDT_BASE + HW_RTC_WATCHDOG);
+	writel(BM_RTC_CTRL_WATCHDOGEN, IMX_WDT_BASE + HW_RTC_CTRL_SET);
+
+	return 0;
+}
+
 /*
  * Reset the cpu by setting up the watchdog timer and let it time out
  *
@@ -50,9 +92,8 @@
  */
 void __noreturn reset_cpu (unsigned long addr)
 {
-	writel(WDOG_COUNTER_RATE, IMX_WDT_BASE + HW_RTC_WATCHDOG);
-	writel(BM_RTC_CTRL_WATCHDOGEN, IMX_WDT_BASE + HW_RTC_CTRL_SET);
-	writel(BV_RTC_PERSISTENT1_GENERAL__RTC_FORCE_UPDATER, IMX_WDT_BASE + HW_RTC_PERSISTENT1);
+	/* HW_CLKCTRL_RESET */
+	writel(1<<1, IMX_CCM_BASE + 0x01e0 + BIT_SET);
 
 	while (1)
 		;
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/speed-imx28.c barebox-2012.02.0-ccu2/arch/arm/mach-mxs/speed-imx28.c
--- barebox-2012.02.0/arch/arm/mach-mxs/speed-imx28.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/speed-imx28.c	2013-01-14 12:46:28.000000000 +0100
@@ -48,6 +48,12 @@
 # define GET_SSP_DIV(x) ((x) & CLKCTRL_SSP_DIV_MASK)
 # define SET_SSP_DIV(x) ((x) & CLKCTRL_SSP_DIV_MASK)
 #define HW_CLKCTRL_GPMI 0x0d0
+# define CLKCTRL_GPMI_CLKGATE (1u << 31)
+# define CLKCTRL_GPMI_BUSY (1u << 29)
+# define CLKCTRL_GPMI_DIV_FRAC_EN (1u << 10)
+# define CLKCTRL_GPMI_DIV_MASK (0x3ff << 0)
+# define GET_GPMI_DIV(x) ((x) & 0x3ff)
+
 /* note: no set/clear register! */
 #define HW_CLKCTRL_SPDIF 0x0e0
 /* note: no set/clear register! */
@@ -257,6 +263,31 @@
 	return rate * 1000;
 }
 
+unsigned int imx_set_hclk(unsigned int rate)
+{
+	unsigned int	base_rate = imx_get_armclk();
+	unsigned int	div;
+	unsigned int	v;
+
+	if (WARN_ON(rate < base_rate / 0x1f) ||
+	    WARN_ON(rate > base_rate))
+		return imx_get_hclk();
+
+	div = (base_rate + rate - 1) / rate;
+	while (readl(IMX_CCM_BASE + HW_CLKCTRL_HBUS) & (1u << 31))
+		;			/* noop */
+
+	v = readl(IMX_CCM_BASE + HW_CLKCTRL_HBUS);
+	v &= ~((1u << 5) | (0x1f << 0));
+	v |= div;
+
+	writel(v, IMX_CCM_BASE + HW_CLKCTRL_HBUS);
+	while (readl(IMX_CCM_BASE + HW_CLKCTRL_HBUS) & (1u << 31))
+		;			/* noop */
+
+	return imx_get_hclk();
+}
+
 /*
  * Source of UART, debug UART, audio, PWM, dri, timer, digctl
  */
@@ -376,6 +407,93 @@
 		IMX_CCM_BASE + HW_CLKCTRL_ENET);
 }
 
+unsigned int imx_get_gpmiclk(void)
+{
+	unsigned int	clkctl = readl(IMX_CCM_BASE + HW_CLKCTRL_GPMI);
+	unsigned int	clkseq = readl(IMX_CCM_BASE + HW_CLKCTRL_CLKSEQ);
+	unsigned int	base_clk;
+
+	if (clkctl & CLKCTRL_GPMI_CLKGATE)
+		return 0;		/* clk disabled */
+
+	if (clkctl & CLKCTRL_GPMI_DIV_FRAC_EN) {
+		printk(KERN_WARNING
+		       "GPMI div-frac interpretation not implemented yet: %08x\n",
+		       clkctl);
+		return 0;
+	}
+
+	if (clkseq & CLKCTRL_CLKSEQ_BYPASS_GPMI)
+		base_clk = imx_get_xtalclk();
+	else
+		base_clk = imx_get_ioclk(0);
+
+	return base_clk / GET_GPMI_DIV(clkctl);
+}
+
+unsigned int imx_set_gpmiclk(unsigned int nc, int use_ioclk)
+{
+	unsigned int	clkctrl;
+
+	do {
+		clkctrl = readl(IMX_CCM_BASE + HW_CLKCTRL_GPMI);
+	} while ((clkctrl & (CLKCTRL_GPMI_BUSY|CLKCTRL_GPMI_CLKGATE))
+		 == CLKCTRL_GPMI_BUSY);
+
+	if (nc == 0)
+		writel(clkctrl | CLKCTRL_GPMI_CLKGATE,
+		       IMX_CCM_BASE + HW_CLKCTRL_GPMI);
+	else {
+		unsigned int	div;
+		unsigned int	base_clk;
+		unsigned int	seq_offs;
+
+		clkctrl &= ~(CLKCTRL_GPMI_DIV_FRAC_EN |
+			     CLKCTRL_GPMI_DIV_MASK);
+
+		if (use_ioclk) {
+			base_clk = imx_get_ioclk(0);
+			seq_offs = BIT_CLR;
+		} else {
+			base_clk = imx_get_xtalclk();
+			seq_offs = BIT_SET;
+		}
+
+		if (WARN_ON(base_clk == 0))
+			return 0;
+
+		div = (base_clk + nc - 1) / nc;
+		if (div == 0)
+			div = 1;
+		else if (WARN_ON(div > 0x3f))
+			return 0;
+
+		clkctrl |= div;
+
+		writel(CLKCTRL_CLKSEQ_BYPASS_GPMI,
+		       IMX_CCM_BASE + HW_CLKCTRL_CLKSEQ + seq_offs);
+
+		if ((clkctrl & CLKCTRL_GPMI_CLKGATE)) {
+			clkctrl &= ~CLKCTRL_GPMI_CLKGATE;
+			writel(clkctrl, IMX_CCM_BASE + HW_CLKCTRL_GPMI);
+
+		}
+
+		while (readl(IMX_CCM_BASE + HW_CLKCTRL_GPMI) &
+		       CLKCTRL_GPMI_CLKGATE)
+			;	/* noop */
+
+		writel(clkctrl, IMX_CCM_BASE + HW_CLKCTRL_GPMI);
+	}
+
+	while (readl(IMX_CCM_BASE + HW_CLKCTRL_GPMI) &
+	       CLKCTRL_GPMI_BUSY)
+		;			/* noop */
+
+	return imx_get_gpmiclk();
+}
+
+
 void imx_dump_clocks(void)
 {
 	printf("mpll:    %10u kHz\n", imx_get_mpllclk() / 1000);
@@ -389,4 +507,5 @@
 	printf("ssp1:    %10u kHz\n", imx_get_sspclk(1) / 1000);
 	printf("ssp2:    %10u kHz\n", imx_get_sspclk(2) / 1000);
 	printf("ssp3:    %10u kHz\n", imx_get_sspclk(3) / 1000);
+	printf("gpmi:    %10u kHz\n", imx_get_gpmiclk() / 1000);
 }
diff -ruN barebox-2012.02.0/arch/arm/mach-mxs/system-imx28.c barebox-2012.02.0-ccu2/arch/arm/mach-mxs/system-imx28.c
--- barebox-2012.02.0/arch/arm/mach-mxs/system-imx28.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-mxs/system-imx28.c	2013-01-14 12:46:28.000000000 +0100
@@ -0,0 +1,115 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <mach/imx-regs.h>
+
+#define MXS_MODULE_CLKGATE		(1u << 30)
+#define MXS_MODULE_SFTRST		(1u << 31)
+
+#define __mxs_clrl(_msk, _addr)	(__raw_writel((_msk),(_addr) + BIT_CLR))
+#define __mxs_setl(_msk, _addr)	(__raw_writel((_msk),(_addr) + BIT_SET))
+
+/*
+ * Clear the bit and poll it cleared.  This is usually called with
+ * a reset address and mask being either SFTRST(bit 31) or CLKGATE
+ * (bit 30).
+ */
+static int clear_poll_bit(void __iomem *addr, u32 mask)
+{
+	int timeout = 0x400;
+
+	/* clear the bit */
+	__mxs_clrl(mask, addr);
+
+	/*
+	 * SFTRST needs 3 GPMI clocks to settle, the reference manual
+	 * recommends to wait 1us.
+	 */
+	udelay(1);
+
+	/* poll the bit becoming clear */
+	while ((__raw_readl(addr) & mask) && --timeout)
+		/* nothing */;
+
+	return !timeout;
+}
+
+int mx28_reset_block(void __iomem *reset_addr, int just_enable)
+{
+	int ret;
+	int timeout = 0x400;
+
+	/* clear and poll SFTRST */
+	ret = clear_poll_bit(reset_addr, MXS_MODULE_SFTRST);
+	if (WARN_ON(ret))
+		goto error;
+
+	/* clear CLKGATE */
+	__mxs_clrl(MXS_MODULE_CLKGATE, reset_addr);
+
+	if (!just_enable) {
+		/* set SFTRST to reset the block */
+		__mxs_setl(MXS_MODULE_SFTRST, reset_addr);
+		udelay(1);
+
+		/* poll CLKGATE becoming set */
+		while ((!(__raw_readl(reset_addr) & MXS_MODULE_CLKGATE)) && --timeout)
+			udelay(1);
+
+		if (WARN_ON(!timeout))
+			goto error;
+	}
+
+	/* clear and poll SFTRST */
+	ret = clear_poll_bit(reset_addr, MXS_MODULE_SFTRST);
+	if (WARN_ON(ret))
+		goto error;
+
+	/* clear and poll CLKGATE */
+	ret = clear_poll_bit(reset_addr, MXS_MODULE_CLKGATE);
+	if (WARN_ON(ret))
+		goto error;
+
+	return 0;
+
+error:
+	pr_err("%s(%p): module reset timeout\n", __func__, reset_addr);
+	return -ETIMEDOUT;
+}
+EXPORT_SYMBOL(mx28_reset_block);
+
+int mx28_wait_mask_set(void __iomem *reg, uint32_t mask, int timeout)
+{
+	unsigned int		a = readl(0x8001c0c0);
+	unsigned int		b = a;
+
+        while ((unsigned int)(b - a) < timeout) {
+                if ((readl(reg) & mask) == mask)
+                        return 0;
+
+                b = readl(0x8001c0c0);
+        }
+
+	if (0)
+	printk("  to: %08x & %08x, %d / %u\n",
+	       readl(reg), mask,
+	       timeout, (unsigned int)(b-a));
+
+        return -ETIMEDOUT;;
+}
diff -ruN barebox-2012.02.0/arch/arm/mach-omap/auxcr.S barebox-2012.02.0-ccu2/arch/arm/mach-omap/auxcr.S
--- barebox-2012.02.0/arch/arm/mach-omap/auxcr.S	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-omap/auxcr.S	2013-01-14 12:46:22.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2012 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include <asm/unified.h>
+
+.arm
+ENTRY(setup_auxcr)
+	mov	r12, #0x3
+	mrc	p15, 0, r0, c1, c0, 1
+	orr	r0, r0, #0x10		@ Enable ASA
+	orr	r0, r0, #1 << 5		@ Enable L1NEON
+	.word 0xE1600070		@ SMC
+	mov	r12, #0x2
+	mrc	p15, 1, r0, c9, c0, 2
+	@ Set PLD_FWD bit in L2AUXCR (Cortex-A8 erratum 725233 workaround)
+	orr	r0, r0, #1 << 27
+	.word 0xE1600070		@ SMC
+	bx	lr
+ENDPROC(setup_auxcr)
diff -ruN barebox-2012.02.0/arch/arm/mach-omap/include/mach/omap3-clock.h barebox-2012.02.0-ccu2/arch/arm/mach-omap/include/mach/omap3-clock.h
--- barebox-2012.02.0/arch/arm/mach-omap/include/mach/omap3-clock.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-omap/include/mach/omap3-clock.h	2013-01-14 12:46:22.000000000 +0100
@@ -143,16 +143,6 @@
 	unsigned int m2div;
 };
 
-/* External functions see omap3_clock_core.S */
-extern struct dpll_param *get_mpu_dpll_param_34x(u32);
-extern struct dpll_param *get_iva_dpll_param_34x(u32);
-extern struct dpll_param *get_core_dpll_param_34x(u32);
-extern struct dpll_param *get_per_dpll_param_34x(u32);
-
-extern struct dpll_param *get_mpu_dpll_param_36x(u32);
-extern struct dpll_param *get_iva_dpll_param_36x(u32);
-extern struct dpll_param *get_core_dpll_param_36x(u32);
-extern struct dpll_param_per_36x *get_per_dpll_param_36x(u32);
 #endif /* __ASSEMBLY__ */
 
 #endif  /* endif _OMAP343X_CLOCKS_H_ */
diff -ruN barebox-2012.02.0/arch/arm/mach-omap/include/mach/silicon.h barebox-2012.02.0-ccu2/arch/arm/mach-omap/include/mach/silicon.h
--- barebox-2012.02.0/arch/arm/mach-omap/include/mach/silicon.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-omap/include/mach/silicon.h	2013-01-14 12:46:22.000000000 +0100
@@ -30,10 +30,8 @@
 #endif
 
 /* If Architecture specific init functions are present */
-#ifdef CONFIG_ARCH_HAS_LOWLEVEL_INIT
 #ifndef __ASSEMBLY__
-void a_init(void);
+void omap3_core_init(void);
 #endif /* __ASSEMBLY__ */
-#endif
 
 #endif /* __ASM_ARCH_OMAP_SILICON_H */
diff -ruN barebox-2012.02.0/arch/arm/mach-omap/Kconfig barebox-2012.02.0-ccu2/arch/arm/mach-omap/Kconfig
--- barebox-2012.02.0/arch/arm/mach-omap/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-omap/Kconfig	2013-01-14 12:46:22.000000000 +0100
@@ -26,6 +26,9 @@
 config MACH_OMAP
 	bool
 
+config OMAP3_LOWLEVEL_INIT
+	bool
+
 choice
 	prompt "Select OMAP Variant"
 
@@ -33,6 +36,7 @@
 	bool "OMAP3"
 	select CPU_V7
 	select GENERIC_GPIO
+	select OMAP3_LOWLEVEL_INIT
 	select ARCH_HAS_LOWLEVEL_INIT
 	select OMAP_CLOCK_SOURCE_S32K
 	help
@@ -73,14 +77,6 @@
 	help
 	  Say Y here if you like to have OMAP3 Clock configuration done.
 
-config OMAP3_COPY_CLOCK_SRAM
-	prompt "SRAM copy of Clock code"
-	bool
-	depends on OMAP3_CLOCK_CONFIG
-	default y
-	help
-	  Say Y here if you like to have initial OMAP3 Clock configuration done from SRAM.
-
 config OMAP_GPMC
 	prompt "Support for GPMC configuration"
 	bool
@@ -112,28 +108,23 @@
 
 config MACH_OMAP343xSDP
 	bool "Texas Instrument's SDP343x"
-	select MACH_HAS_LOWLEVEL_INIT
 	select OMAP_CLOCK_ALL
-	select HAS_OMAP_NAND
 	depends on ARCH_OMAP3
 	help
 	  Say Y here if you are using SDP343x platform
 
 config MACH_BEAGLE
 	bool "Texas Instrument's Beagle Board"
-	select MACH_HAS_LOWLEVEL_INIT
 	select OMAP_CLOCK_ALL
 	select HAVE_NOSHELL
-	select HAS_OMAP_NAND
 	depends on ARCH_OMAP3
 	  help
 	  Say Y here if you are using Beagle Board
 
 config MACH_OMAP3EVM
 	bool "Texas Instrument's OMAP3 EVM"
-	select MACH_HAS_LOWLEVEL_INIT
 	select OMAP_CLOCK_ALL
-	select HAS_OMAP_NAND
+	select HAVE_NOSHELL
 	depends on ARCH_OMAP3
 	  help
 	  Say Y here if you are using OMAP3EVM
@@ -142,6 +133,7 @@
 	bool "Texas Instrument's Panda Board"
 	select HAVE_NOSHELL
 	select MACH_HAS_LOWLEVEL_INIT
+	depends on ARCH_OMAP4
 	help
 	  Say Y here if you are using OMAP4 Panda board
 
@@ -156,9 +148,8 @@
 
 config MACH_PCAAL1
 	bool "Phytec phyCARD-A-L1"
-	select MACH_HAS_LOWLEVEL_INIT
 	select OMAP_CLOCK_ALL
-	select HAS_OMAP_NAND
+	depends on ARCH_OMAP3
 	  help
 	  Say Y here if you are using a phyCARD-A-L1 PCA-A-L1
 
@@ -190,7 +181,4 @@
 	  Say Y here if you would like to have complete pin muxing to be
 	  done at boot time
 
-config HAS_OMAP_NAND
-	bool
-
 endmenu
diff -ruN barebox-2012.02.0/arch/arm/mach-omap/Makefile barebox-2012.02.0-ccu2/arch/arm/mach-omap/Makefile
--- barebox-2012.02.0/arch/arm/mach-omap/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-omap/Makefile	2013-01-14 12:46:22.000000000 +0100
@@ -21,9 +21,9 @@
 #
 obj-$(CONFIG_ARCH_OMAP) += syslib.o
 obj-$(CONFIG_OMAP_CLOCK_SOURCE_S32K) += s32k_clksource.o
-obj-$(CONFIG_ARCH_OMAP3) += omap3_core.o omap3_generic.o
+obj-$(CONFIG_ARCH_OMAP3) += omap3_core.o omap3_generic.o auxcr.o
 obj-$(CONFIG_ARCH_OMAP4) += omap4_generic.o omap4_clock.o
-obj-$(CONFIG_OMAP3_CLOCK_CONFIG) += omap3_clock_core.o omap3_clock.o
+obj-$(CONFIG_OMAP3_CLOCK_CONFIG) += omap3_clock.o
 obj-$(CONFIG_OMAP_GPMC) += gpmc.o devices-gpmc-nand.o
 obj-$(CONFIG_SHELL_NONE) += xload.o
 obj-$(CONFIG_I2C_TWL6030) += omap4_twl6030_mmc.o
diff -ruN barebox-2012.02.0/arch/arm/mach-omap/omap3_clock.c barebox-2012.02.0-ccu2/arch/arm/mach-omap/omap3_clock.c
--- barebox-2012.02.0/arch/arm/mach-omap/omap3_clock.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-omap/omap3_clock.c	2013-01-14 12:46:22.000000000 +0100
@@ -47,10 +47,6 @@
 #include <mach/syslib.h>
 
 /* Following functions are exported from omap3_clock_core.S */
-#ifdef CONFIG_OMAP3_COPY_CLOCK_SRAM
-/* A.K.A go_to_speed */
-static void (*f_lock_pll) (u32, u32, u32, u32);
-#endif
 /* Helper functions */
 static u32 get_osc_clk_speed(void);
 static void get_sys_clkin_sel(u32 osc_clk, u32 *sys_clkin_sel);
@@ -147,6 +143,22 @@
 		*sys_clkin_sel = 0;
 }
 
+static struct dpll_param core_dpll_param_34x_es1[] = {
+	{ .m = 0x19F, .n = 0x0E, .fsel = 0x03, .m2 = 0x01, }, /* 12   MHz */
+	{ .m = 0x1B2, .n = 0x10, .fsel = 0x03, .m2 = 0x01, }, /* 13   MHz */
+	{ .m = 0x19F, .n = 0x17, .fsel = 0x03, .m2 = 0x01, }, /* 19.2 MHz */
+	{ .m = 0x1B2, .n = 0x21, .fsel = 0x03, .m2 = 0x01, }, /* 26   MHz */
+	{ .m = 0x19F, .n = 0x2F, .fsel = 0x03, .m2 = 0x01, }, /* 38.4 MHz */
+};
+
+static struct dpll_param core_dpll_param_34x_es2[] = {
+	{ .m = 0x0A6, .n = 0x05, .fsel = 0x07, .m2 = 0x01, }, /* 12   MHz */
+	{ .m = 0x14C, .n = 0x0C, .fsel = 0x03, .m2 = 0x01, }, /* 13   MHz */
+	{ .m = 0x19F, .n = 0x17, .fsel = 0x03, .m2 = 0x01, }, /* 19.2 MHz */
+	{ .m = 0x0A6, .n = 0x0C, .fsel = 0x07, .m2 = 0x01, }, /* 26   MHz */
+	{ .m = 0x19F, .n = 0x2F, .fsel = 0x03, .m2 = 0x01, }, /* 38.4 MHz */
+};
+
 /**
  * @brief Initialize CORE DPLL for OMAP34x
  *
@@ -155,10 +167,11 @@
  */
 static void init_core_dpll_34x(u32 cpu_rev, u32 clk_sel)
 {
-	struct dpll_param *dp = get_core_dpll_param_34x(cpu_rev);
-#ifdef CONFIG_OMAP3_COPY_CLOCK_SRAM
-	int p0, p1, p2, p3;
-#endif
+	struct dpll_param *dp;
+	if (cpu_rev == OMAP34XX_ES1)
+		dp = core_dpll_param_34x_es1;
+	else
+		dp = core_dpll_param_34x_es2;
 
 	dp += clk_sel;
 
@@ -202,49 +215,20 @@
 		sr32(CM_REG(CLKEN_PLL), 0, 3, PLL_LOCK);
 		wait_on_value((0x1 << 0), 1, CM_REG(IDLEST_CKGEN), LDELAY);
 	} else if (running_in_flash()) {
-#ifdef CONFIG_OMAP3_COPY_CLOCK_SRAM
-		f_lock_pll = (void *)(OMAP_SRAM_INTVECT +
-					OMAP_SRAM_INTVECT_COPYSIZE);
-
-		/*
-		 * Jump to small relocated code area in SRAM.
-		 */
-		p0 = readl(CM_REG(CLKEN_PLL));
-		sr32((u32) &p0, 0, 3, PLL_FAST_RELOCK_BYPASS);
-
-		/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
-		sr32((u32) &p0, 4, 4, dp->fsel);
-
-		p1 = readl(CM_REG(CLKSEL1_PLL));
-
-		/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
-		sr32((u32) &p1, 27, 2, dp->m2);
-
-		/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
-		sr32((u32) &p1, 16, 11, dp->m);
-
-		/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
-		sr32((u32) &p1, 8, 7, dp->n);
-
-		/* Set source CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
-		sr32((u32) &p1, 6, 1, 0);
-
-		p2 = readl(CM_REG(CLKSEL_CORE));
-		sr32((u32) &p2, 8, 4, CORE_SSI_DIV);
-		sr32((u32) &p2, 4, 2, CORE_FUSB_DIV);
-		sr32((u32) &p2, 2, 2, CORE_L4_DIV);
-		sr32((u32) &p2, 0, 2, CORE_L3_DIV);
-
-		p3 = CM_REG(IDLEST_CKGEN);
-
-		(*f_lock_pll) (p0, p1, p2, p3);
-#else
 		/***Oopps.. Wrong .config!! *****/
 		hang();
-#endif
 	}
 }
 
+/* PER DPLL values are same for both ES1 and ES2 */
+static struct dpll_param per_dpll_param_34x[] = {
+	{ .m = 0x0D8, .n = 0x05, .fsel = 0x07, .m2 = 0x09, }, /* 12   MHz */
+	{ .m = 0x1B0, .n = 0x0C, .fsel = 0x03, .m2 = 0x09, }, /* 13   MHz */
+	{ .m = 0x0E1, .n = 0x09, .fsel = 0x07, .m2 = 0x09, }, /* 19.2 MHz */
+	{ .m = 0x0D8, .n = 0x0C, .fsel = 0x07, .m2 = 0x09, }, /* 26   MHz */
+	{ .m = 0x0E1, .n = 0x13, .fsel = 0x07, .m2 = 0x09, }, /* 38.4 MHz */
+};
+
 /**
  * @brief Initialize PER DPLL for OMAP34x
  *
@@ -253,7 +237,7 @@
  */
 static void init_per_dpll_34x(u32 cpu_rev, u32 clk_sel)
 {
-	struct dpll_param *dp = get_per_dpll_param_34x(cpu_rev);
+	struct dpll_param *dp = per_dpll_param_34x;
 
 	dp += clk_sel;
 
@@ -300,6 +284,22 @@
 	wait_on_value((0x1 << 1), 2, CM_REG(IDLEST_CKGEN), LDELAY);
 }
 
+static struct dpll_param mpu_dpll_param_34x_es1[] = {
+	{ .m = 0x0FE, .n = 0x07, .fsel = 0x05, .m2 = 0x01, }, /* 12   MHz */
+	{ .m = 0x17D, .n = 0x0C, .fsel = 0x03, .m2 = 0x01, }, /* 13   MHz */
+	{ .m = 0x179, .n = 0x12, .fsel = 0x04, .m2 = 0x01, }, /* 19.2 MHz */
+	{ .m = 0x17D, .n = 0x19, .fsel = 0x03, .m2 = 0x01, }, /* 26   MHz */
+	{ .m = 0x1FA, .n = 0x32, .fsel = 0x03, .m2 = 0x01, }, /* 38.4 MHz */
+};
+
+static struct dpll_param mpu_dpll_param_34x_es2[] = {
+	{.m = 0x0FA, .n = 0x05, .fsel = 0x07, .m2 = 0x01, }, /* 12   MHz */
+	{.m = 0x1F4, .n = 0x0C, .fsel = 0x03, .m2 = 0x01, }, /* 13   MHz */
+	{.m = 0x271, .n = 0x17, .fsel = 0x03, .m2 = 0x01, }, /* 19.2 MHz */
+	{.m = 0x0FA, .n = 0x0C, .fsel = 0x07, .m2 = 0x01, }, /* 26   MHz */
+	{.m = 0x271, .n = 0x2F, .fsel = 0x03, .m2 = 0x01, }, /* 38.4 MHz */
+};
+
 /**
  * @brief Initialize MPU DPLL for OMAP34x
  *
@@ -311,7 +311,12 @@
  */
 static void init_mpu_dpll_34x(u32 cpu_rev, u32 clk_sel)
 {
-	struct dpll_param *dp = get_mpu_dpll_param_34x(cpu_rev);
+	struct dpll_param *dp;
+
+	if (cpu_rev == OMAP34XX_ES1)
+		dp = mpu_dpll_param_34x_es1;
+	else
+		dp = mpu_dpll_param_34x_es2;
 
 	dp += clk_sel;
 
@@ -328,6 +333,22 @@
 	sr32(CM_REG(CLKEN_PLL_MPU), 4, 4, dp->fsel);
 }
 
+static struct dpll_param iva_dpll_param_34x_es1[] = {
+	{ .m = 	0x07D, .n = 0x05, .fsel = 0x07,	.m2 = 0x01, }, /* 12   MHz */
+	{ .m = 	0x0FA, .n = 0x0C, .fsel = 0x03,	.m2 = 0x01, }, /* 13   MHz */
+	{ .m = 	0x082, .n = 0x09, .fsel = 0x07,	.m2 = 0x01, }, /* 19.2 MHz */
+	{ .m = 	0x07D, .n = 0x0C, .fsel = 0x07,	.m2 = 0x01, }, /* 26   MHz */
+	{ .m = 	0x13F, .n = 0x30, .fsel = 0x03,	.m2 = 0x01, }, /* 38.4 MHz */
+};
+
+static struct dpll_param iva_dpll_param_34x_es2[] = {
+	{ .m = 0x0B4, .n = 0x05, .fsel = 0x07, .m2 = 0x01, }, /* 12   MHz */
+	{ .m = 0x168, .n = 0x0C, .fsel = 0x03, .m2 = 0x01, }, /* 13   MHz */
+	{ .m = 0x0E1, .n = 0x0B, .fsel = 0x06, .m2 = 0x01, }, /* 19.2 MHz */
+	{ .m = 0x0B4, .n = 0x0C, .fsel = 0x07, .m2 = 0x01, }, /* 26   MHz */
+	{ .m = 0x0E1, .n = 0x17, .fsel = 0x06, .m2 = 0x01, }, /* 38.4 MHz */
+};
+
 /**
  * @brief Initialize IVA DPLL for OMAP34x
  *
@@ -336,7 +357,12 @@
  */
 static void init_iva_dpll_34x(u32 cpu_rev, u32 clk_sel)
 {
-	struct dpll_param *dp = get_iva_dpll_param_34x(cpu_rev);
+	struct dpll_param *dp;
+
+	if (cpu_rev == OMAP34XX_ES1)
+		dp = iva_dpll_param_34x_es1;
+	else
+		dp = iva_dpll_param_34x_es2;
 
 	dp += clk_sel;
 
@@ -361,6 +387,15 @@
 	wait_on_value((0x1 << 0), 1, CM_REG(IDLEST_PLL_IVA2), LDELAY);
 }
 
+/* FIXME: All values correspond to 26MHz only */
+static struct dpll_param core_dpll_param_36x[] = {
+	{ .m = 0x0C8, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 12   MHz */
+	{ .m = 0x0C8, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 13   MHz */
+	{ .m = 0x0C8, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 19.2 MHz */
+	{ .m = 0x0C8, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 26   MHz */
+	{ .m = 0x0C8, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 38.4 MHz */
+};
+
 /**
  * @brief Initialize CORE DPLL for OMAP36x
  *
@@ -369,10 +404,7 @@
  */
 static void init_core_dpll_36x(u32 cpu_rev, u32 clk_sel)
 {
-	struct dpll_param *dp = get_core_dpll_param_36x(cpu_rev);
-#ifdef CONFIG_OMAP3_COPY_CLOCK_SRAM
-	int p0, p1, p2, p3;
-#endif
+	struct dpll_param *dp = core_dpll_param_36x;
 
 	dp += clk_sel;
 
@@ -409,49 +441,20 @@
 		sr32(CM_REG(CLKEN_PLL), 0, 3, PLL_LOCK);
 		wait_on_value((0x1 << 0), 1, CM_REG(IDLEST_CKGEN), LDELAY);
 	} else if (running_in_flash()) {
-#ifdef CONFIG_OMAP3_COPY_CLOCK_SRAM
-		f_lock_pll = (void *)(OMAP_SRAM_INTVECT +
-					OMAP_SRAM_INTVECT_COPYSIZE);
-
-		/*
-		 * Jump to small relocated code area in SRAM.
-		 */
-		p0 = readl(CM_REG(CLKEN_PLL));
-		sr32((u32) &p0, 0, 3, PLL_FAST_RELOCK_BYPASS);
-
-		/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
-		sr32((u32) &p0, 4, 4, dp->fsel);
-
-		p1 = readl(CM_REG(CLKSEL1_PLL));
-
-		/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
-		sr32((u32) &p1, 27, 5, dp->m2);
-
-		/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
-		sr32((u32) &p1, 16, 11, dp->m);
-
-		/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
-		sr32((u32) &p1, 8, 7, dp->n);
-
-		/* Set source CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
-		sr32((u32) &p1, 6, 1, 0);
-
-		p2 = readl(CM_REG(CLKSEL_CORE));
-		sr32((u32) &p2, 8, 4, CORE_SSI_DIV);
-		sr32((u32) &p2, 4, 2, CORE_FUSB_DIV);
-		sr32((u32) &p2, 2, 2, CORE_L4_DIV);
-		sr32((u32) &p2, 0, 2, CORE_L3_DIV);
-
-		p3 = CM_REG(IDLEST_CKGEN);
-
-		(*f_lock_pll) (p0, p1, p2, p3);
-#else
 		/***Oopps.. Wrong .config!! *****/
 		hang();
-#endif
 	}
 }
 
+/* FIXME: All values correspond to 26MHz only */
+static struct dpll_param_per_36x per_dpll_param_36x[] = {
+	{ .m = 0x1B0, .n = 0x0C, .m2 = 9, .m3 = 0x10, .m4 = 9, .m5 = 4,	.m6 = 3, .m2div = 1, },  /* 12   MHz */
+	{ .m = 0x1B0, .n = 0x0C, .m2 = 9, .m3 = 0x10, .m4 = 9, .m5 = 4,	.m6 = 3, .m2div = 1, },  /* 13   MHz */
+	{ .m = 0x1B0, .n = 0x0C, .m2 = 9, .m3 = 0x10, .m4 = 9, .m5 = 4,	.m6 = 3, .m2div = 1, },  /* 19.2 MHz */
+	{ .m = 0x1B0, .n = 0x0C, .m2 = 9, .m3 = 0x10, .m4 = 9, .m5 = 4,	.m6 = 3, .m2div = 1, },  /* 26   MHz */
+	{ .m = 0x1B0, .n = 0x0C, .m2 = 9, .m3 = 0x10, .m4 = 9, .m5 = 4,	.m6 = 3, .m2div = 1, },  /* 38.4 MHz */
+};
+
 /**
  * @brief Initialize PER DPLL for OMAP36x
  *
@@ -460,7 +463,7 @@
  */
 static void init_per_dpll_36x(u32 cpu_rev, u32 clk_sel)
 {
-	struct dpll_param_per_36x *dp = get_per_dpll_param_36x(cpu_rev);
+	struct dpll_param_per_36x *dp = per_dpll_param_36x;
 
 	dp += clk_sel;
 
@@ -496,6 +499,15 @@
 	wait_on_value((0x1 << 1), 2, CM_REG(IDLEST_CKGEN), LDELAY);
 }
 
+/* FIXME: All values correspond to 26MHz only */
+static struct dpll_param mpu_dpll_param_36x[] = {
+	{ .m = 0x12C, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 12   MHz */
+	{ .m = 0x12C, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 13   MHz */
+	{ .m = 0x12C, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 19.2 MHz */
+	{ .m = 0x12C, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 26   MHz */
+	{ .m = 0x12C, .n = 0x0C, .fsel = 0x00, .m2 = 0x01, }, /* 38.4 MHz */
+};
+
 /**
  * @brief Initialize MPU DPLL for OMAP36x
  *
@@ -504,7 +516,7 @@
  */
 static void init_mpu_dpll_36x(u32 cpu_rev, u32 clk_sel)
 {
-	struct dpll_param *dp = get_mpu_dpll_param_36x(cpu_rev);
+	struct dpll_param *dp = mpu_dpll_param_36x;
 
 	dp += clk_sel;
 
@@ -521,6 +533,15 @@
 	sr32(CM_REG(CLKEN_PLL_MPU), 4, 4, dp->fsel);
 }
 
+/* FIXME: All values correspond to 26MHz only */
+static struct dpll_param iva_dpll_param_36x[] = {
+	{ .m = 0x00A, .n = 0x00, .fsel = 0x00, .m2 = 0x01, }, /* 12   MHz */
+	{ .m = 0x00A, .n = 0x00, .fsel = 0x00, .m2 = 0x01, }, /* 13   MHz */
+	{ .m = 0x00A, .n = 0x00, .fsel = 0x00, .m2 = 0x01, }, /* 19.2 MHz */
+	{ .m = 0x00A, .n = 0x00, .fsel = 0x00, .m2 = 0x01, }, /* 26   MHz */
+	{ .m = 0x00A, .n = 0x00, .fsel = 0x00, .m2 = 0x01, }, /* 38.4 MHz */
+};
+
 /**
  * @brief Initialize IVA DPLL for OMAP36x
  *
@@ -529,7 +550,7 @@
  */
 static void init_iva_dpll_36x(u32 cpu_rev, u32 clk_sel)
 {
-	struct dpll_param *dp = get_iva_dpll_param_36x(cpu_rev);
+	struct dpll_param *dp = iva_dpll_param_36x;
 
 	dp += clk_sel;
 
@@ -557,8 +578,7 @@
 /**
  * @brief Inits clocks for PRCM
  *
- * This is called from SRAM, or Flash (using temp SRAM stack).
- * if CONFIG_OMAP3_COPY_CLOCK_SRAM is defined, @ref go_to_speed
+ * This is called from SRAM
  *
  * @return void
  */
diff -ruN barebox-2012.02.0/arch/arm/mach-omap/omap3_core.S barebox-2012.02.0-ccu2/arch/arm/mach-omap/omap3_core.S
--- barebox-2012.02.0/arch/arm/mach-omap/omap3_core.S	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-omap/omap3_core.S	2013-01-14 12:46:22.000000000 +0100
@@ -13,7 +13,6 @@
  * @li Call architecture initialization function a_init
  *
  * arch_init_lowlevel is enabled if CONFIG_ARCH_HAS_LOWLEVEL_INIT is defined
- * cpy_clk_code is called if CONFIG_OMAP3_COPY_CLOCK_SRAM is defined
  */
 /*
  * (C) Copyright 2006-2008
@@ -37,55 +36,14 @@
  */
 
 #include <config.h>
+#include <linux/linkage.h>
+#include <asm/assembler.h>
 #include <mach/silicon.h>
 #include <mach/wdt.h>
 #include <mach/clocks.h>
 
 #ifdef CONFIG_ARCH_HAS_LOWLEVEL_INIT
-.globl arch_init_lowlevel
-arch_init_lowlevel:
-       /* Copy vectors to mask ROM indirect addr */
-	mov	r0, pc			/* Store the current pc address */
-	sub	r0, r0, #8		/* Reduce offset */
-	ldr	r1, arch_start		/* Load the link address for arch_int */
-	ldr	r2, barebox_start		/* load the link address of start_init*/
-	sub	r1, r1, r2		/* get the offset */
-	/* subtract the offset from PC of arch=Current start */
-	sub	r0, r0, r1
-	mov	r2, #OMAP_SRAM_INTVECT_COPYSIZE		/* r2 <- size to copy */
-	add	r2, r0, r2		/* r2 <- source end address */
-	ldr	r1, SRAM_INTVECT	/* build vect addr */
-next:
-	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
-	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
-	cmp	r0, r2			/* until source end address [r2]    */
-	ble	next			/* loop until equal */
-
-#ifdef CONFIG_OMAP3_COPY_CLOCK_SRAM
-	/* No need to copy/exec the clock code - DPLL adjust already done
-	 * in Perip/NAND/oneNAND Boot.
-	 * Put dpll adjust code behind vectors. r1 has address to copy to
-	 */
-	bl	cpy_clk_code
-#endif
-	ldr	r1, SRAM_INTVECT	/* build vect addr */
-	/* Read the interrupt vector base address */
-	mrc p15, #0, r0, c12, c0, #0
-	/* Clear the vector base 4:0 is reserved. */
-	and r0, r0, #0xF
-	/* Store the SRAM_INTVECT address */
-	orr r0, r0, r1
-	/* Store the new vector address */
-	mcr p15, #0, r0, c12, c0, #0
-	/* Setup a temporary stack so that we can call C functions */
-	ldr	sp,	SRAM_STACK
-        str     ip,	[sp]    /* stash old link register */
-        str     lr,	[sp]    /* stash current link register */
-	mov	ip,	lr	/* save link reg across call */
-	bl      a_init          /* Architecture init */
-        ldr     lr,	[sp]    /* restore current link register */
-        ldr     ip,	[sp]    /* restore save ip */
-
+ENTRY(arch_init_lowlevel)
 	/* Invalidate all Dcaches */
 #ifndef CONFIG_CPU_V7_DCACHE_SKIP
 	/* If Arch specific ROM code SMI handling does not exist */
@@ -113,8 +71,12 @@
 inval_loop2:
 	mov	r9, r4			/* create working copy of max way size */
 inval_loop3:
-	orr	r11, r10, r9, lsl r5	/* factor way and cache number into r11*/
-	orr	r11, r11, r7, lsl r2	/* factor index number into r11 */
+ARM(	orr	r11, r10, r9, lsl r5	) /* factor way and cache number into r11 */
+ARM(	orr	r11, r11, r7, lsl r2	) /* factor index number into r11 */
+THUMB(	lsl	r6, r9, r5		)
+THUMB(	orr	r11, r10, r6		) /* factor way and cache number into r11 */
+THUMB(	lsl	r6, r7, r2		)
+THUMB(	orr	r11, r11, r6		) /* factor index number into r11 */
 	mcr	p15, 0, r11, c7, c6, 2	/* invalidate by set/way */
 	subs	r9, r9, #1		/* decrement the way */
 	bge	inval_loop3
@@ -131,13 +93,7 @@
 #endif /* CONFIG_CPU_V7_DCACHE_SKIP */
 	/* back to arch calling code */
 	mov	pc,	lr
-
-arch_start:
-	.word	arch_init_lowlevel
-barebox_start:
-	.word	exception_vectors
-SRAM_INTVECT:
-	.word	OMAP_SRAM_INTVECT
+ENDPROC(arch_init_lowlevel)
 
 SRAM_STACK:
 	.word	OMAP_SRAM_STACK
diff -ruN barebox-2012.02.0/arch/arm/mach-omap/omap3_generic.c barebox-2012.02.0-ccu2/arch/arm/mach-omap/omap3_generic.c
--- barebox-2012.02.0/arch/arm/mach-omap/omap3_generic.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/mach-omap/omap3_generic.c	2013-01-14 12:46:22.000000000 +0100
@@ -419,25 +419,7 @@
  *
  * @return void
  */
-static void setup_auxcr(void)
-{
-	unsigned long i;
-	volatile unsigned int j;
-	/* Save r0, r12 and restore them after usage */
-	__asm__ __volatile__("mov %0, r12":"=r"(j));
-	__asm__ __volatile__("mov %0, r0":"=r"(i));
-
-	/* GP Device ROM code API usage here */
-	/* r12 = AUXCR Write function and r0 value */
-	__asm__ __volatile__("mov r12, #0x3");
-	__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
-	/* Enabling ASA */
-	__asm__ __volatile__("orr r0, r0, #0x10");
-	/* SMI instruction to call ROM Code API */
-	__asm__ __volatile__(".word 0xE1600070");
-	__asm__ __volatile__("mov r0, %0":"=r"(i));
-	__asm__ __volatile__("mov r12, %0":"=r"(j));
-}
+void setup_auxcr(void);
 
 /**
  * @brief Try to unlock the SRAM for general use
@@ -484,7 +466,7 @@
  *
  * @return void
  */
-void a_init(void)
+void omap3_core_init(void)
 {
 	watchdog_init();
 
diff -ruN barebox-2012.02.0/arch/arm/Makefile barebox-2012.02.0-ccu2/arch/arm/Makefile
--- barebox-2012.02.0/arch/arm/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/Makefile	2013-01-14 12:46:28.000000000 +0100
@@ -87,9 +87,9 @@
 board-$(CONFIG_MACH_MX1ADS)			:= mx1ads
 board-$(CONFIG_MACH_NOMADIK_8815NHK)		:= nhk8815
 board-$(CONFIG_MACH_NXDB500)			:= netx
-board-$(CONFIG_MACH_OMAP343xSDP)		:= omap
-board-$(CONFIG_MACH_BEAGLE)			:= omap
-board-$(CONFIG_MACH_OMAP3EVM)			:= omap
+board-$(CONFIG_MACH_OMAP343xSDP)		:= omap343xdsp
+board-$(CONFIG_MACH_BEAGLE)			:= beagle
+board-$(CONFIG_MACH_OMAP3EVM)			:= omap3evm
 board-$(CONFIG_MACH_PANDA)			:= panda
 board-$(CONFIG_MACH_PCM049)			:= pcm049
 board-$(CONFIG_MACH_PCA100)			:= phycard-i.MX27
@@ -111,11 +111,15 @@
 board-$(CONFIG_MACH_FREESCALE_MX53_SMD)		:= freescale-mx53-smd
 board-$(CONFIG_MACH_GUF_CUPID)			:= guf-cupid
 board-$(CONFIG_MACH_MINI2440)			:= mini2440
+board-$(CONFIG_MACH_TNY_A9260)			:= tny-a926x
+board-$(CONFIG_MACH_TNY_A9263)			:= tny-a926x
+board-$(CONFIG_MACH_TNY_A9G20)			:= tny-a926x
 board-$(CONFIG_MACH_USB_A9260)			:= usb-a926x
 board-$(CONFIG_MACH_USB_A9263)			:= usb-a926x
 board-$(CONFIG_MACH_USB_A9G20)			:= usb-a926x
 board-$(CONFIG_MACH_VERSATILEPB)		:= versatile
 board-$(CONFIG_MACH_TX25)			:= karo-tx25
+board-$(CONFIG_MACH_EQ3_CCU2)			:= eq3-ccu2
 
 machdirs := $(patsubst %,arch/arm/mach-%/,$(machine-y))
 
@@ -131,8 +135,12 @@
 
 ifndef CONFIG_MODULES
 # Add cleanup flags
+#CPPFLAGS += -flto
+#LDFLAGS_barebox += -static -flto -fuse-linker-plugin
 CPPFLAGS += -fdata-sections -ffunction-sections
 LDFLAGS_barebox += -static --gc-sections
+
+#barebox:	LD := $(CC)
 endif
 
 barebox.netx: barebox.bin
@@ -147,12 +155,13 @@
 KBUILD_IMAGE := barebox.netx
 endif
 
-barebox.bin.ift: barebox.bin
+MLO: barebox.bin
 	@echo "  IFT    " $@
 	$(Q)scripts/omap_signGP barebox.bin $(TEXT_BASE) 1
+	$(Q)test -e barebox.bin.ift && mv barebox.bin.ift MLO
 
 ifeq ($(CONFIG_OMAP_BUILD_IFT),y)
-KBUILD_IMAGE := barebox.bin.ift
+KBUILD_IMAGE := MLO
 endif
 
 all: $(KBUILD_IMAGE)
diff -ruN barebox-2012.02.0/arch/arm/tools/mach-types barebox-2012.02.0-ccu2/arch/arm/tools/mach-types
--- barebox-2012.02.0/arch/arm/tools/mach-types	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/arm/tools/mach-types	2013-01-14 12:46:22.000000000 +0100
@@ -3903,3 +3903,4 @@
 apq8064_mtp		MACH_APQ8064_MTP	APQ8064_MTP		3949
 apq8064_fluid		MACH_APQ8064_FLUID	APQ8064_FLUID		3950
 apq8064_liquid		MACH_APQ8064_LIQUID	APQ8064_LIQUID		3951
+elv_ccu2		MACH_ELV_CCU2		ELV_CCU2		3957
diff -ruN barebox-2012.02.0/arch/mips/lib/barebox.lds.S barebox-2012.02.0-ccu2/arch/mips/lib/barebox.lds.S
--- barebox-2012.02.0/arch/mips/lib/barebox.lds.S	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/mips/lib/barebox.lds.S	2013-01-14 12:46:35.000000000 +0100
@@ -34,9 +34,12 @@
 		*(.text_entry*)
 		_stext = .;
 		_text = .;
+		__bare_init_start = .;
 		*(.text_bare_init*)
+		__bare_init_end = .;
 		*(.text*)
 	}
+	BAREBOX_BARE_INIT_SIZE
 
 	PRE_IMAGE
 
diff -ruN barebox-2012.02.0/arch/mips/lib/.gitignore barebox-2012.02.0-ccu2/arch/mips/lib/.gitignore
--- barebox-2012.02.0/arch/mips/lib/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/mips/lib/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-barebox.lds
diff -ruN barebox-2012.02.0/arch/nios2/cpu/barebox.lds.S barebox-2012.02.0-ccu2/arch/nios2/cpu/barebox.lds.S
--- barebox-2012.02.0/arch/nios2/cpu/barebox.lds.S	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/nios2/cpu/barebox.lds.S	2013-01-14 12:46:35.000000000 +0100
@@ -44,9 +44,12 @@
 		_stext = .;
 		__text = .;
 		_text = .;
+		__bare_init_start = .;
 		*(.text_entry)
+		__bare_init_end = .;
 		*(.text)
 	}
+	BAREBOX_BARE_INIT_SIZE
 
 	. = ALIGN(4);
 	.rodata : { *(.rodata) }
diff -ruN barebox-2012.02.0/arch/sandbox/board/.gitignore barebox-2012.02.0-ccu2/arch/sandbox/board/.gitignore
--- barebox-2012.02.0/arch/sandbox/board/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/sandbox/board/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-barebox.lds
diff -ruN barebox-2012.02.0/arch/x86/lib/barebox.lds.S barebox-2012.02.0-ccu2/arch/x86/lib/barebox.lds.S
--- barebox-2012.02.0/arch/x86/lib/barebox.lds.S	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/arch/x86/lib/barebox.lds.S	2013-01-14 12:46:34.000000000 +0100
@@ -145,13 +145,16 @@
 		/* do not align here! It may fails with the LOADADDR! */
 		_stext = .;
 		*(.text_entry*)
+		__bare_init_start = .;
 		*(.text_bare_init*)
+		__bare_init_end = .;
 		*(.text*)
 		. = ALIGN(4);
 		*(.rodata*)
 		. = ALIGN(4);
 		_etext = .;			/* End of text and rodata section */
 	} > barebox
+	BAREBOX_BARE_INIT_SIZE
 
 	.data : AT ( LOADADDR(.text) + SIZEOF(.text) ) {
 		*(.data*)
diff -ruN barebox-2012.02.0/commands/Kconfig barebox-2012.02.0-ccu2/commands/Kconfig
--- barebox-2012.02.0/commands/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/commands/Kconfig	2013-01-14 12:46:19.000000000 +0100
@@ -311,6 +311,8 @@
 	tristate
 	default y
 	select CRC32
+	select UNCOMPRESS
+	select FILETYPE
 	prompt "bootm"
 
 config CMD_BOOTM_SHOW_TYPE
@@ -421,6 +423,7 @@
 config CMD_VERSION
 	tristate
 	default y
+	depends on BANNER
 	prompt "version"
 
 config CMD_HELP
@@ -475,6 +478,7 @@
 
 config CMD_UNCOMPRESS
 	bool
+	select UNCOMPRESS
 	prompt "uncompress"
 	help
 	  Say yes here to get the uncompress command. uncompress handles
@@ -512,6 +516,18 @@
 	help
 	  The usb command allows to rescan for USB devices.
 
+config CMD_FCB
+       bool
+       depends on ARCH_IMX28
+       prompt "fcbinfo command"
+       default y
+
+config CMD_WATCHDOG
+       bool
+       depends on ARCH_IMX28
+       prompt "watchdog command"
+       default y
+
 endmenu
 
 endif
diff -ruN barebox-2012.02.0/commands/login.c barebox-2012.02.0-ccu2/commands/login.c
--- barebox-2012.02.0/commands/login.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/commands/login.c	2013-01-14 12:46:19.000000000 +0100
@@ -63,7 +63,7 @@
 		if (passwd_len < 0)
 			run_command(timeout_cmd, 0);
 
-		if (check_passwd(passwd, passwd_len))
+		if (check_passwd(passwd, passwd_len) > 0)
 			return 0;
 	} while(1);
 
diff -ruN barebox-2012.02.0/commands/Makefile barebox-2012.02.0-ccu2/commands/Makefile
--- barebox-2012.02.0/commands/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/commands/Makefile	2013-01-14 12:46:19.000000000 +0100
@@ -64,3 +64,5 @@
 obj-$(CONFIG_CMD_MAGICVAR)	+= magicvar.o
 obj-$(CONFIG_CMD_IOMEM)		+= iomem.o
 obj-$(CONFIG_CMD_LINUX_EXEC)	+= linux_exec.o
+obj-$(CONFIG_CMD_FCB)		+= mx28.o
+obj-$(CONFIG_CMD_WATCHDOG)	+= watchdog.o
diff -ruN barebox-2012.02.0/commands/mx28.c barebox-2012.02.0-ccu2/commands/mx28.c
--- barebox-2012.02.0/commands/mx28.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/commands/mx28.c	2013-01-14 12:46:19.000000000 +0100
@@ -0,0 +1,599 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <errno.h>
+#include <fs.h>
+#include <fcntl.h>
+#include <clock.h>
+#include <environment.h>
+#include <net.h>
+
+#include <asm/unaligned.h>
+
+#include <mach/clock.h>
+#include <mach/gpmi.h>
+#include <mach/imx-regs.h>
+
+#include <asm/io.h>
+
+#define FCB_FIELDS							\
+	F(checksum, "FCB checksum", "%08x")				\
+	F(fingerprint, "Magic fingerprint", "%08x")			\
+	F(version, "FCB version", "%08x")					\
+	F(nand_timing0, "NAND timings/0", "%08x")			\
+	F(nand_timing1, "NAND timings/1", "%08x")			\
+	F(page_data_size, "page data size", "%u")			\
+	F(total_page_size, "Total page size", "%u")			\
+	F(sectors_per_block, "Sectors per block", "%u")			\
+	F(number_of_nands, "Number of NAND devices", "%u")		\
+	F(total_internal_die, "Number of internal dice", "%u")		\
+	F(cell_type, "Cell Type", "%u")					\
+	F(ecc_blockN_ecc_type, "BlockN ECC type", "%u")			\
+	F(ecc_block0_size, "Block0 ECC size", "%u")			\
+	F(ecc_blockN_size, "BlockN ECC size", "%u")			\
+	F(ecc_block0_ecc_type, "Block0 ECC type", "%u")			\
+	F(metadata_bytes, "Number of metadata bytes", "%u")		\
+	F(num_ecc_blocks_per_page, "Number of BCH block excluding B0", "%u") \
+	F(ecc_blockN_ecc_level_sdk, "BlockN ECC level (SDK)", "%u")	\
+	F(ecc_block0_size_sdk, "Block0 ECC Size (SDK)", "%u")		\
+	F(ecc_blockN_size_sdk, "BlockN ECC Size (SDK)", "%u")		\
+	F(ecc_block0_ecc_level_sdk, "Block0 ECC level (SDK)", "%u")	\
+	F(ecc_num_ecc_block_per_page_sdk, "ECC Blocks per page (SDK)", "%u") \
+	F(metadata_bytes_sdk, "Metadata Bytes (SDK)", "%u")		\
+	F(erase_threshold, "BCH_MODE erase threshold", "%08x")		\
+	F(boot_patch, "Boot patch", "%u")				\
+	F(patch_sectors, "Number of patch pages", "%u")			\
+	F(firmware1_sector, "Primary Firmware starting sector", "%u")	\
+	F(firmware2_sector, "Secondary Firmware starting sector", "%u") \
+	F(firmware1_num_sector, "Primary Firmware sector count", "%u") \
+	F(firmware2_num_sector, "Secondary Firmware sector count", "%u") \
+	F(dbbt_start_address, "DBBT Search Area starting page", "%u")	\
+	F(bad_block_marker_byte, "Byte offset of bad block marker", "%u") \
+	F(bad_block_marker_start_bit, "Bit offset of bad block marker", "%u") \
+	F(bb_marker_physical_offset, "Physical byte offset of bb marker", "%u")
+
+#define DBBT_FIELDS \
+	F(checksum, "DBBT checksum", "%08x")		 \
+	F(fingerprint, "DBBT magic fingerprint", "%08x") \
+	F(version, "DBBT version", "%08x") \
+	F(number_bb, "Number of bad blocks", "%u") \
+	F(number_2k_pages_bb, "Number of bad 2k pages", "%u")
+
+struct mx28_field_desc {
+	size_t		offset;
+	char const	*desc;
+	char const	*fmt;
+};
+
+#define F(_attr, _desc, _fmt) \
+	uint32_t	_attr;
+
+struct mx28_fcb_block {
+	FCB_FIELDS
+	uint8_t		pad[376];
+};
+
+struct mx28_dbbt_block {
+	DBBT_FIELDS
+	uint8_t		pad[492];
+};
+
+#undef F
+
+#define F(_attr, _desc, _fmt)						\
+	{								\
+		.offset	=  offsetof(struct mx28_fcb_block, _attr),	\
+		.desc = _desc,						\
+		.fmt = _fmt,						\
+	},
+
+static struct mx28_field_desc const	mx28_fcb_desc[] = {
+	FCB_FIELDS
+};
+
+#undef F
+
+
+#define F(_attr, _desc, _fmt)						\
+	{								\
+		.offset	=  offsetof(struct mx28_dbbt_block, _attr),	\
+		.desc = _desc,						\
+		.fmt = _fmt,						\
+	},
+
+static struct mx28_field_desc const	mx28_dbbt_desc[] = {
+	DBBT_FIELDS
+};
+
+#undef F
+
+static uint32_t boot_crc(void const *buf, size_t len)
+{
+	uint8_t const	*ptr = buf;
+	uint32_t	sum = 0;
+
+	while (len >= sizeof *ptr) {
+		sum += *ptr;
+		++ptr;
+		len -= sizeof *ptr;
+	}
+
+	return sum ^ 0xffffffffu;
+}
+
+struct fcb_page {
+	uint8_t			pad0[12];
+	struct mx28_fcb_block 	b;
+	uint8_t			parity[1036-524];
+	uint8_t			spare[2112 - 1036];
+} __packed;
+
+static int do_fcbinfo(struct command *cmdtp, int argc, char *argv[])
+{
+	char const	*dev;
+	int		fd = -1;
+	int		rc;
+	struct fcb_page	fcb_buf __aligned(32);
+	struct mx28_fcb_block const	*fcb;
+	ssize_t		l;
+	size_t		i;
+
+	BUILD_BUG_ON(offsetof(struct mx28_fcb_block, metadata_bytes) != 60);
+	BUILD_BUG_ON(offsetof(struct mx28_fcb_block, boot_patch) != 96);
+	BUILD_BUG_ON(offsetof(struct mx28_fcb_block, bad_block_marker_byte) != 124);
+	BUILD_BUG_ON(offsetof(struct mx28_fcb_block, bb_marker_physical_offset)
+		     != 132);
+
+	if (argc <= 1)
+		dev = "/dev/nandraw0";
+	else
+		dev = argv[1];
+
+	fd = open(dev, O_RDONLY);
+	if (fd < 0) {
+		perror("open()");
+		rc = COMMAND_ERROR;
+		goto out;
+	}
+
+	l = read(fd, &fcb_buf, sizeof fcb_buf);
+	if (l < 0) {
+		perror("read()");
+		rc = COMMAND_ERROR;
+		goto out;
+	}
+
+	fcb = &fcb_buf.b;
+
+	for (i = 0; i < ARRAY_SIZE(mx28_fcb_desc); ++i) {
+		struct mx28_field_desc const	*desc = &mx28_fcb_desc[i];
+		uint32_t			v;
+
+		memcpy(&v, &((unsigned char *)fcb)[desc->offset], sizeof v);
+		printf("%-40s\t: ", desc->desc);
+		printf(desc->fmt, v);
+		printf("\n");
+	}
+
+	printf("CRC32: %08x/%u\n", boot_crc(&fcb->fingerprint, sizeof *fcb - 4),
+	       sizeof *fcb - 4);
+
+	rc = 0;
+
+out:
+	if (fd >= 0)
+		close(fd);
+
+	return rc;
+}
+
+#undef BIT
+
+#define BIT(v,n)	(((v) >> (n)) & 0x1)
+#define B(n)		(BIT(d,n))
+
+static uint8_t calculate_parity_13_8(uint8_t d)
+{
+        uint8_t p = 0;
+
+	p |= (B(6) ^ B(5) ^ B(3) ^ B(2))        << 0;
+	p |= (B(7) ^ B(5) ^ B(4) ^ B(2) ^ B(1)) << 1;
+	p |= (B(7) ^ B(6) ^ B(5) ^ B(1) ^ B(0)) << 2;
+	p |= (B(7) ^ B(4) ^ B(3) ^ B(0))        << 3;
+	p |= (B(6) ^ B(4) ^ B(3) ^ B(2) ^ B(1) ^ B(0)) << 4;
+	return p;
+}
+
+#undef B
+#undef BIT
+
+static void fill_parity(void *dst_v, void const *src_v, size_t len)
+{
+	uint8_t const	*src = src_v;
+	uint8_t		*dst = dst_v;
+
+	while (len-- > 0)
+		*dst++ = calculate_parity_13_8(*src++);
+}
+
+struct mx28_fcb_block const	fcb_template = {
+	.fingerprint = 0x20424346,
+	.version = 0x01000000,
+	.nand_timing0 = (( 6 << 24) | /* dsample time */
+			 (25 << 16) | /* address setup time */
+			 (60 <<  8) | /* data hold time */
+			 (80 << 0)), /* data setup time */
+	.nand_timing1 = 0x00000000,
+	.page_data_size = 2048,
+	.total_page_size = 2112,
+	.sectors_per_block = 64,
+	.number_of_nands = 1,
+	.ecc_blockN_ecc_type = 4,
+	.ecc_block0_size = 512,
+	.ecc_blockN_size = 512,
+	.ecc_block0_ecc_type = 4,
+	.metadata_bytes = 12,
+	.num_ecc_blocks_per_page = 3,
+	.erase_threshold = 0,
+	.firmware1_sector = 1024*1024 / 2048,
+	.firmware1_num_sector = 384 * 1024/ 2048,
+	.firmware2_sector = (1024 + 512) * 1024 / 2048,
+	.firmware2_num_sector = 384 * 1024/ 2048,
+#if 0
+	.dbbt_start_address = 512 * 1024 / 2048,
+#endif
+	.bad_block_marker_byte = 1999,
+	.bad_block_marker_start_bit = 0,
+	.bb_marker_physical_offset = 2048
+};
+
+static int fill_part_info(char const *part, unsigned int pgsize,
+			  uint32_t *page,
+			  uint32_t *num_pages)
+{
+	struct cdev	*cdev = cdev_by_name(part);
+
+	if (!cdev) {
+		fprintf(stderr,
+			"no information about partition '%s'; assuming defaults\n",
+			part);
+
+		return -1;
+	}
+
+	WARN_ON(cdev->offset % pgsize);
+	WARN_ON(cdev->size % pgsize);
+
+	put_unaligned(cdev->offset / pgsize, page);
+	put_unaligned((cdev->size + pgsize - 1) / pgsize, num_pages);
+
+	return 0;
+}
+
+static int do_fcbinit(struct command *cmdtp, int argc, char *argv[])
+{
+	char const	*dev;
+	int		fd = -1;
+	int		rc;
+	size_t		i;
+
+	struct fcb_page	buf __aligned(32);
+	uint32_t	crc;
+	struct mxs_nand_fcb_params const *fcb_info;
+	struct device_d			*gpmi_dev;
+
+	memset(&buf, 0, sizeof buf);
+	memcpy(&buf.b, &fcb_template, sizeof fcb_template);
+
+	gpmi_dev = get_device_by_name("mxs_nand0");
+	if (gpmi_dev)
+		fcb_info = mxs_nand_get_fcb_params(gpmi_dev);
+	else
+		fcb_info = 0;
+
+	if (!fcb_info) {
+		fprintf(stderr,
+			"NAND driver does not provide FCB information; assuming defaults\n");
+	} else {
+		buf.b.nand_timing0 = fcb_info->timing0;
+		buf.b.nand_timing1 = fcb_info->timing1;
+		buf.b.page_data_size = fcb_info->page_data_size;
+		buf.b.total_page_size = fcb_info->total_page_size;
+		buf.b.sectors_per_block = fcb_info->pages_per_block;
+		buf.b.ecc_block0_ecc_type = fcb_info->ecc_type[0];
+		buf.b.ecc_blockN_ecc_type = fcb_info->ecc_type[1];
+		buf.b.ecc_block0_size = fcb_info->block_size[0];
+		buf.b.ecc_blockN_size = fcb_info->block_size[1];
+		buf.b.num_ecc_blocks_per_page = fcb_info->num_ecc_blocks;
+		buf.b.metadata_bytes = fcb_info->metadata_bytes;
+		buf.b.bad_block_marker_byte = fcb_info->bad_block_bit / 8;
+		buf.b.bad_block_marker_start_bit = fcb_info->bad_block_bit % 8;
+	}
+
+	fill_part_info("bootstream0", buf.b.page_data_size,
+		       &buf.b.firmware1_sector, &buf.b.firmware1_num_sector);
+
+	fill_part_info("bootstream1", buf.b.page_data_size,
+		       &buf.b.firmware2_sector, &buf.b.firmware2_num_sector);
+
+	crc = boot_crc(&buf.b, sizeof buf.b);
+
+	memcpy(&buf.b.checksum, &crc, sizeof crc);
+	fill_parity(&buf.parity[0], &buf.b, sizeof buf.b);
+
+	if (argc <= 1)
+		dev = "/dev/nandraw0";
+	else
+		dev = argv[1];
+
+	fd = open(dev, O_WRONLY);
+	if (fd < 0) {
+		perror("open()");
+		rc = COMMAND_ERROR;
+		goto out;
+	}
+
+	for (i = 0; i < 4; ++i) {
+		ssize_t l;
+
+		printf("writing FCB#%u...", i);
+
+		rc = erase(fd, 64*2112, i * 64 * 2112);
+		if (rc < 0) {
+			perror("erase()");
+			continue;
+		}
+
+		rc = lseek(fd, i * 64 * 2112, SEEK_SET);
+		if (rc < 0) {
+			perror("lseek()");
+			continue;
+		}
+
+		l = write(fd, &buf, sizeof buf);
+		if (l < 0) {
+			perror("write()");
+			continue;
+		}
+		if (l != sizeof buf) {
+			fprintf(stderr,
+				"wrote %zd bytes from %zd requested ones\n",
+				l, sizeof buf);
+			continue;
+		}
+
+		printf(" done\n");
+	}
+
+	rc = 0;
+
+out:
+	if (fd >= 0)
+		close(fd);
+
+	return rc;
+}
+
+static int do_fcb(struct command *cmdtp, int argc, char *argv[])
+{
+	if (argc < 2)
+		fprintf(stderr, "missing command\n");
+	else if (strcmp(argv[1], "init") == 0)
+		return do_fcbinit(cmdtp, argc-1, argv+1);
+	else if (strcmp(argv[1], "dump") == 0)
+		return do_fcbinfo(cmdtp, argc-1, argv+1);
+	else
+		fprintf(stderr, "unsupported command '%s'\n", argv[1]);
+
+	return COMMAND_ERROR_USAGE;
+}
+
+BAREBOX_CMD_HELP_START(fcb)
+BAREBOX_CMD_HELP_USAGE("fcb init|dump [<device>]\n")
+BAREBOX_CMD_HELP_SHORT("FCB related commands\n")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(fcb)
+	.cmd = do_fcb,
+	.usage	=  "FCB related commands",
+	BAREBOX_CMD_HELP(cmd_fcb_help)
+BAREBOX_CMD_END;
+
+static bool ocotp_write(unsigned int reg, uint32_t v)
+{
+	uint32_t	c;
+
+	if (readl(0x8002c000) & ((1<<12) | (1<<9) | (1<<8))) {
+		printk(KERN_WARNING
+		       "OCOTP busy or in error state (%02x <= %08x): %08x\n",
+		       reg, v, readl(0x8002c000));
+		return false;
+	}
+
+	c = readl(0x8002c000);
+	c &= ~(0x3f | (0xffff << 16));
+	c |= reg;
+	c |= 0x3e77 << 16;		/* unlock key */
+
+	writel(c, 0x8002c000);
+	writel(v, 0x8002c010);
+
+	while (readl(0x8002c000) & (1 << 8))
+		;			/* noop */
+
+	udelay(2);
+
+	if (readl(0x8002c000) & (1 << 9)) {
+		printk(KERN_WARNING "OCOTP programming %02x <= %08x failed\n",
+		       reg, v);
+		writel(1 << 9, 0x8002c000 + BIT_CLR);
+		return false;
+	}
+
+	return true;
+}
+
+static bool ocotp_write_data(uint32_t const ocotp_data[],
+			     size_t num_data)
+{
+	static unsigned int const	DATA_OFFSET[] = {
+		0x00, 0x01, 0x02, 0x03,
+		0x15, 0x16
+	};
+
+	unsigned int	old_hclk = imx_get_hclk();
+	unsigned int	old_vddio = readl(0x80044060);
+	int		rc = COMMAND_ERROR;
+	size_t		i;
+
+	BUG_ON(num_data > ARRAY_SIZE(DATA_OFFSET));
+
+	imx_set_hclk(24000000);
+
+	writel(old_vddio & ~0x1fu, 0x80044060); /* set 2.8V VDDIO */
+
+	udelay(1000);
+
+	writel(1u << 13, 0x8002c000 + BIT_SET);
+	while (readl(0x8002c000) & (1 << 8))
+		;			/* noop */
+
+	if (readl(0x8002c000) & ((1<<12) | (1<<9) | (1<<8))) {
+		printk(KERN_WARNING "OCOTP busy or in error state: %08x\n",
+		       readl(0x8002c000));
+		goto out;
+	}
+
+	udelay(2);
+
+	for (i = 0; i < num_data; ++i) {
+		if (!ocotp_write(DATA_OFFSET[i], ocotp_data[i]))
+			break;
+	}
+
+	writel(1u << 13, 0x8002c000 + BIT_SET);
+	udelay(2);
+
+	if (i < num_data)
+		goto out;
+
+
+	rc = 0;
+
+	printk(KERN_INFO "OCOTP initialized\n");
+
+out:
+	writel(old_vddio, 0x80044060); /* set original VDDIO */
+	udelay(1000);
+	imx_set_hclk(old_hclk);
+
+	return rc;
+}
+
+static int do_ocotpinit(struct command *cmdtp, int argc, char *argv[])
+{
+	unsigned char const	*device_id;
+	unsigned char	enetaddr[6];
+	unsigned int	radio_addr;
+	char		*err_ptr;
+	uint32_t	ocotp[6];
+	bool		ignore_radio = getenv_ull("CCU2_IGNORE_RADIO") > 0;
+
+	/* step 1: verify command parameters */
+	if (argc != 4)
+		return COMMAND_ERROR_USAGE;
+
+	if (string_to_ethaddr(argv[1], enetaddr) < 0 ||
+	    !is_valid_ether_addr(enetaddr) ||
+	    is_local_ether_addr(enetaddr)) {
+		printk(KERN_ERR "invalid mac address\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+	device_id = (unsigned char const *)argv[2];
+	if (strlen((char const *)device_id) != 10) {
+		printk(KERN_ERR "invalid device id\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+	radio_addr = simple_strtoul(argv[3], &err_ptr, 16);
+	if (*err_ptr != '\0' || radio_addr > 0xffffff) {
+		printk(KERN_ERR "invalid radio address\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+
+	/* step 2: verify that OCOTP is empty */
+	writel((1u << 12), 0x8002c004);	/* HW_OCOTP_CTRL |= RD_BANK_OPEN */
+
+	/* delay access to OCOTP */
+	while (readl(0x8002c000) & (1u << 8))
+		;			/* noop */
+
+	ocotp[0]  = readl(0x8002c020); /* cust0 */
+	ocotp[1]  = readl(0x8002c030); /* cust1 */
+	ocotp[2]  = readl(0x8002c040); /* cust2 */
+	ocotp[3]  = readl(0x8002c050); /* cust3 */
+	ocotp[4]  = readl(0x8002c170); /* un0 */
+	ocotp[5]  = readl(0x8002c180); /* un1 */
+
+	writel((1u << 12), 0x8002c008);	/* HW_OCOTP_CTRL &= ~RD_BANK_OPEN */
+
+	if (!ignore_radio && (ocotp[4] != 0)) {
+		printk(KERN_ERR "OCOTP for radio already occupied\n");
+		return COMMAND_ERROR;
+	}
+
+	if (ocotp[0] != 0 || ocotp[1] != 0 ||
+	    ocotp[2] != 0 || ocotp[3] != 0) {
+		printk(KERN_ERR "OCOTP already occupied\n");
+		return COMMAND_ERROR;
+	}
+
+	ocotp[0] = ((enetaddr[0]  << 24) |
+		    (enetaddr[1]  << 16) |
+		    (enetaddr[2]  <<  8) |
+		    (enetaddr[3]  <<  0));
+	ocotp[1] = ((enetaddr[4]  << 24) |
+		    (enetaddr[5]  << 16) |
+		    (device_id[0] <<  8) |
+		    (device_id[1] <<  0));
+	ocotp[2] = ((device_id[2] << 24) |
+		    (device_id[3] << 16) |
+		    (device_id[4] <<  8) |
+		    (device_id[5] <<  0));
+	ocotp[3] = ((device_id[6] << 24) |
+		    (device_id[7] << 16) |
+		    (device_id[8] <<  8) |
+		    (device_id[9] <<  0));
+	ocotp[4] = ((((radio_addr >> 16) & 0xffu) << 24) |
+		    (((radio_addr >>  8) & 0xffu) << 16) |
+		    (((radio_addr >>  0) & 0xffu) <<  8));
+
+	return ocotp_write_data(ocotp, ignore_radio ? 4 : 5);
+}
+
+BAREBOX_CMD_HELP_START(ocotpinit)
+BAREBOX_CMD_HELP_USAGE("ocotpinit <mac> <serial[10]> <hex:radio>\n");
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(ocotpinit)
+	.cmd = do_ocotpinit,
+	.usage	=  "initialize OCOTP",
+	BAREBOX_CMD_HELP(cmd_ocotpinit_help)
+BAREBOX_CMD_END;
diff -ruN barebox-2012.02.0/commands/watchdog.c barebox-2012.02.0-ccu2/commands/watchdog.c
--- barebox-2012.02.0/commands/watchdog.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/commands/watchdog.c	2013-01-14 12:46:19.000000000 +0100
@@ -0,0 +1,48 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <common.h>
+#include <command.h>
+
+#include <mach/watchdog.h>
+
+static int do_watchdog(struct command *cmdtp, int argc, char *argv[])
+{
+	int		rc;
+
+	if (argc != 2)
+		return COMMAND_ERROR_USAGE;
+
+	watchdog_prepare();
+
+	if (strcmp(argv[1], "off") == 0)
+		rc = watchdog_off();
+	else
+		rc = watchdog_trigger(simple_strtoul(argv[1], NULL, 10));
+
+	return rc;
+}
+
+BAREBOX_CMD_HELP_START(watchdog)
+BAREBOX_CMD_HELP_USAGE("watchdog off|<delay_ms>")
+BAREBOX_CMD_HELP_SHORT("Disable watchdog resp. trigger it.\n")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(watchdog)
+	.cmd		= do_watchdog,
+	.usage		= "configure watchdog",
+	BAREBOX_CMD_HELP(cmd_watchdog_help)
+BAREBOX_CMD_END
diff -ruN barebox-2012.02.0/common/console.c barebox-2012.02.0-ccu2/common/console.c
--- barebox-2012.02.0/common/console.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/common/console.c	2013-01-14 12:46:19.000000000 +0100
@@ -40,8 +40,9 @@
 LIST_HEAD(console_list);
 EXPORT_SYMBOL(console_list);
 
-#define CONSOLE_UNINITIALIZED	0
-#define CONSOLE_INIT_FULL	1
+#define CONSOLE_UNINITIALIZED		0
+#define CONSOLE_INITIALIZED_BUFFER	1
+#define CONSOLE_INIT_FULL		2
 
 static int initialized = 0;
 
@@ -109,17 +110,25 @@
 	return 0;
 }
 
-static struct kfifo *console_input_buffer;
-static struct kfifo *console_output_buffer;
+#define CONSOLE_BUFFER_SIZE	1024
 
-static int getc_buffer_flush(void)
+static char console_input_buffer[CONSOLE_BUFFER_SIZE];
+static char console_output_buffer[CONSOLE_BUFFER_SIZE];
+
+static struct kfifo __console_input_fifo;
+static struct kfifo __console_output_fifo;
+static struct kfifo *console_input_fifo = &__console_input_fifo;
+static struct kfifo *console_output_fifo = &__console_output_fifo;
+
+static void console_init_early(void)
 {
-	console_input_buffer = kfifo_alloc(1024);
-	console_output_buffer = kfifo_alloc(1024);
-	return 0;
-}
+	kfifo_init(console_input_fifo, console_input_buffer,
+			CONSOLE_BUFFER_SIZE);
+	kfifo_init(console_output_fifo, console_output_buffer,
+			CONSOLE_BUFFER_SIZE);
 
-postcore_initcall(getc_buffer_flush);
+	initialized = CONSOLE_INITIALIZED_BUFFER;
+}
 
 int console_register(struct console_device *newcdev)
 {
@@ -127,6 +136,9 @@
 	int first = 0;
 	char ch;
 
+	if (initialized == CONSOLE_UNINITIALIZED)
+		console_init_early();
+
 	dev->id = -1;
 	strcpy(dev->name, "cs");
 	dev->type_data = newcdev;
@@ -145,6 +157,7 @@
 #ifdef CONFIG_CONSOLE_ACTIVATE_ALL
 	dev_set_param(dev, "active", "ioe");
 #endif
+	dev_set_param(dev, "active", "ioe");
 #ifdef CONFIG_CONSOLE_ACTIVATE_FIRST
 	if (list_empty(&console_list)) {
 		first = 1;
@@ -154,8 +167,7 @@
 
 	list_add_tail(&newcdev->list, &console_list);
 
-
-	while (kfifo_getc(console_output_buffer, &ch) == 0)
+	while (kfifo_getc(console_output_fifo, &ch) == 0)
 		console_putc(CONSOLE_STDOUT, ch);
 	if (first)
 		barebox_banner();
@@ -226,16 +238,16 @@
 	start = get_time_ns();
 	while (1) {
 		if (tstc_raw()) {
-			kfifo_putc(console_input_buffer, getc_raw());
+			kfifo_putc(console_input_fifo, getc_raw());
 
 			start = get_time_ns();
 		}
 		if (is_timeout(start, 100 * USECOND) &&
-				kfifo_len(console_input_buffer))
+				kfifo_len(console_input_fifo))
 			break;
 	}
 
-	kfifo_getc(console_input_buffer, &ch);
+	kfifo_getc(console_input_fifo, &ch);
 	return ch;
 }
 EXPORT_SYMBOL(getc);
@@ -252,7 +264,7 @@
 
 int tstc(void)
 {
-	return kfifo_len(console_input_buffer) || tstc_raw();
+	return kfifo_len(console_input_fifo) || tstc_raw();
 }
 EXPORT_SYMBOL(tstc);
 
@@ -263,7 +275,11 @@
 
 	switch (init) {
 	case CONSOLE_UNINITIALIZED:
-		kfifo_putc(console_output_buffer, c);
+		console_init_early();
+		/* fall through */
+
+	case CONSOLE_INITIALIZED_BUFFER:
+		kfifo_putc(console_output_fifo, c);
 		return;
 
 	case CONSOLE_INIT_FULL:
diff -ruN barebox-2012.02.0/common/dummy_malloc.c barebox-2012.02.0-ccu2/common/dummy_malloc.c
--- barebox-2012.02.0/common/dummy_malloc.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/common/dummy_malloc.c	2013-01-14 12:46:19.000000000 +0100
@@ -24,3 +24,15 @@
 	BUG();
 }
 
+void *calloc(size_t n, size_t elem_size)
+{
+	size_t size = elem_size * n;
+	void *r = malloc(size);
+
+	if (!r)
+		return r;
+
+	memset(r, 0x0, size);
+
+	return r;
+}
diff -ruN barebox-2012.02.0/common/.gitignore barebox-2012.02.0-ccu2/common/.gitignore
--- barebox-2012.02.0/common/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/common/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-module.lds
diff -ruN barebox-2012.02.0/common/Kconfig barebox-2012.02.0-ccu2/common/Kconfig
--- barebox-2012.02.0/common/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/common/Kconfig	2013-01-14 12:46:19.000000000 +0100
@@ -40,6 +40,9 @@
 config HAVE_NOSHELL
 	bool
 
+config FILETYPE
+	bool
+
 menu "General Settings              "
 
 config LOCALVERSION
@@ -74,6 +77,10 @@
 config BOARDINFO
 	string
 
+config BANNER
+	bool "display banner"
+	default y
+
 config ENVIRONMENT_VARIABLES
 	bool "environment variables support"
 
@@ -97,6 +104,22 @@
 	help
 	  The Address barebox gets linked at.
 
+config BAREBOX_MAX_IMAGE_SIZE
+	prompt "Maximum size of barebox"
+	hex
+	default 0xffffffff
+	help
+	  Define the maximum size of barebox
+
+config BAREBOX_MAX_BARE_INIT_SIZE
+	prompt "Maximum bare_init size"
+	hex
+	default 0xffffffff
+	help
+	  Define the maximum size of bare_init
+	  this will allow your bare_init will fit in SRAM as example
+	  ARCH can overwrite it via ARCH_BAREBOX_MAX_BARE_INIT_SIZE
+
 config HAVE_CONFIGURABLE_MEMORY_LAYOUT
 	bool
 
@@ -251,6 +274,7 @@
 		bool "hush parser"
 		select ENVIRONMENT_VARIABLES
 		select COMMAND_SUPPORT
+		select PARAMETER
 		help
 		  Enable hush support. This is the most advanced shell available
 		  for barebox.
@@ -259,6 +283,7 @@
 		bool "Simple parser"
 		select ENVIRONMENT_VARIABLES
 		select COMMAND_SUPPORT
+		select PARAMETER
 		help
 		  simple shell. No if/then, no return values from commands, no loops
 
@@ -422,6 +447,7 @@
 config DEFAULT_ENVIRONMENT
 	bool
 	default y
+	select CMD_LOADENV
 	prompt "Compile in default environment"
 	help
 	  Enabling this option will give you a default environment when
diff -ruN barebox-2012.02.0/common/Makefile barebox-2012.02.0-ccu2/common/Makefile
--- barebox-2012.02.0/common/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/common/Makefile	2013-01-14 12:46:19.000000000 +0100
@@ -17,7 +17,7 @@
 obj-$(CONFIG_MALLOC_TLSF) += tlsf.o
 obj-$(CONFIG_MALLOC_DUMMY) += dummy_malloc.o
 obj-y += clock.o
-obj-y += version.o
+obj-$(CONFIG_BANNER) += version.o
 obj-$(CONFIG_COMMAND_SUPPORT) += command.o
 obj-$(CONFIG_CONSOLE_FULL) += console.o
 obj-$(CONFIG_CONSOLE_SIMPLE) += console_simple.o
@@ -28,7 +28,7 @@
 obj-y += startup.o
 obj-y += misc.o
 obj-y += memsize.o
-obj-y += filetype.o
+obj-$(CONFIG_FILETYPE) += filetype.o
 obj-y += resource.o
 obj-$(CONFIG_MENU) += menu.o
 obj-$(CONFIG_PASSWORD) += password.o
diff -ruN barebox-2012.02.0/common/password.c barebox-2012.02.0-ccu2/common/password.c
--- barebox-2012.02.0/common/password.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/common/password.c	2013-01-14 12:46:19.000000000 +0100
@@ -29,6 +29,9 @@
 #include <xfuncs.h>
 #include <clock.h>
 
+#define SALT		"\"XlT&[@l-`;61ZRm5-hSDyB,87hhqB6K"
+#define SALT_LEN	(sizeof SALT - 1)
+
 #if defined(CONFIG_PASSWD_SUM_MD5)
 #define PASSWD_SUM "md5"
 #elif defined(CONFIG_PASSWD_SUM_SHA1)
@@ -52,6 +55,7 @@
 	do {
 		if (tstc()) {
 			ch = getc();
+			start = get_time_ns();
 
 			switch (ch) {
 			case '\r':
@@ -69,11 +73,14 @@
 			case CTL_CH('h'):
 			case KEY_DEL7:
 			case KEY_DEL:
-				if (flags & STAR && pos > 0)
-					puts("\b \b");
-				*buf = '\0';
-				buf--;
-				pos--;
+				if (pos > 0) {
+					if (flags & STAR)
+						puts("\b \b");
+
+					*buf = '\0';
+					buf--;
+					pos--;
+				}
 				continue;
 			default:
 				if (pos < length - 1) {
@@ -152,6 +159,16 @@
 	if (fd < 0)
 		return fd;
 
+	ret = read(fd, sum, SALT_LEN);
+	if (ret < 0)
+		goto exit;
+	if (ret != SALT_LEN) {
+		ret = -EIO;
+		goto exit;
+	}
+
+	sum += ret;
+
 	do {
 		ret = read(fd, &c, sizeof(char));
 
@@ -201,6 +218,15 @@
 	if (fd < 0)
 		return fd;
 
+	ret = write(fd, SALT, SALT_LEN);
+	if (ret < 0)
+		goto exit;
+
+	if (ret != SALT_LEN) {
+		ret = -EIO;
+		goto exit;
+	}
+
 	do {
 		c = to_hexa(*sum >> 4 & 0xf);
 
@@ -220,6 +246,8 @@
 		length--;
 	} while(length > 0);
 
+	write(fd, "\n", 1);
+
 	ret = 0;
 
 exit:
@@ -243,25 +271,25 @@
 	if (!passwd1_sum)
 		return -ENOMEM;
 
-	passwd2_sum = calloc(d->length, sizeof(unsigned char));
+	passwd2_sum = calloc(d->length + SALT_LEN, sizeof(unsigned char));
 
 	if (!passwd2_sum) {
 		ret = -ENOMEM;
 		goto err1;
 	}
 
+	ret = read_passwd(passwd2_sum, d->length);
+	if (ret < 0)
+		goto err2;
+
 	d->init(d);
 
+	d->update(d, passwd2_sum, SALT_LEN);
 	d->update(d, passwd, length);
 
 	d->final(d, passwd1_sum);
 
-	ret = read_passwd(passwd2_sum, d->length);
-
-	if (ret < 0)
-		goto err2;
-
-	if (strncmp(passwd1_sum, passwd2_sum, d->length) == 0)
+	if (memcmp(passwd1_sum, passwd2_sum + SALT_LEN, d->length) == 0)
 		ret = 1;
 
 err2:
@@ -281,13 +309,14 @@
 
 	d = digest_get_by_name(PASSWD_SUM);
 
-	passwd_sum = calloc(d->length, sizeof(unsigned char));
+	passwd_sum = calloc(d->length + SALT_LEN, sizeof(unsigned char));
 
 	if (!passwd_sum)
 		return -ENOMEM;
 
 	d->init(d);
 
+	d->update(d, SALT, SALT_LEN);
 	d->update(d, passwd, length);
 
 	d->final(d, passwd_sum);
diff -ruN barebox-2012.02.0/common/startup.c barebox-2012.02.0-ccu2/common/startup.c
--- barebox-2012.02.0/common/startup.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/common/startup.c	2013-01-14 12:46:19.000000000 +0100
@@ -121,16 +121,12 @@
 
 	for (initcall = __barebox_initcalls_start;
 			initcall < __barebox_initcalls_end; initcall++) {
-		PUTS_LL("<<");
-		PUTHEX_LL(*initcall);
+		debug("initcall-> %pS\n", *initcall);
 		result = (*initcall)();
-		PUTC_LL('>');
-		if (result)
-			hang();
-		PUTS_LL(">\n");
+		debug("initcall<- %pS (%d)\n", *initcall, result);
 	}
 
-	PUTS_LL("initcalls done\n");
+	debug("initcalls done\n");
 
 	display_meminfo();
 
diff -ruN barebox-2012.02.0/defaultenv/bin/boot barebox-2012.02.0-ccu2/defaultenv/bin/boot
--- barebox-2012.02.0/defaultenv/bin/boot	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/defaultenv/bin/boot	2013-01-14 12:46:19.000000000 +0100
@@ -1,5 +1,8 @@
 #!/bin/sh
 
+#nfsopts=vers=2,udp,rsize=4096,wsize=4096
+nfsopts=v3,nolock,tcp
+
 . /env/config
 
 if [ x$kernel_loc = xnet ]; then
@@ -23,6 +26,13 @@
 	kernel_loc=disk
 fi
 
+if [ x$kernel_loc = xnfs ] || [ x$kernel_loc = xtftp ]; then
+    if [ x$ip = xdhcp ]; then
+	# initializes env
+	dhcp && . /env/config
+    fi
+fi
+
 if [ x$ip = xdhcp ]; then
 	bootargs="$bootargs ip=dhcp"
 elif [ x$ip = xnone ]; then
@@ -33,7 +43,7 @@
 
 
 if [ x$rootfs_loc = xnet ]; then
-	bootargs="$bootargs root=/dev/nfs nfsroot=$nfsroot,v3,tcp noinitrd"
+	bootargs="$bootargs root=/dev/nfs nfsroot=$nfsroot,$nfsopts ro noinitrd"
 elif [ x$rootfs_loc = xdisk ]; then
 	bootargs="$bootargs root=/dev/$rootfs_part_linux_dev rootfstype=$rootfs_type noinitrd rootwait"
 elif [ x$rootfs_loc = xinitrd ]; then
@@ -73,9 +83,6 @@
 fi
 
 if [ x$kernel_loc = xnfs -o x$kernel_loc = xtftp ]; then
-	if [ x$ip = xdhcp ]; then
-		dhcp
-	fi
 	kdev=/image
 	$kernel_loc $kernelimage $kdev || exit 1
 elif [ x$kernel_loc = xnor ]; then
@@ -89,6 +96,9 @@
 	exit 1
 fi
 
-echo "booting kernel from $kdev"
+if [ -f /env/bin/boot_board ]; then
+    . /env/bin/boot_board
+fi
 
+echo "booting kernel from $kdev"
 bootm $bootm_opt $kdev
diff -ruN barebox-2012.02.0/defaultenv/bin/update barebox-2012.02.0-ccu2/defaultenv/bin/update
--- barebox-2012.02.0/defaultenv/bin/update	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/defaultenv/bin/update	2013-01-14 12:46:19.000000000 +0100
@@ -63,7 +63,7 @@
 	exit 1
 fi
 
-if [ x${mode} != xtftp -a x${mode} != xxmodem ] ; then
+if [ x${mode} != xtftp -a x${mode} != xxmodem -a x${mode} != xnfs ]; then
 	echo "unsupported mode ${mode}."
 	. /env/bin/_update_help
 	exit 1
diff -ruN barebox-2012.02.0/defaultenv/bin/_update barebox-2012.02.0-ccu2/defaultenv/bin/_update
--- barebox-2012.02.0/defaultenv/bin/_update	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/defaultenv/bin/_update	2013-01-14 12:46:19.000000000 +0100
@@ -10,7 +10,7 @@
 	exit 1
 fi
 
-if [ x$mode = xtftp ]; then
+if [ x$mode = xtftp -o x$mode = xnfs ]; then
 	if [ x$ip = xdhcp ]; then
 		dhcp
 	fi
@@ -20,6 +20,7 @@
 		echo "Server did not reply! Update aborted."
 		exit 1
 	fi
+	load=$mode
 fi
 
 if [ x$mode = xxmodem ]; then
@@ -28,6 +29,7 @@
 		echo "loadb failed or cancelled! Update aborted."
 		exit 1
 	fi
+	load="cp -v"
 fi
 
 unprotect $part
@@ -40,11 +42,6 @@
 echo
 echo "flashing $image to $part"
 echo
-
-if [ x$mode = xtftp ]; then
-	tftp $image $part || exit 1
-else
-	cp -v $image $part || exit 1
-fi
+$load $image $part || exit 1
 
 protect $part
diff -ruN barebox-2012.02.0/defaultenv/bin/_update_help barebox-2012.02.0-ccu2/defaultenv/bin/_update_help
--- barebox-2012.02.0/defaultenv/bin/_update_help	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/defaultenv/bin/_update_help	2013-01-14 12:46:19.000000000 +0100
@@ -7,8 +7,8 @@
 echo " -c     to check the crc32 for the image and flashed one"
 echo ""
 echo "default mode is tftp"
-echo "type update -t kernel -d <nor|nand|disk> [-m tftp|xmodem] [-f imagename] to update kernel into flash"
-echo "type update -t rootfs -d <nor|nand> [-m tftp|xmodem] [-f imagename] to update rootfs into flash"
-echo "type update -t barebox -d <nor|nand> [-m tftp|xmodem] [-f imagename] to update barebox into flash"
-echo "type update -t bareboxenv -d <nor|nand> [-m tftp|xmodem] [-f imagename] to update bareboxenv into flash"
-echo "type update -t xload -d <nor|nand> [-m tftp|xmodem] [-f imagename] to update xload into flash"
+echo "type update -t kernel -d <nor|nand|disk> [-m tftp|xmodem|nfs] [-f imagename] to update kernel into flash"
+echo "type update -t rootfs -d <nor|nand> [-m tftp|xmodem|nfs] [-f imagename] to update rootfs into flash"
+echo "type update -t barebox -d <nor|nand> [-m tftp|xmodem|nfs] [-f imagename] to update barebox into flash"
+echo "type update -t bareboxenv -d <nor|nand> [-m tftp|xmodem|nfs] [-f imagename] to update bareboxenv into flash"
+echo "type update -t xload -d <nor|nand> [-m tftp|xmodem|nfs] [-f imagename] to update xload into flash"
diff -ruN barebox-2012.02.0/Documentation/barebox-main.dox barebox-2012.02.0-ccu2/Documentation/barebox-main.dox
--- barebox-2012.02.0/Documentation/barebox-main.dox	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/Documentation/barebox-main.dox	2013-01-14 12:46:19.000000000 +0100
@@ -1,13 +1,13 @@
 /** @mainpage Barebox
 
-Barebox is a bootloader that initializes a hardware and boots Linux and
+Barebox is a bootloader that initializes hardware and boots Linux and
 maybe other operating systems or bare metal code on a variety of
-processors. It was initialy derived from U-Boot and captures up with
-several of it's ideas, so users being familiar with U-Boot should come
-into production quickly with Barebox.
+processors. It was initially derived from U-Boot and retains several of
+U-Boot's ideas, so users familiar with U-Boot should come into
+production quickly with Barebox.
 
 However, as the Barebox developers are highly addicted to the Linux
-kernel, it's coding style and code quality, we try to stick as closely
+kernel, its coding style and code quality, we try to stick as closely
 as possible to the methodologies and techniques developed in Linux. In
 addition we have a strong background in POSIX, so you'll find several
 good old Unix traditions realized in Barebox as well.
@@ -26,7 +26,7 @@
 - <b>Environment Filesystem:</b><br>
   In contrast to U-Boot, Barebox doesn't misuse the environment for
   scripting. If you start the bootloader, it gives you a shell and
-  something that looks like a filesystem. In fact it isn't: it is a very
+  something that looks like a filesystem. In fact it isn't; it is a very
   simple ar archive being extracted from flash into a ramdisk with 'loadenv'
   and stored back with 'saveenv'.
 
@@ -41,7 +41,7 @@
   if they have the same name.
 
 - <b>Clocksource:</b><br>
-  We use the clocksource API knwon from Linux.
+  We use the standard clocksource API from Linux.
 
 - <b>Kconfig/Kbuild:</b><br>
   This gives us parallel builds and removes the need for lots of ifdefs.
@@ -54,7 +54,7 @@
   to simulate devices.
 
 - <b>Device Parameters:</b><br>
-  There is a parameter model in @a Barebox: each device can specify it's
+  There is a parameter model in @a Barebox: each device can specify its
   own parameters, which do exist for every instance. Parameters can be
   changed on the command line with \<devid\>.\<param\>="...". For
   example, if you want to access the IPv4 address for eth0, this is done
diff -ruN barebox-2012.02.0/Documentation/first_steps.dox barebox-2012.02.0-ccu2/Documentation/first_steps.dox
--- barebox-2012.02.0/Documentation/first_steps.dox	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/Documentation/first_steps.dox	2013-01-14 12:46:19.000000000 +0100
@@ -3,12 +3,12 @@
 <i>This section demonstrates the first steps with the 'sandbox'
 platform. </i>
 
-@a barebox usually needs an environment for storing it's configuration.
-You can generate an environment using the example-environment contained
-in arch/sanbox/board/env:
+@a barebox usually needs an environment for storing its configuration.
+You can generate an environment using the example environment contained
+in arch/sandbox/board/env:
 
 @code
-# ./scripts/bareboxenv -s -p 0x10000 arch/sanbox/board/env/ env.bin
+# ./scripts/bareboxenv -s -p 0x10000 arch/sandbox/board/env/ env.bin
 @endcode
 
 To get some files to play with you can generate a cramfs image:
diff -ruN barebox-2012.02.0/Documentation/.gitignore barebox-2012.02.0-ccu2/Documentation/.gitignore
--- barebox-2012.02.0/Documentation/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/Documentation/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-html
diff -ruN barebox-2012.02.0/drivers/mci/Kconfig barebox-2012.02.0-ccu2/drivers/mci/Kconfig
--- barebox-2012.02.0/drivers/mci/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mci/Kconfig	2013-01-14 12:46:35.000000000 +0100
@@ -69,8 +69,8 @@
 	bool "OMAP HSMMC"
 	depends on ARCH_OMAP4 || ARCH_OMAP3
 	help
-	  Enable this entry to add support to read and write SD cards on a
-	  OMAP4 based system.
+	  Enable this entry to add support to read and write SD cards on
+	  both OMAP3 and OMAP4 based systems.
 
 config MCI_PXA
 	bool "PXA"
diff -ruN barebox-2012.02.0/drivers/mci/mci-core.c barebox-2012.02.0-ccu2/drivers/mci/mci-core.c
--- barebox-2012.02.0/drivers/mci/mci-core.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mci/mci-core.c	2013-01-14 12:46:35.000000000 +0100
@@ -1432,11 +1432,11 @@
  * @param host mci_host for this MCI device
  * @return 0 on success
  */
-int mci_register(struct mci_host *host)
+int mci_register(struct mci_host *host, int id)
 {
 	struct device_d *mci_dev = xzalloc(sizeof(struct device_d));
 
-	mci_dev->id = -1;
+	mci_dev->id = id;
 	strcpy(mci_dev->name, mci_driver.name);
 	mci_dev->platform_data = (void*)host;
 	dev_add_child(host->hw_dev, mci_dev);
diff -ruN barebox-2012.02.0/drivers/mci/mci_spi.c barebox-2012.02.0-ccu2/drivers/mci/mci_spi.c
--- barebox-2012.02.0/drivers/mci/mci_spi.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mci/mci_spi.c	2013-01-14 12:46:35.000000000 +0100
@@ -387,6 +387,7 @@
 	host->mci.send_cmd = mmc_spi_request;
 	host->mci.set_ios = mmc_spi_set_ios;
 	host->mci.init = mmc_spi_init;
+	host->mci.hw_dev = dev;
 
 	host->dev = dev;
 	host->spi = spi;
diff -ruN barebox-2012.02.0/drivers/mci/mxs.c barebox-2012.02.0-ccu2/drivers/mci/mxs.c
--- barebox-2012.02.0/drivers/mci/mxs.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mci/mxs.c	2013-01-14 12:46:35.000000000 +0100
@@ -731,6 +731,7 @@
 		return 0;
 	}
 #endif
+
 	if (pd->f_min == 0) {
 		host->f_min = mxs_mci_get_unit_clock(mxs_mci) / 254 / 256;
 		pr_debug("Min. frequency is %u Hz\n", host->f_min);
@@ -753,7 +754,7 @@
 	mxs_mci->f_max = host->f_max;
 #endif
 
-	return mci_register(host);
+	return mci_register(host, mxs_mci->index);
 }
 
 static struct driver_d mxs_mci_driver = {
diff -ruN barebox-2012.02.0/drivers/mtd/core.c barebox-2012.02.0-ccu2/drivers/mtd/core.c
--- barebox-2012.02.0/drivers/mtd/core.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/core.c	2013-01-14 12:46:35.000000000 +0100
@@ -173,6 +173,10 @@
 	struct mtd_info *mtd = cdev->priv;
 	struct erase_info erase;
 	int ret;
+	char const *tmp = dev_get_param(cdev->dev, "num_erase_bad");
+	unsigned int num_erase_bad = tmp ? simple_strtoul(tmp, NULL, 10) : 0;
+
+	dev_set_param(cdev->dev, "num_erase_bad", NULL);
 
 	memset(&erase, 0, sizeof(erase));
 	erase.mtd = mtd;
@@ -183,6 +187,12 @@
 		dev_dbg(cdev->dev, "erase %d %d\n", erase.addr, erase.len);
 
 		ret = mtd->block_isbad(mtd, erase.addr);
+		if (ret > 0 && num_erase_bad > 0) {
+			erase.num_erase_bad = 1;
+			--num_erase_bad;
+			ret = 0;
+		}
+
 		if (ret > 0) {
 			printf("Skipping bad block at 0x%08x\n", erase.addr);
 		} else {
@@ -227,14 +237,18 @@
 	mtd->cdev.dev = &mtd->class_dev;
 	mtd->cdev.mtd = mtd;
 
-	sprintf(str, "%u", mtd->size);
-	dev_add_param_fixed(&mtd->class_dev, "size", str);
-	sprintf(str, "%u", mtd->erasesize);
-	dev_add_param_fixed(&mtd->class_dev, "erasesize", str);
-	sprintf(str, "%u", mtd->writesize);
-	dev_add_param_fixed(&mtd->class_dev, "writesize", str);
-	sprintf(str, "%u", mtd->oobsize);
-	dev_add_param_fixed(&mtd->class_dev, "oobsize", str);
+	if (IS_ENABLED(CONFIG_PARAMETER)) {
+		sprintf(str, "%u", mtd->size);
+		dev_add_param_fixed(&mtd->class_dev, "size", str);
+		sprintf(str, "%u", mtd->erasesize);
+		dev_add_param_fixed(&mtd->class_dev, "erasesize", str);
+		sprintf(str, "%u", mtd->writesize);
+		dev_add_param_fixed(&mtd->class_dev, "writesize", str);
+		sprintf(str, "%u", mtd->oobsize);
+		dev_add_param_fixed(&mtd->class_dev, "oobsize", str);
+	}
+
+	dev_add_param(&mtd->class_dev, "num_erase_bad", NULL, NULL, 0);
 
 	devfs_create(&mtd->cdev);
 
diff -ruN barebox-2012.02.0/drivers/mtd/nand/atmel_nand.c barebox-2012.02.0-ccu2/drivers/mtd/nand/atmel_nand.c
--- barebox-2012.02.0/drivers/mtd/nand/atmel_nand.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/nand/atmel_nand.c	2013-01-14 12:46:35.000000000 +0100
@@ -374,7 +374,8 @@
 
 	nand_chip->ecc.mode = NAND_ECC_SOFT;
 
-	if (pdata->ecc_mode == NAND_ECC_HW) {
+	if (IS_ENABLED(CONFIG_NAND_ECC_HW) &&
+	    pdata->ecc_mode == NAND_ECC_HW) {
 		host->ecc = dev_request_mem_region(dev, 1);
 
 		if (!host->ecc)
@@ -412,7 +413,8 @@
 		goto err_scan_ident;
 	}
 
-	if (nand_chip->ecc.mode == NAND_ECC_HW) {
+	if (IS_ENABLED(CONFIG_NAND_ECC_HW) &&
+	    nand_chip->ecc.mode == NAND_ECC_HW) {
 		/* ECC is calculated for the whole page (1 step) */
 		nand_chip->ecc.size = mtd->writesize;
 
diff -ruN barebox-2012.02.0/drivers/mtd/nand/Kconfig barebox-2012.02.0-ccu2/drivers/mtd/nand/Kconfig
--- barebox-2012.02.0/drivers/mtd/nand/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/nand/Kconfig	2013-01-14 12:46:35.000000000 +0100
@@ -53,6 +53,12 @@
 	prompt "i.MX NAND driver"
 	depends on ARCH_IMX
 
+config NAND_MXS
+	bool
+	prompt "i.MX28 NAND driver"
+	depends on ARCH_MXS
+	select MX28_DMA
+
 config NAND_OMAP_GPMC
 	tristate "NAND Flash Support for GPMC based OMAP platforms"
 	depends on OMAP_GPMC
diff -ruN barebox-2012.02.0/drivers/mtd/nand/Makefile barebox-2012.02.0-ccu2/drivers/mtd/nand/Makefile
--- barebox-2012.02.0/drivers/mtd/nand/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/nand/Makefile	2013-01-14 12:46:35.000000000 +0100
@@ -12,6 +12,7 @@
 obj-$(CONFIG_MTD_NAND_DISKONCHIP)	+= diskonchip.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
 obj-$(CONFIG_NAND_IMX)			+= nand_imx.o
+obj-$(CONFIG_NAND_MXS)			+= nand_mxs.o
 obj-$(CONFIG_NAND_OMAP_GPMC)		+= nand_omap_gpmc.o nand_omap_bch_decoder.o
 obj-$(CONFIG_NAND_ATMEL)		+= atmel_nand.o
 obj-$(CONFIG_NAND_S3C24XX)		+= nand_s3c24xx.o
diff -ruN barebox-2012.02.0/drivers/mtd/nand/nand-bb.c barebox-2012.02.0-ccu2/drivers/mtd/nand/nand-bb.c
--- barebox-2012.02.0/drivers/mtd/nand/nand-bb.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/nand/nand-bb.c	2013-01-14 12:46:35.000000000 +0100
@@ -264,7 +264,7 @@
  * @param[in] name Partition name (can be obtained with devinfo command)
  * @return The device representing the new partition.
  */
-int dev_add_bb_dev(char *path, const char *name)
+int dev_add_bb_dev(char const *path, const char *name)
 {
 	struct nand_bb *bb;
 	int ret = -ENOMEM;
diff -ruN barebox-2012.02.0/drivers/mtd/nand/nand_mxs.c barebox-2012.02.0-ccu2/drivers/mtd/nand/nand_mxs.c
--- barebox-2012.02.0/drivers/mtd/nand/nand_mxs.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/nand/nand_mxs.c	2013-01-14 12:46:35.000000000 +0100
@@ -0,0 +1,1307 @@
+/*
+ * Freescale i.MX28 NAND flash driver
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Freescale GPMI NFC NAND Flash Driver
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 Embedded Alley Solutions, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <asm/mmu.h>
+#include <mach/generic.h>
+#include <mach/clock.h>
+#include <mach/imx-regs.h>
+#include <mach/dma.h>
+#include <mach/gpmi.h>
+#include <mach/regs-bch.h>
+#include <mach/regs-gpmi.h>
+#include <mach/regs-apbh.h>
+
+#define	MXS_NAND_DMA_DESCRIPTOR_COUNT		4
+
+#define	MXS_NAND_CHUNK_DATA_CHUNK_SIZE		512
+#define	MXS_NAND_METADATA_SIZE			12
+
+#define	MXS_NAND_COMMAND_BUFFER_SIZE		32
+
+#define	MXS_NAND_BCH_TIMEOUT			10000
+
+struct mxs_nand_info {
+	struct device_d		*dev;
+	struct nand_chip	nand;
+	struct mtd_info		mtd;
+
+	struct mx28_gpmi_regs	*gpmi_regs;
+	struct mxs_nand_fcb_params	fcb;
+
+	int		cur_chip;
+
+	uint32_t	cmd_queue_len;
+
+	uint8_t		*cmd_buf;
+	uint8_t		*data_buf;
+	uint8_t		*oob_buf;
+
+	uint8_t		marking_block_bad;
+	uint8_t		raw_oob_mode;
+
+	unsigned int	timings[2];
+
+	/* Functions with altered behaviour */
+	int		(*hooked_read_oob)(struct mtd_info *mtd,
+				loff_t from, struct mtd_oob_ops *ops);
+	int		(*hooked_write_oob)(struct mtd_info *mtd,
+				loff_t to, struct mtd_oob_ops *ops);
+	int		(*hooked_block_markbad)(struct mtd_info *mtd,
+				loff_t ofs);
+
+	/* DMA descriptors */
+	struct mxs_dma_desc	**desc;
+	uint32_t		desc_index;
+};
+
+static struct nand_ecclayout fake_ecc_layout;
+
+static void mxs_nand_dma_clean(void *addr, size_t len)
+{
+	dma_clean_range(virt_to_phys(addr), virt_to_phys(addr + len));
+}
+
+static void mxs_nand_dma_flush(void *addr, size_t len)
+{
+	dma_flush_range(virt_to_phys(addr), virt_to_phys(addr + len));
+}
+
+static void mxs_nand_dma_inv(void *addr, size_t len)
+{
+	dma_inv_range(virt_to_phys(addr), virt_to_phys(addr + len));
+}
+
+static void mxs_nand_dump_gpmi(struct mxs_nand_info const *info,
+			       char const *prefix)
+{
+	if (1)
+	printk(KERN_DEBUG
+	       "%sCTRL=[%08x,%08x], ECC=[%08x,%u], COMPARE=%08x, ADDR=[%08x,%08x], TIMING=[%08x,%08x], STAT=[%08x,%08x]\n",
+	       prefix,
+	       readl(&info->gpmi_regs->hw_gpmi_ctrl0),
+	       readl(&info->gpmi_regs->hw_gpmi_ctrl1),
+	       readl(&info->gpmi_regs->hw_gpmi_eccctrl),
+	       readl(&info->gpmi_regs->hw_gpmi_ecccount),
+	       readl(&info->gpmi_regs->hw_gpmi_compare),
+	       readl(&info->gpmi_regs->hw_gpmi_payload),
+	       readl(&info->gpmi_regs->hw_gpmi_auxiliary),
+	       readl(&info->gpmi_regs->hw_gpmi_timing0),
+	       readl(&info->gpmi_regs->hw_gpmi_timing1),
+	       readl(&info->gpmi_regs->hw_gpmi_stat),
+	       readl(&info->gpmi_regs->hw_gpmi_debug));
+}
+
+static struct mxs_dma_desc *mxs_nand_get_dma_desc(struct mxs_nand_info *info)
+{
+	struct mxs_dma_desc *desc;
+
+	if (info->desc_index >= MXS_NAND_DMA_DESCRIPTOR_COUNT) {
+		printf("MXS NAND: Too many DMA descriptors requested\n");
+		return NULL;
+	}
+
+	desc = info->desc[info->desc_index];
+	info->desc_index++;
+
+	return desc;
+}
+
+static void mxs_nand_return_dma_descs(struct mxs_nand_info *info)
+{
+	int i;
+	struct mxs_dma_desc *desc;
+
+	for (i = 0; i < info->desc_index; i++) {
+		desc = info->desc[i];
+		memset(desc, 0, sizeof(struct mxs_dma_desc));
+		desc->address = virt_to_phys(desc);
+	}
+
+	info->desc_index = 0;
+}
+
+static uint32_t mxs_nand_ecc_chunk_cnt(uint32_t page_data_size)
+{
+	return page_data_size / MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
+}
+
+static uint32_t mxs_nand_ecc_size_in_bits(uint32_t ecc_strength)
+{
+	return ecc_strength * 13;
+}
+
+static uint32_t mxs_nand_aux_status_offset(void)
+{
+	return (MXS_NAND_METADATA_SIZE + 0x3) & ~0x3;
+}
+
+static inline uint32_t mxs_nand_get_ecc_strength(uint32_t page_data_size,
+						uint32_t page_oob_size)
+{
+	if (page_data_size == 2048)
+		return 8;
+
+	if (page_data_size == 4096) {
+		if (page_oob_size == 128)
+			return 8;
+
+		if (page_oob_size == 218)
+			return 16;
+	}
+
+	return 0;
+}
+
+static inline uint32_t mxs_nand_get_mark_offset(uint32_t page_data_size,
+						uint32_t ecc_strength)
+{
+	uint32_t chunk_data_size_in_bits;
+	uint32_t chunk_ecc_size_in_bits;
+	uint32_t chunk_total_size_in_bits;
+	uint32_t block_mark_chunk_number;
+	uint32_t block_mark_chunk_bit_offset;
+	uint32_t block_mark_bit_offset;
+
+	chunk_data_size_in_bits = MXS_NAND_CHUNK_DATA_CHUNK_SIZE * 8;
+	chunk_ecc_size_in_bits  = mxs_nand_ecc_size_in_bits(ecc_strength);
+
+	chunk_total_size_in_bits =
+			chunk_data_size_in_bits + chunk_ecc_size_in_bits;
+
+	/* Compute the bit offset of the block mark within the physical page. */
+	block_mark_bit_offset = page_data_size * 8;
+
+	/* Subtract the metadata bits. */
+	block_mark_bit_offset -= MXS_NAND_METADATA_SIZE * 8;
+
+	/*
+	 * Compute the chunk number (starting at zero) in which the block mark
+	 * appears.
+	 */
+	block_mark_chunk_number =
+			block_mark_bit_offset / chunk_total_size_in_bits;
+
+	/*
+	 * Compute the bit offset of the block mark within its chunk, and
+	 * validate it.
+	 */
+	block_mark_chunk_bit_offset = block_mark_bit_offset -
+			(block_mark_chunk_number * chunk_total_size_in_bits);
+
+	if (block_mark_chunk_bit_offset > chunk_data_size_in_bits)
+		return 1;
+
+	/*
+	 * Now that we know the chunk number in which the block mark appears,
+	 * we can subtract all the ECC bits that appear before it.
+	 */
+	block_mark_bit_offset -=
+		block_mark_chunk_number * chunk_ecc_size_in_bits;
+
+	return block_mark_bit_offset;
+}
+
+static uint32_t mxs_nand_mark_byte_offset(struct mtd_info *mtd)
+{
+	uint32_t ecc_strength;
+	ecc_strength = mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize);
+	return mxs_nand_get_mark_offset(mtd->writesize, ecc_strength) >> 3;
+}
+
+static uint32_t mxs_nand_mark_bit_offset(struct mtd_info *mtd)
+{
+	uint32_t ecc_strength;
+	ecc_strength = mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize);
+	return mxs_nand_get_mark_offset(mtd->writesize, ecc_strength) & 0x7;
+}
+
+/*
+ * Wait for BCH complete IRQ and clear the IRQ
+ */
+static int mxs_nand_wait_for_bch_complete(void)
+{
+	struct mx28_bch_regs *bch_regs = (struct mx28_bch_regs *)MXS_BCH_BASE;
+	int timeout = MXS_NAND_BCH_TIMEOUT;
+	int ret;
+
+	ret = mx28_wait_mask_set(&bch_regs->hw_bch_ctrl_reg,
+		BCH_CTRL_COMPLETE_IRQ, timeout);
+
+	writel(BCH_CTRL_COMPLETE_IRQ, &bch_regs->hw_bch_ctrl_clr);
+
+	return ret;
+}
+
+/*
+ * This is the function that we install in the cmd_ctrl function pointer of the
+ * owning struct nand_chip. The only functions in the reference implementation
+ * that use these functions pointers are cmdfunc and select_chip.
+ *
+ * In this driver, we implement our own select_chip, so this function will only
+ * be called by the reference implementation's cmdfunc. For this reason, we can
+ * ignore the chip enable bit and concentrate only on sending bytes to the NAND
+ * Flash.
+ */
+static void mxs_nand_cmd_ctrl(struct mtd_info *mtd, int data, unsigned int ctrl)
+{
+	struct nand_chip *nand = mtd->priv;
+	struct mxs_nand_info *nand_info = nand->priv;
+	struct mxs_dma_desc *d;
+	uint32_t channel = MXS_DMA_CHANNEL_AHB_APBH_GPMI0 + nand_info->cur_chip;
+	int ret;
+
+	/*
+	 * If this condition is true, something is _VERY_ wrong in MTD
+	 * subsystem!
+	 */
+	if (nand_info->cmd_queue_len == MXS_NAND_COMMAND_BUFFER_SIZE) {
+		printf("MXS NAND: Command queue too long\n");
+		return;
+	}
+
+	/*
+	 * Every operation begins with a command byte and a series of zero or
+	 * more address bytes. These are distinguished by either the Address
+	 * Latch Enable (ALE) or Command Latch Enable (CLE) signals being
+	 * asserted. When MTD is ready to execute the command, it will
+	 * deasert both latch enables.
+	 *
+	 * Rather than run a separate DMA operation for every single byte, we
+	 * queue them up and run a single DMA operation for the entire series
+	 * of command and data bytes.
+	 */
+	if (ctrl & (NAND_ALE | NAND_CLE)) {
+		if (data != NAND_CMD_NONE)
+			nand_info->cmd_buf[nand_info->cmd_queue_len++] = data;
+		return;
+	}
+
+	/*
+	 * If control arrives here, MTD has deasserted both the ALE and CLE,
+	 * which means it's ready to run an operation. Check if we have any
+	 * bytes to send.
+	 */
+	if (nand_info->cmd_queue_len == 0)
+		return;
+
+	/* Compile the DMA descriptor -- a descriptor that sends command. */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_DMA_READ | MXS_DMA_DESC_IRQ |
+		MXS_DMA_DESC_CHAIN | MXS_DMA_DESC_DEC_SEM |
+		MXS_DMA_DESC_WAIT4END | (3 << MXS_DMA_DESC_PIO_WORDS_OFFSET) |
+		(nand_info->cmd_queue_len << MXS_DMA_DESC_BYTES_OFFSET);
+
+	d->cmd.address = virt_to_phys(nand_info->cmd_buf);
+
+	d->cmd.pio_words[0] =
+		GPMI_CTRL0_COMMAND_MODE_WRITE |
+		GPMI_CTRL0_WORD_LENGTH |
+		(nand_info->cur_chip << GPMI_CTRL0_CS_OFFSET) |
+		GPMI_CTRL0_ADDRESS_NAND_CLE |
+		GPMI_CTRL0_ADDRESS_INCREMENT |
+		nand_info->cmd_queue_len;
+
+	mxs_dma_desc_append(channel, d);
+
+	mxs_nand_dma_flush(nand_info->cmd_buf,
+			   nand_info->cmd_queue_len);
+
+	/* Execute the DMA chain. */
+	ret = mxs_dma_go(channel);
+	if (ret)
+		printf("MXS NAND: Error sending command\n");
+
+	mxs_nand_return_dma_descs(nand_info);
+
+	/* Reset the command queue. */
+	nand_info->cmd_queue_len = 0;
+}
+
+/*
+ * Test if the NAND flash is ready.
+ */
+static int mxs_nand_device_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct mxs_nand_info *nand_info = chip->priv;
+	struct mx28_gpmi_regs *gpmi_regs =
+		(struct mx28_gpmi_regs *)MXS_GPMI_BASE;
+	uint32_t tmp;
+
+	tmp = readl(&gpmi_regs->hw_gpmi_stat);
+	tmp >>= (GPMI_STAT_READY_BUSY_OFFSET + nand_info->cur_chip);
+
+	return tmp & 1;
+}
+
+/*
+ * Select the NAND chip.
+ */
+static void mxs_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	struct nand_chip *nand = mtd->priv;
+	struct mxs_nand_info *nand_info = nand->priv;
+
+	nand_info->cur_chip = chip;
+}
+
+/*
+ * Handle block mark swapping.
+ *
+ * Note that, when this function is called, it doesn't know whether it's
+ * swapping the block mark, or swapping it *back* -- but it doesn't matter
+ * because the the operation is the same.
+ */
+static void mxs_nand_swap_block_mark(struct mtd_info *mtd,
+					uint8_t *data_buf, uint8_t *oob_buf)
+{
+	uint32_t bit_offset;
+	uint32_t buf_offset;
+
+	uint32_t src;
+	uint32_t dst;
+
+	bit_offset = mxs_nand_mark_bit_offset(mtd);
+	buf_offset = mxs_nand_mark_byte_offset(mtd);
+
+	/*
+	 * Get the byte from the data area that overlays the block mark. Since
+	 * the ECC engine applies its own view to the bits in the page, the
+	 * physical block mark won't (in general) appear on a byte boundary in
+	 * the data.
+	 */
+	src = data_buf[buf_offset] >> bit_offset;
+	src |= data_buf[buf_offset + 1] << (8 - bit_offset);
+
+	dst = oob_buf[0];
+
+	oob_buf[0] = src;
+
+	data_buf[buf_offset] &= ~(0xff << bit_offset);
+	data_buf[buf_offset + 1] &= 0xff << bit_offset;
+
+	data_buf[buf_offset] |= dst << bit_offset;
+	data_buf[buf_offset + 1] |= dst >> (8 - bit_offset);
+}
+
+/*
+ * Read data from NAND.
+ */
+static void mxs_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int length)
+{
+	struct nand_chip *nand = mtd->priv;
+	struct mxs_nand_info *nand_info = nand->priv;
+	struct mxs_dma_desc *d;
+	uint32_t channel = MXS_DMA_CHANNEL_AHB_APBH_GPMI0 + nand_info->cur_chip;
+	int ret;
+
+	if (length > NAND_MAX_PAGESIZE) {
+		printf("MXS NAND: DMA buffer too big\n");
+		return;
+	}
+
+	if (!buf) {
+		printf("MXS NAND: DMA buffer is NULL\n");
+		return;
+	}
+
+	/* Compile the DMA descriptor - a descriptor that reads data. */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_DMA_WRITE | MXS_DMA_DESC_IRQ |
+		MXS_DMA_DESC_DEC_SEM | MXS_DMA_DESC_WAIT4END |
+		(1 << MXS_DMA_DESC_PIO_WORDS_OFFSET) |
+		(length << MXS_DMA_DESC_BYTES_OFFSET);
+
+	d->cmd.address = virt_to_phys(nand_info->data_buf);
+
+	d->cmd.pio_words[0] =
+		GPMI_CTRL0_COMMAND_MODE_READ |
+		GPMI_CTRL0_WORD_LENGTH |
+		(nand_info->cur_chip << GPMI_CTRL0_CS_OFFSET) |
+		GPMI_CTRL0_ADDRESS_NAND_DATA |
+		length;
+
+	mxs_dma_desc_append(channel, d);
+
+	/*
+	 * A DMA descriptor that waits for the command to end and the chip to
+	 * become ready.
+	 *
+	 * I think we actually should *not* be waiting for the chip to become
+	 * ready because, after all, we don't care. I think the original code
+	 * did that and no one has re-thought it yet.
+	 */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_NO_DMAXFER | MXS_DMA_DESC_IRQ |
+		MXS_DMA_DESC_NAND_WAIT_4_READY | MXS_DMA_DESC_DEC_SEM |
+		MXS_DMA_DESC_WAIT4END | (4 << MXS_DMA_DESC_PIO_WORDS_OFFSET);
+
+	d->cmd.address = 0;
+
+	d->cmd.pio_words[0] =
+		GPMI_CTRL0_COMMAND_MODE_WAIT_FOR_READY |
+		GPMI_CTRL0_WORD_LENGTH |
+		(nand_info->cur_chip << GPMI_CTRL0_CS_OFFSET) |
+		GPMI_CTRL0_ADDRESS_NAND_DATA;
+
+	mxs_dma_desc_append(channel, d);
+
+	/* Execute the DMA chain. */
+	mxs_nand_dma_clean(nand_info->data_buf, length);
+	ret = mxs_dma_go(channel);
+	if (ret) {
+		printf("%s: DMA read error: %d\n", __func__, ret);
+		goto rtn;
+	}
+
+	mxs_nand_dma_inv(nand_info->data_buf, length);
+
+	memcpy(buf, nand_info->data_buf, length);
+
+rtn:
+	mxs_nand_return_dma_descs(nand_info);
+}
+
+/*
+ * Write data to NAND.
+ */
+static void mxs_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
+				int length)
+{
+	struct nand_chip *nand = mtd->priv;
+	struct mxs_nand_info *nand_info = nand->priv;
+	struct mxs_dma_desc *d;
+	uint32_t channel = MXS_DMA_CHANNEL_AHB_APBH_GPMI0 + nand_info->cur_chip;
+	int ret;
+
+	if (length > NAND_MAX_PAGESIZE) {
+		printf("MXS NAND: DMA buffer too big\n");
+		return;
+	}
+
+	if (!buf) {
+		printf("MXS NAND: DMA buffer is NULL\n");
+		return;
+	}
+
+	memcpy(nand_info->data_buf, buf, length);
+
+	/* Compile the DMA descriptor - a descriptor that writes data. */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_DMA_READ | MXS_DMA_DESC_IRQ |
+		MXS_DMA_DESC_DEC_SEM | MXS_DMA_DESC_WAIT4END |
+		(4 << MXS_DMA_DESC_PIO_WORDS_OFFSET) |
+		(length << MXS_DMA_DESC_BYTES_OFFSET);
+
+	d->cmd.address = virt_to_phys(nand_info->data_buf);
+
+	d->cmd.pio_words[0] =
+		GPMI_CTRL0_COMMAND_MODE_WRITE |
+		GPMI_CTRL0_WORD_LENGTH |
+		(nand_info->cur_chip << GPMI_CTRL0_CS_OFFSET) |
+		GPMI_CTRL0_ADDRESS_NAND_DATA |
+		length;
+
+	mxs_dma_desc_append(channel, d);
+
+	mxs_nand_dma_flush(nand_info->data_buf, length);
+
+	/* Execute the DMA chain. */
+	ret = mxs_dma_go(channel);
+	if (ret)
+		printf("MXS NAND: DMA write error\n");
+
+	mxs_nand_return_dma_descs(nand_info);
+}
+
+/*
+ * Read a single byte from NAND.
+ */
+static uint8_t mxs_nand_read_byte(struct mtd_info *mtd)
+{
+	uint8_t buf;
+	mxs_nand_read_buf(mtd, &buf, 1);
+	return buf;
+}
+
+/*
+ * Read a page from NAND.
+ */
+static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
+					uint8_t *buf)
+{
+	struct mxs_nand_info *nand_info = nand->priv;
+	struct mxs_dma_desc *d;
+	uint32_t channel = MXS_DMA_CHANNEL_AHB_APBH_GPMI0 + nand_info->cur_chip;
+	uint32_t corrected = 0, failed = 0;
+	uint8_t	*status;
+	int i, ret;
+
+	/* Compile the DMA descriptor - wait for ready. */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_NO_DMAXFER | MXS_DMA_DESC_CHAIN |
+		MXS_DMA_DESC_NAND_WAIT_4_READY | MXS_DMA_DESC_WAIT4END |
+		(1 << MXS_DMA_DESC_PIO_WORDS_OFFSET);
+
+	d->cmd.address = 0;
+
+	d->cmd.pio_words[0] =
+		GPMI_CTRL0_COMMAND_MODE_WAIT_FOR_READY |
+		GPMI_CTRL0_WORD_LENGTH |
+		(nand_info->cur_chip << GPMI_CTRL0_CS_OFFSET) |
+		GPMI_CTRL0_ADDRESS_NAND_DATA;
+
+	mxs_dma_desc_append(channel, d);
+
+	/* Compile the DMA descriptor - enable the BCH block and read. */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_NO_DMAXFER | MXS_DMA_DESC_CHAIN |
+		MXS_DMA_DESC_WAIT4END |	(6 << MXS_DMA_DESC_PIO_WORDS_OFFSET);
+
+	d->cmd.address = 0;
+
+	d->cmd.pio_words[0] =
+		GPMI_CTRL0_COMMAND_MODE_READ |
+		GPMI_CTRL0_WORD_LENGTH |
+		(nand_info->cur_chip << GPMI_CTRL0_CS_OFFSET) |
+		GPMI_CTRL0_ADDRESS_NAND_DATA |
+		(mtd->writesize + mtd->oobsize);
+	d->cmd.pio_words[1] = 0;
+	d->cmd.pio_words[2] =
+		GPMI_ECCCTRL_ENABLE_ECC |
+		GPMI_ECCCTRL_ECC_CMD_DECODE |
+		GPMI_ECCCTRL_BUFFER_MASK_BCH_PAGE;
+	d->cmd.pio_words[3] = mtd->writesize + mtd->oobsize;
+	d->cmd.pio_words[4] = virt_to_phys(nand_info->data_buf);
+	d->cmd.pio_words[5] = virt_to_phys(nand_info->oob_buf);
+
+	mxs_dma_desc_append(channel, d);
+
+	/* Compile the DMA descriptor - disable the BCH block. */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_NO_DMAXFER | MXS_DMA_DESC_CHAIN |
+		MXS_DMA_DESC_NAND_WAIT_4_READY | MXS_DMA_DESC_WAIT4END |
+		(3 << MXS_DMA_DESC_PIO_WORDS_OFFSET);
+
+	d->cmd.address = 0;
+
+	d->cmd.pio_words[0] =
+		GPMI_CTRL0_COMMAND_MODE_WAIT_FOR_READY |
+		GPMI_CTRL0_WORD_LENGTH |
+		(nand_info->cur_chip << GPMI_CTRL0_CS_OFFSET) |
+		GPMI_CTRL0_ADDRESS_NAND_DATA |
+		(mtd->writesize + mtd->oobsize);
+	d->cmd.pio_words[1] = 0;
+	d->cmd.pio_words[2] = 0;
+
+	mxs_dma_desc_append(channel, d);
+
+	/* Compile the DMA descriptor - deassert the NAND lock and interrupt. */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_NO_DMAXFER | MXS_DMA_DESC_IRQ |
+		MXS_DMA_DESC_DEC_SEM;
+
+	d->cmd.address = 0;
+
+	mxs_dma_desc_append(channel, d);
+
+	/* Execute the DMA chain. */
+	mxs_nand_dma_clean(nand_info->data_buf, mtd->writesize);
+	mxs_nand_dma_clean(nand_info->oob_buf, mtd->oobsize);
+
+	ret = mxs_dma_go(channel);
+	if (ret) {
+		mxs_nand_dump_gpmi(nand_info, "  GPMI/err: ");
+		printf("%s: DMA read error: %d\n", __func__, ret);
+		goto rtn;
+	}
+
+	ret = mxs_nand_wait_for_bch_complete();
+	if (ret) {
+		printf("%s: BCH read timeout: %d\n", __func__, ret);
+		goto rtn;
+	}
+
+	mxs_nand_dma_inv(nand_info->data_buf, mtd->writesize);
+	mxs_nand_dma_inv(nand_info->oob_buf, mtd->oobsize);
+
+	/* Read DMA completed, now do the mark swapping. */
+	mxs_nand_swap_block_mark(mtd, nand_info->data_buf, nand_info->oob_buf);
+
+	/* Loop over status bytes, accumulating ECC status. */
+	status = nand_info->oob_buf + mxs_nand_aux_status_offset();
+	for (i = 0; i < mxs_nand_ecc_chunk_cnt(mtd->writesize); i++) {
+		if (status[i] == 0x00)
+			continue;
+
+		if (status[i] == 0xff)
+			continue;
+
+		if (status[i] == 0xfe) {
+			failed++;
+			continue;
+		}
+
+		corrected += status[i];
+	}
+
+	/* Propagate ECC status to the owning MTD. */
+	mtd->ecc_stats.failed += failed;
+	mtd->ecc_stats.corrected += corrected;
+
+	/*
+	 * It's time to deliver the OOB bytes. See mxs_nand_ecc_read_oob() for
+	 * details about our policy for delivering the OOB.
+	 *
+	 * We fill the caller's buffer with set bits, and then copy the block
+	 * mark to the caller's buffer. Note that, if block mark swapping was
+	 * necessary, it has already been done, so we can rely on the first
+	 * byte of the auxiliary buffer to contain the block mark.
+	 */
+	memset(nand->oob_poi, 0xff, mtd->oobsize);
+
+	nand->oob_poi[0] = nand_info->oob_buf[0];
+
+	memcpy(buf, nand_info->data_buf, mtd->writesize);
+
+rtn:
+	mxs_nand_return_dma_descs(nand_info);
+
+	return ret;
+}
+
+/*
+ * Write a page to NAND.
+ */
+static void mxs_nand_ecc_write_page(struct mtd_info *mtd,
+				struct nand_chip *nand, const uint8_t *buf)
+{
+	struct mxs_nand_info *nand_info = nand->priv;
+	struct mxs_dma_desc *d;
+	uint32_t channel = MXS_DMA_CHANNEL_AHB_APBH_GPMI0 + nand_info->cur_chip;
+	int ret;
+
+	memcpy(nand_info->data_buf, buf, mtd->writesize);
+	memcpy(nand_info->oob_buf, nand->oob_poi, mtd->oobsize);
+
+	/* Handle block mark swapping. */
+	mxs_nand_swap_block_mark(mtd, nand_info->data_buf, nand_info->oob_buf);
+
+	/* Compile the DMA descriptor - write data. */
+	d = mxs_nand_get_dma_desc(nand_info);
+	d->cmd.data =
+		MXS_DMA_DESC_COMMAND_NO_DMAXFER | MXS_DMA_DESC_IRQ |
+		MXS_DMA_DESC_DEC_SEM | MXS_DMA_DESC_WAIT4END |
+		(6 << MXS_DMA_DESC_PIO_WORDS_OFFSET);
+
+	d->cmd.address = 0;
+
+	d->cmd.pio_words[0] =
+		GPMI_CTRL0_COMMAND_MODE_WRITE |
+		GPMI_CTRL0_WORD_LENGTH |
+		(nand_info->cur_chip << GPMI_CTRL0_CS_OFFSET) |
+		GPMI_CTRL0_ADDRESS_NAND_DATA;
+	d->cmd.pio_words[1] = 0;
+	d->cmd.pio_words[2] =
+		GPMI_ECCCTRL_ENABLE_ECC |
+		GPMI_ECCCTRL_ECC_CMD_ENCODE |
+		GPMI_ECCCTRL_BUFFER_MASK_BCH_PAGE;
+	d->cmd.pio_words[3] = (mtd->writesize + mtd->oobsize);
+	d->cmd.pio_words[4] = virt_to_phys(nand_info->data_buf);
+	d->cmd.pio_words[5] = virt_to_phys(nand_info->oob_buf);
+
+	mxs_dma_desc_append(channel, d);
+
+	mxs_nand_dma_flush(nand_info->data_buf, mtd->writesize);
+	mxs_nand_dma_flush(nand_info->oob_buf, mtd->oobsize);
+
+	/* Execute the DMA chain. */
+	ret = mxs_dma_go(channel);
+	if (ret) {
+		printf("MXS NAND: DMA write error\n");
+		goto rtn;
+	}
+
+	ret = mxs_nand_wait_for_bch_complete();
+	if (ret) {
+		printf("MXS NAND: BCH write timeout\n");
+		goto rtn;
+	}
+
+rtn:
+	mxs_nand_return_dma_descs(nand_info);
+}
+
+/*
+ * Read OOB from NAND.
+ *
+ * This function is a veneer that replaces the function originally installed by
+ * the NAND Flash MTD code.
+ */
+static int mxs_nand_hook_read_oob(struct mtd_info *mtd, loff_t from,
+					struct mtd_oob_ops *ops)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct mxs_nand_info *nand_info = chip->priv;
+	int ret;
+
+	if (ops->mode == MTD_OOB_RAW)
+		nand_info->raw_oob_mode = 1;
+	else
+		nand_info->raw_oob_mode = 0;
+
+	ret = nand_info->hooked_read_oob(mtd, from, ops);
+
+	nand_info->raw_oob_mode = 0;
+
+	return ret;
+}
+
+/*
+ * Write OOB to NAND.
+ *
+ * This function is a veneer that replaces the function originally installed by
+ * the NAND Flash MTD code.
+ */
+static int mxs_nand_hook_write_oob(struct mtd_info *mtd, loff_t to,
+					struct mtd_oob_ops *ops)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct mxs_nand_info *nand_info = chip->priv;
+	int ret;
+
+	if (ops->mode == MTD_OOB_RAW)
+		nand_info->raw_oob_mode = 1;
+	else
+		nand_info->raw_oob_mode = 0;
+
+	ret = nand_info->hooked_write_oob(mtd, to, ops);
+
+	nand_info->raw_oob_mode = 0;
+
+	return ret;
+}
+
+/*
+ * Mark a block bad in NAND.
+ *
+ * This function is a veneer that replaces the function originally installed by
+ * the NAND Flash MTD code.
+ */
+static int mxs_nand_hook_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct mxs_nand_info *nand_info = chip->priv;
+	int ret;
+
+	nand_info->marking_block_bad = 1;
+
+	ret = nand_info->hooked_block_markbad(mtd, ofs);
+
+	nand_info->marking_block_bad = 0;
+
+	return ret;
+}
+
+/*
+ * There are several places in this driver where we have to handle the OOB and
+ * block marks. This is the function where things are the most complicated, so
+ * this is where we try to explain it all. All the other places refer back to
+ * here.
+ *
+ * These are the rules, in order of decreasing importance:
+ *
+ * 1) Nothing the caller does can be allowed to imperil the block mark, so all
+ *    write operations take measures to protect it.
+ *
+ * 2) In read operations, the first byte of the OOB we return must reflect the
+ *    true state of the block mark, no matter where that block mark appears in
+ *    the physical page.
+ *
+ * 3) ECC-based read operations return an OOB full of set bits (since we never
+ *    allow ECC-based writes to the OOB, it doesn't matter what ECC-based reads
+ *    return).
+ *
+ * 4) "Raw" read operations return a direct view of the physical bytes in the
+ *    page, using the conventional definition of which bytes are data and which
+ *    are OOB. This gives the caller a way to see the actual, physical bytes
+ *    in the page, without the distortions applied by our ECC engine.
+ *
+ * What we do for this specific read operation depends on whether we're doing
+ * "raw" read, or an ECC-based read.
+ *
+ * It turns out that knowing whether we want an "ECC-based" or "raw" read is not
+ * easy. When reading a page, for example, the NAND Flash MTD code calls our
+ * ecc.read_page or ecc.read_page_raw function. Thus, the fact that MTD wants an
+ * ECC-based or raw view of the page is implicit in which function it calls
+ * (there is a similar pair of ECC-based/raw functions for writing).
+ *
+ * Since MTD assumes the OOB is not covered by ECC, there is no pair of
+ * ECC-based/raw functions for reading or or writing the OOB. The fact that the
+ * caller wants an ECC-based or raw view of the page is not propagated down to
+ * this driver.
+ *
+ * Since our OOB *is* covered by ECC, we need this information. So, we hook the
+ * ecc.read_oob and ecc.write_oob function pointers in the owning
+ * struct mtd_info with our own functions. These hook functions set the
+ * raw_oob_mode field so that, when control finally arrives here, we'll know
+ * what to do.
+ */
+static int mxs_nand_ecc_read_oob(struct mtd_info *mtd, struct nand_chip *nand,
+				int page, int cmd)
+{
+	struct mxs_nand_info *nand_info = nand->priv;
+
+	/*
+	 * First, fill in the OOB buffer. If we're doing a raw read, we need to
+	 * get the bytes from the physical page. If we're not doing a raw read,
+	 * we need to fill the buffer with set bits.
+	 */
+	if (nand_info->raw_oob_mode) {
+		/*
+		 * If control arrives here, we're doing a "raw" read. Send the
+		 * command to read the conventional OOB and read it.
+		 */
+		nand->cmdfunc(mtd, NAND_CMD_READ0, mtd->writesize, page);
+		nand->read_buf(mtd, nand->oob_poi, mtd->oobsize);
+	} else {
+		/*
+		 * If control arrives here, we're not doing a "raw" read. Fill
+		 * the OOB buffer with set bits and correct the block mark.
+		 */
+		memset(nand->oob_poi, 0xff, mtd->oobsize);
+
+		nand->cmdfunc(mtd, NAND_CMD_READ0, mtd->writesize, page);
+		mxs_nand_read_buf(mtd, nand->oob_poi, 1);
+	}
+
+	return 0;
+
+}
+
+/*
+ * Write OOB data to NAND.
+ */
+static int mxs_nand_ecc_write_oob(struct mtd_info *mtd, struct nand_chip *nand,
+					int page)
+{
+	struct mxs_nand_info *nand_info = nand->priv;
+	uint8_t block_mark = 0;
+
+	/*
+	 * There are fundamental incompatibilities between the i.MX GPMI NFC and
+	 * the NAND Flash MTD model that make it essentially impossible to write
+	 * the out-of-band bytes.
+	 *
+	 * We permit *ONE* exception. If the *intent* of writing the OOB is to
+	 * mark a block bad, we can do that.
+	 */
+
+	if (!nand_info->marking_block_bad) {
+		printf("NXS NAND: Writing OOB isn't supported\n");
+		return -EIO;
+	}
+
+	/* Write the block mark. */
+	nand->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+	nand->write_buf(mtd, &block_mark, 1);
+	nand->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	/* Check if it worked. */
+	if (nand->waitfunc(mtd, nand) & NAND_STATUS_FAIL)
+		return -EIO;
+
+	return 0;
+}
+
+/*
+ * Claims all blocks are good.
+ *
+ * In principle, this function is *only* called when the NAND Flash MTD system
+ * isn't allowed to keep an in-memory bad block table, so it is forced to ask
+ * the driver for bad block information.
+ *
+ * In fact, we permit the NAND Flash MTD system to have an in-memory BBT, so
+ * this function is *only* called when we take it away.
+ *
+ * Thus, this function is only called when we want *all* blocks to look good,
+ * so it *always* return success.
+ */
+static int mxs_nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
+{
+	return 0;
+}
+
+/*
+ * Nominally, the purpose of this function is to look for or create the bad
+ * block table. In fact, since the we call this function at the very end of
+ * the initialization process started by nand_scan(), and we doesn't have a
+ * more formal mechanism, we "hook" this function to continue init process.
+ *
+ * At this point, the physical NAND Flash chips have been identified and
+ * counted, so we know the physical geometry. This enables us to make some
+ * important configuration decisions.
+ *
+ * The return value of this function propogates directly back to this driver's
+ * call to nand_scan(). Anything other than zero will cause this driver to
+ * tear everything down and declare failure.
+ */
+static int mxs_nand_scan_bbt(struct mtd_info *mtd)
+{
+	struct nand_chip *nand = mtd->priv;
+	struct mxs_nand_info *nand_info = nand->priv;
+	struct mx28_bch_regs *bch_regs = (struct mx28_bch_regs *)MXS_BCH_BASE;
+	uint32_t tmp;
+
+	/* Configure BCH and set NFC geometry */
+	mx28_reset_block(&bch_regs->hw_bch_ctrl_reg, 0);
+
+	writel(nand_info->timings[0], &nand_info->gpmi_regs->hw_gpmi_timing0);
+	writel(nand_info->timings[1], &nand_info->gpmi_regs->hw_gpmi_timing1);
+
+	/* Configure layout 0 */
+	tmp = (mxs_nand_ecc_chunk_cnt(mtd->writesize) - 1)
+		<< BCH_FLASHLAYOUT0_NBLOCKS_OFFSET;
+	tmp |= MXS_NAND_METADATA_SIZE << BCH_FLASHLAYOUT0_META_SIZE_OFFSET;
+	tmp |= (mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize) >> 1)
+		<< BCH_FLASHLAYOUT0_ECC0_OFFSET;
+	tmp |= MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
+	writel(tmp, &bch_regs->hw_bch_flash0layout0);
+
+	tmp = (mtd->writesize + mtd->oobsize)
+		<< BCH_FLASHLAYOUT1_PAGE_SIZE_OFFSET;
+	tmp |= (mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize) >> 1)
+		<< BCH_FLASHLAYOUT1_ECCN_OFFSET;
+	tmp |= MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
+	writel(tmp, &bch_regs->hw_bch_flash0layout1);
+
+	/* Set *all* chip selects to use layout 0 */
+	writel(0, &bch_regs->hw_bch_layoutselect);
+
+	/* Enable BCH complete interrupt */
+	writel(BCH_CTRL_COMPLETE_IRQ_EN, &bch_regs->hw_bch_ctrl_set);
+
+	/* Hook some operations at the MTD level. */
+	if (mtd->read_oob != mxs_nand_hook_read_oob) {
+		nand_info->hooked_read_oob = mtd->read_oob;
+		mtd->read_oob = mxs_nand_hook_read_oob;
+	}
+
+	if (mtd->write_oob != mxs_nand_hook_write_oob) {
+		nand_info->hooked_write_oob = mtd->write_oob;
+		mtd->write_oob = mxs_nand_hook_write_oob;
+	}
+
+	if (mtd->block_markbad != mxs_nand_hook_block_markbad) {
+		nand_info->hooked_block_markbad = mtd->block_markbad;
+		mtd->block_markbad = mxs_nand_hook_block_markbad;
+	}
+
+	/* We use the reference implementation for bad block management. */
+	return nand_default_bbt(mtd);
+}
+
+/*
+ * Allocate DMA buffers
+ */
+static int mxs_nand_alloc_buffers(struct mxs_nand_info *nand_info)
+{
+	uint8_t *buf;
+	const int size = NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE;
+
+	/* DMA buffers */
+	buf = memalign(MXS_DMA_ALIGNMENT, size);
+	if (!buf) {
+		printf("MXS NAND: Error allocating DMA buffers\n");
+		return -ENOMEM;
+	}
+
+	memset(buf, 0, size);
+
+	nand_info->data_buf = buf;
+	nand_info->oob_buf = buf + NAND_MAX_PAGESIZE;
+
+	/* Command buffers */
+	nand_info->cmd_buf = memalign(MXS_DMA_ALIGNMENT,
+				MXS_NAND_COMMAND_BUFFER_SIZE);
+	if (!nand_info->cmd_buf) {
+		free(buf);
+		printf("MXS NAND: Error allocating command buffers\n");
+		return -ENOMEM;
+	}
+	memset(nand_info->cmd_buf, 0, MXS_NAND_COMMAND_BUFFER_SIZE);
+	nand_info->cmd_queue_len = 0;
+
+	return 0;
+}
+
+static inline unsigned int ns2cyc(unsigned int clkfreq, unsigned int ns,
+				  unsigned int max)
+{
+	unsigned long	v = clkfreq;
+
+	v = (v + 100000 - 1) / 100000;
+
+	if (WARN_ON(ns == 0))
+		v = 1;
+	else if (WARN_ON(v >= ULONG_MAX / ns))
+		v = max;		/* todo */
+	else {
+		v *= ns;
+		v += 10000u - 1;
+		v /= 10000u;
+	}
+
+	if (WARN_ON(v > max))
+		v = max;
+
+	return v;
+}
+
+#define TM0_DATA_SETUP(_cyc)		((_cyc) << GPMI_TIMING0_DATA_SETUP_OFFSET)
+#define TM0_DATA_HOLD(_cyc)		((_cyc) << GPMI_TIMING0_DATA_HOLD_OFFSET)
+#define TM0_ADDRESS_SETUP(_cyc)	((_cyc) << GPMI_TIMING0_ADDRESS_SETUP_OFFSET)
+#define TM1_BUSY_TIMEOUT(_cyc4096)	((_cyc4096) << GPMI_TIMING1_DEVICE_BUSY_TIMEOUT_OFFSET)
+
+/*
+ * Initializes the NFC hardware.
+ */
+static int mxs_nand_hw_init(struct mxs_nand_info *info,
+			    struct mxs_nand_platform_data const	*pdata)
+{
+	struct mx28_gpmi_regs *gpmi_regs =
+		(struct mx28_gpmi_regs *)MXS_GPMI_BASE;
+	int i = 0;
+	unsigned int		clkfreq = imx_get_gpmiclk();
+
+	info->desc = malloc(sizeof(struct mxs_dma_desc *) *
+				MXS_NAND_DMA_DESCRIPTOR_COUNT);
+	if (!info->desc)
+		goto err1;
+
+	/* Allocate the DMA descriptors. */
+	for (i = 0; i < MXS_NAND_DMA_DESCRIPTOR_COUNT; i++) {
+		info->desc[i] = mxs_dma_desc_alloc();
+		if (!info->desc[i])
+			goto err2;
+	}
+
+	/* Reset the GPMI block. */
+	mx28_reset_block(&gpmi_regs->hw_gpmi_ctrl0_reg, 0);
+
+	info->timings[0] = \
+		(TM0_DATA_SETUP(ns2cyc(clkfreq, pdata->ns_data_setup, 255)) |
+		 TM0_DATA_HOLD(ns2cyc(clkfreq, pdata->ns_data_hold, 255)) |
+		 TM0_ADDRESS_SETUP(ns2cyc(clkfreq, pdata->ns_address_setup,
+					  0xffff)));
+
+	info->timings[1] = \
+		(TM1_BUSY_TIMEOUT((ns2cyc(clkfreq, pdata->ns_busy_timeout,
+					  0x10000 * 4096 - 1)
+				   + 4096 - 1) / 4096));
+
+	writel(info->timings[0], &gpmi_regs->hw_gpmi_timing0);
+	writel(info->timings[1], &gpmi_regs->hw_gpmi_timing1);
+
+	/*
+	 * Choose NAND mode, set IRQ polarity, disable write protection and
+	 * select BCH ECC.
+	 */
+	writel(GPMI_CTRL1_GPMI_MODE, &gpmi_regs->hw_gpmi_ctrl1_clr);
+	writel(GPMI_CTRL1_ATA_IRQRDY_POLARITY | GPMI_CTRL1_DEV_RESET |
+	       GPMI_CTRL1_BCH_MODE, &gpmi_regs->hw_gpmi_ctrl1_set);
+
+	return 0;
+
+err2:
+	free(info->desc);
+err1:
+	for (--i; i >= 0; i--)
+		mxs_dma_desc_free(info->desc[i]);
+	printf("MXS NAND: Unable to allocate DMA descriptors\n");
+	return -ENOMEM;
+}
+
+struct mxs_nand_fcb_params const *mxs_nand_get_fcb_params(struct device_d *dev)
+{
+	struct mxs_nand_info	*info = dev->priv;
+
+	if (WARN_ON(!info))
+		return NULL;
+
+	return &info->fcb;
+}
+EXPORT_SYMBOL(mxs_nand_get_fcb_params);
+
+static int __init mxs_nand_probe(struct device_d *dev)
+{
+	struct mxs_nand_platform_data const	*pdata = dev->platform_data;
+	struct mxs_nand_info	*info;
+	struct nand_chip	*nand;
+	struct mtd_info		*mtd;
+	int			rc;
+
+	info = kzalloc(sizeof *info, GFP_KERNEL);
+	if (!info) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	rc = mxs_nand_alloc_buffers(info);
+	if (rc)
+		goto out;
+
+	rc = mxs_nand_hw_init(info, pdata);
+	if (rc)
+		goto out;
+
+	memset(&fake_ecc_layout, 0, sizeof(fake_ecc_layout));
+
+	dev->priv = info;
+
+	info->dev = dev;
+	info->gpmi_regs = (struct mx28_gpmi_regs *)MXS_GPMI_BASE;
+	info->cur_chip = dev->id;
+
+	nand = &info->nand;
+	mtd = &info->mtd;
+
+	nand->priv = info;
+
+	nand->cmd_ctrl		= mxs_nand_cmd_ctrl;
+
+	nand->dev_ready		= mxs_nand_device_ready;
+	nand->select_chip	= mxs_nand_select_chip;
+	nand->block_bad		= mxs_nand_block_bad;
+	nand->scan_bbt		= mxs_nand_scan_bbt;
+
+	nand->read_byte		= mxs_nand_read_byte;
+
+	nand->read_buf		= mxs_nand_read_buf;
+	nand->write_buf		= mxs_nand_write_buf;
+
+	mtd->priv = nand;
+	mtd->dev = dev;
+
+	/* first scan to find the device and get the page size */
+	if (nand_scan_ident(mtd, 1)) {
+		rc = -ENXIO;
+		goto out;
+	}
+
+	nand->ecc.read_page	= mxs_nand_ecc_read_page;
+	nand->ecc.write_page	= mxs_nand_ecc_write_page;
+	nand->ecc.read_oob	= mxs_nand_ecc_read_oob;
+	nand->ecc.write_oob	= mxs_nand_ecc_write_oob;
+
+	nand->ecc.layout	= &fake_ecc_layout;
+	nand->ecc.mode		= NAND_ECC_HW;
+	nand->ecc.bytes		= 9;
+	nand->ecc.size		= 512;
+
+	nand->options          |= NAND_NO_SUBPAGE_WRITE;
+
+	/* second phase scan */
+	if (nand_scan_tail(mtd)) {
+		rc = -ENXIO;
+		goto out;
+	}
+
+	add_mtd_device(mtd, "nand");
+
+	info->fcb.timing0 = ((6 << 24) | /* dsample time */
+			     (pdata->ns_address_setup << 16) |
+			     (pdata->ns_data_hold << 8) |
+			     (pdata->ns_data_setup << 0));
+	info->fcb.timing1 = 0;
+	info->fcb.page_data_size = mtd->writesize;
+	info->fcb.total_page_size = mtd->writesize + mtd->oobsize;
+	info->fcb.pages_per_block = mtd->erasesize / mtd->writesize;
+	info->fcb.ecc_type[0] = mxs_nand_get_ecc_strength(mtd->writesize,
+							  mtd->oobsize) >> 1;
+	info->fcb.ecc_type[1] = info->fcb.ecc_type[0];
+	info->fcb.block_size[0] = MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
+	info->fcb.block_size[1] = info->fcb.block_size[0];
+	info->fcb.num_ecc_blocks = (info->fcb.page_data_size /
+				    info->fcb.block_size[0] - 1);
+	info->fcb.metadata_bytes = MXS_NAND_METADATA_SIZE;
+	info->fcb.bad_block_bit = (mxs_nand_mark_byte_offset(mtd) * 8 +
+				   mxs_nand_mark_bit_offset(mtd));
+
+	{
+		unsigned int	rev = readl(&info->gpmi_regs->hw_gpmi_version);
+
+		dev_info(dev,
+			 "NAND device initialized; controller rev. %u.%u.%u\n",
+			 (rev >> 24) & 0xff, (rev >> 16) & 0xff,
+			 (rev >>  0) & 0xffff);
+	}
+
+	rc = 0;
+
+out:
+	if (rc < 0 && info) {
+		kfree(info->data_buf);
+		kfree(info->cmd_buf);
+
+		kfree(info);
+	}
+
+	return rc;
+}
+
+static struct driver_d mxs_nand_driver = {
+	.name  = "mxs_nand",
+	.probe = mxs_nand_probe,
+};
+
+/*
+ * Main initialization routine
+ * @return  0 if successful; non-zero otherwise
+ */
+static int __init mxs_nand_init(void)
+{
+	return register_driver(&mxs_nand_driver);
+}
+device_initcall(mxs_nand_init);
diff -ruN barebox-2012.02.0/drivers/mtd/nand/nand_omap_gpmc.c barebox-2012.02.0-ccu2/drivers/mtd/nand/nand_omap_gpmc.c
--- barebox-2012.02.0/drivers/mtd/nand/nand_omap_gpmc.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/nand/nand_omap_gpmc.c	2013-01-14 12:46:35.000000000 +0100
@@ -959,6 +959,9 @@
 	dev_add_param(pdev, "eccmode", omap_gpmc_eccmode_set, NULL, 0);
 	dev_set_param(pdev, "eccmode", ecc_mode_strings[pdata->ecc_mode]);
 
+	if (! IS_ENABLED(CONFIG_PARAMETER))
+		omap_gpmc_eccmode(oinfo, pdata->ecc_mode);
+
 	/* We are all set to register with the system now! */
 	err = add_mtd_device(minfo, "nand");
 	if (err) {
diff -ruN barebox-2012.02.0/drivers/mtd/nand/nand_write.c barebox-2012.02.0-ccu2/drivers/mtd/nand/nand_write.c
--- barebox-2012.02.0/drivers/mtd/nand/nand_write.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/nand/nand_write.c	2013-01-14 12:46:35.000000000 +0100
@@ -629,8 +629,15 @@
 		/*
 		 * heck if we have a bad block, we do not erase bad blocks !
 		 */
-		if (nand_block_checkbad(mtd, ((loff_t) page) <<
-					chip->page_shift, 0, allowbbt)) {
+		if (!nand_block_checkbad(mtd, ((loff_t) page) <<
+					chip->page_shift, 0, allowbbt))
+			;		/* noop */
+		else if (instr->num_erase_bad > 0) {
+			--instr->num_erase_bad;
+			printk(KERN_INFO
+			       "nand_erase: trying to erase bad block at page 0x%08x\n",
+				page);
+		} else {
 			printk(KERN_WARNING "nand_erase: attempt to erase a "
 			       "bad block at page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
diff -ruN barebox-2012.02.0/drivers/mtd/ubi/build.c barebox-2012.02.0-ccu2/drivers/mtd/ubi/build.c
--- barebox-2012.02.0/drivers/mtd/ubi/build.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/ubi/build.c	2013-01-14 12:46:35.000000000 +0100
@@ -481,6 +481,8 @@
 	if (err)
 		goto out_wl;
 
+	ubi_do_work(ubi);
+
 	ubi_scan_destroy_si(si);
 	return 0;
 
diff -ruN barebox-2012.02.0/drivers/mtd/ubi/ubi.h barebox-2012.02.0-ccu2/drivers/mtd/ubi/ubi.h
--- barebox-2012.02.0/drivers/mtd/ubi/ubi.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/ubi/ubi.h	2013-01-14 12:46:35.000000000 +0100
@@ -645,4 +645,6 @@
 		return idx;
 }
 
+int ubi_do_work(struct ubi_device *ubi);
+
 #endif /* !__UBI_UBI_H__ */
diff -ruN barebox-2012.02.0/drivers/mtd/ubi/wl.c barebox-2012.02.0-ccu2/drivers/mtd/ubi/wl.c
--- barebox-2012.02.0/drivers/mtd/ubi/wl.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/mtd/ubi/wl.c	2013-01-14 12:46:35.000000000 +0100
@@ -288,6 +288,21 @@
 	return err;
 }
 
+int ubi_do_work(struct ubi_device *ubi)
+{
+	int		err = 0;
+
+	spin_lock(&ubi->wl_lock);
+	while (!list_empty(&ubi->works) && !err) {
+		spin_unlock(&ubi->wl_lock);
+		err = do_work(ubi);
+		spin_lock(&ubi->wl_lock);
+	}
+	spin_unlock(&ubi->wl_lock);
+
+	return err;
+}
+
 /**
  * produce_free_peb - produce a free physical eraseblock.
  * @ubi: UBI device description object
@@ -696,13 +711,6 @@
 	list_add_tail(&wrk->list, &ubi->works);
 	ubi_assert(ubi->works_count >= 0);
 	ubi->works_count += 1;
-
-	/*
-	 * U-Boot special: We have no bgt_thread in U-Boot!
-	 * So just call do_work() here directly.
-	 */
-	do_work(ubi);
-
 	spin_unlock(&ubi->wl_lock);
 }
 
diff -ruN barebox-2012.02.0/drivers/net/fec_imx.c barebox-2012.02.0-ccu2/drivers/net/fec_imx.c
--- barebox-2012.02.0/drivers/net/fec_imx.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/net/fec_imx.c	2013-01-14 12:46:35.000000000 +0100
@@ -22,21 +22,21 @@
 #include <malloc.h>
 #include <net.h>
 #include <init.h>
-#include <miidev.h>
 #include <driver.h>
 #include <miidev.h>
 #include <fec.h>
+#include <io.h>
+#include <clock.h>
+#include <xfuncs.h>
 
 #include <asm/mmu.h>
-#include <io.h>
+
 #include <mach/generic.h>
 #include <mach/imx-regs.h>
-#include <clock.h>
 #include <mach/clock.h>
 #ifndef CONFIG_ARCH_MXS
 # include <mach/iim.h>
 #endif
-#include <xfuncs.h>
 
 #include "fec_imx.h"
 
@@ -274,6 +274,7 @@
 static int fec_init(struct eth_device *dev)
 {
 	struct fec_priv *fec = (struct fec_priv *)dev->priv;
+	u32 rcntl;
 
 	/*
 	 * Clear FEC-Lite interrupt event register(IEVENT)
@@ -288,17 +289,9 @@
 	/*
 	 * Set FEC-Lite receive control register(R_CNTRL):
 	 */
-	if (fec->xcv_type == SEVENWIRE) {
-		/*
-		 * Frame length=1518; 7-wire mode
-		 */
-		writel(FEC_R_CNTRL_MAX_FL(1518), fec->regs + FEC_R_CNTRL);
-	} else {
-		/*
-		 * Frame length=1518; MII mode;
-		 */
-		writel(FEC_R_CNTRL_MAX_FL(1518) | FEC_R_CNTRL_MII_MODE,
-			fec->regs + FEC_R_CNTRL);
+	rcntl = FEC_R_CNTRL_MAX_FL(1518);
+	if (fec->xcv_type != SEVENWIRE) {
+		rcntl |= FEC_R_CNTRL_MII_MODE;
 		/*
 		 * Set MII_SPEED = (1/(mii_speed * 2)) * System Clock
 		 * and do not drop the Preamble.
@@ -309,13 +302,8 @@
 
 	if (fec->xcv_type == RMII) {
 		if (cpu_is_mx28()) {
-			/* just another way to enable RMII */
-			uint32_t reg = readl(fec->regs + FEC_R_CNTRL);
-			writel(reg | FEC_R_CNTRL_RMII_MODE
-				/* the linux driver add these bits, why not we? */
-				/* | FEC_R_CNTRL_FCE | */
-				/* FEC_R_CNTRL_NO_LGTH_CHECK */,
-				fec->regs + FEC_R_CNTRL);
+			rcntl |= FEC_R_CNTRL_RMII_MODE | FEC_R_CNTRL_FCE |
+				FEC_R_CNTRL_NO_LGTH_CHECK;
 		} else {
 			/* disable the gasket and wait */
 			writel(0, fec->regs + FEC_MIIGSK_ENR);
@@ -329,6 +317,7 @@
 			writel(FEC_MIIGSK_ENR_EN, fec->regs + FEC_MIIGSK_ENR);
 		}
 	}
+	writel(rcntl, fec->regs + FEC_R_CNTRL);
 
 	/*
 	 * Set Opcode/Pause Duration Register
@@ -384,6 +373,17 @@
 		ret = miidev_wait_aneg(&fec->miidev);
 		if (ret)
 			return ret;
+
+		ret = miidev_get_status(&fec->miidev);
+		if (ret < 0)
+			return ret;
+
+		if (ret & MIIDEV_STATUS_IS_10MBIT) {
+			u32 rcntl = readl(fec->regs + FEC_R_CNTRL);
+			rcntl |= FEC_R_CNTRL_RMII_10T;
+			writel(rcntl, fec->regs + FEC_R_CNTRL);
+		}
+
 		miidev_print_status(&fec->miidev);
 	}
 
diff -ruN barebox-2012.02.0/drivers/net/fec_imx.h barebox-2012.02.0-ccu2/drivers/net/fec_imx.h
--- barebox-2012.02.0/drivers/net/fec_imx.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/net/fec_imx.h	2013-01-14 12:46:35.000000000 +0100
@@ -94,20 +94,6 @@
 #define FEC_IMASK_COL_RETRY_LIM         0x00100000
 #define FEC_IMASK_XFIFO_UN              0x00080000
 
-#define FEC_RCNTRL_MAX_FL_SHIFT         16
-#define FEC_RCNTRL_LOOP                 0x01
-#define FEC_RCNTRL_DRT                  0x02
-#define FEC_RCNTRL_MII_MODE             0x04
-#define FEC_RCNTRL_PROM                 0x08
-#define FEC_RCNTRL_BC_REJ               0x10
-#define FEC_RCNTRL_FCE                  0x20
-
-#define FEC_TCNTRL_GTS                  0x00000001
-#define FEC_TCNTRL_HBC                  0x00000002
-#define FEC_TCNTRL_FDEN                 0x00000004
-#define FEC_TCNTRL_TFC_PAUSE            0x00000008
-#define FEC_TCNTRL_RFC_PAUSE            0x00000010
-
 #define FEC_ECNTRL_RESET                0x00000001	/**< reset the FEC */
 #define FEC_ECNTRL_ETHER_EN             0x00000002	/**< enable the FEC */
 
diff -ruN barebox-2012.02.0/drivers/net/miidev.c barebox-2012.02.0-ccu2/drivers/net/miidev.c
--- barebox-2012.02.0/drivers/net/miidev.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/net/miidev.c	2013-01-14 12:46:35.000000000 +0100
@@ -30,23 +30,37 @@
 
 int miidev_restart_aneg(struct mii_device *mdev)
 {
-	uint16_t status;
-	int timeout;
+	int status, timeout;
+	uint64_t start;
+
+	status = mii_write(mdev, mdev->address, MII_BMCR, BMCR_RESET);
+	if (status)
+		return status;
+
+	start = get_time_ns();
+	do {
+		status = mii_read(mdev, mdev->address, MII_BMCR);
+		if (status < 0)
+			return status;
 
-	/*
-	 * Reset PHY, then delay 300ns
-	 */
-	mii_write(mdev, mdev->address, MII_BMCR, BMCR_RESET);
+		if (is_timeout(start, SECOND))
+			return -ETIMEDOUT;
+
+	} while (status & BMCR_RESET);
 
 	if (mdev->flags & MIIDEV_FORCE_LINK)
 		return 0;
 
-	udelay(1000);
-
 	if (mdev->flags & MIIDEV_FORCE_10) {
 		printf("Forcing 10 Mbps ethernet link... ");
+
 		status = mii_read(mdev, mdev->address, MII_BMSR);
-		mii_write(mdev, mdev->address, MII_BMCR, BMCR_FULLDPLX | BMCR_CTST);
+		if (status < 0)
+			return status;
+
+		status = mii_write(mdev, mdev->address, MII_BMCR, BMCR_FULLDPLX | BMCR_CTST);
+		if (status)
+			return status;
 
 		timeout = 20;
 		do {	/* wait for link status to go down */
@@ -56,6 +70,8 @@
 				break;
 			}
 			status = mii_read(mdev, mdev->address, MII_BMSR);
+			if (status < 0)
+				return status;
 		} while (status & BMSR_LSTATUS);
 
 	} else {	/* MII100 */
@@ -63,10 +79,18 @@
 		 * Set the auto-negotiation advertisement register bits
 		 */
 		status = mii_read(mdev, mdev->address, MII_ADVERTISE);
+		if (status < 0)
+			return status;
+
 		status |= ADVERTISE_ALL;
-		mii_write(mdev, mdev->address, MII_ADVERTISE, status);
 
-		mii_write(mdev, mdev->address, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+		status = mii_write(mdev, mdev->address, MII_ADVERTISE, status);
+		if (status)
+			return status;
+
+		status = mii_write(mdev, mdev->address, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+		if (status)
+			return status;
 	}
 
 	return 0;
@@ -74,70 +98,84 @@
 
 int miidev_wait_aneg(struct mii_device *mdev)
 {
-	uint64_t start;
 	int status;
+	uint64_t start = get_time_ns();
 
 	if (mdev->flags & MIIDEV_FORCE_LINK)
 		return 0;
 
-	/*
-	 * Wait for AN completion
-	 */
-	start = get_time_ns();
 	do {
+		status = mii_read(mdev, mdev->address, MII_BMSR);
+		if (status < 0)
+			return status;
+
 		if (is_timeout(start, 5 * SECOND)) {
 			printf("%s: Autonegotiation timeout\n", mdev->cdev.name);
-			return -1;
+			return -ETIMEDOUT;
 		}
 
-		status = mii_read(mdev, mdev->address, MII_BMSR);
-		if (status < 0) {
-			printf("%s: Autonegotiation failed. status: 0x%04x\n", mdev->cdev.name, status);
-			return -1;
-		}
 	} while (!(status & BMSR_LSTATUS));
 
 	return 0;
 }
 
+int miidev_get_status(struct mii_device *mdev)
+{
+	int ret, status;
+
+	ret = mii_read(mdev, mdev->address, MII_BMSR);
+	if (ret < 0)
+		goto err_out;
+
+	status = ret & BMSR_LSTATUS ? MIIDEV_STATUS_IS_UP : 0;
+
+	ret = mii_read(mdev, mdev->address, MII_BMCR);
+	if (ret < 0)
+		goto err_out;
+
+	if (ret & BMCR_ANENABLE) {
+		ret = mii_read(mdev, mdev->address, MII_LPA);
+		if (ret < 0)
+			goto err_out;
+
+		status |= ret & LPA_DUPLEX ? MIIDEV_STATUS_IS_FULL_DUPLEX : 0;
+		status |= ret & LPA_100 ? MIIDEV_STATUS_IS_100MBIT :
+				MIIDEV_STATUS_IS_10MBIT;
+	} else {
+		status |= ret & BMCR_FULLDPLX ? MIIDEV_STATUS_IS_FULL_DUPLEX : 0;
+		status |= ret & BMCR_SPEED100 ? MIIDEV_STATUS_IS_100MBIT :
+			MIIDEV_STATUS_IS_10MBIT;
+	}
+
+	return status;
+err_out:
+	printf("%s: failed to read (%d)\n", mdev->cdev.name, ret);
+	return ret;
+}
+
 int miidev_print_status(struct mii_device *mdev)
 {
-	int bmsr, bmcr, lpa;
 	char *duplex;
-	int speed;
+	int speed, status;
 
 	if (mdev->flags & MIIDEV_FORCE_LINK) {
 		printf("Forcing link present...\n");
 		return 0;
 	}
 
-	bmsr = mii_read(mdev, mdev->address, MII_BMSR);
-	if (bmsr < 0)
-		goto err_out;
-	bmcr = mii_read(mdev, mdev->address, MII_BMCR);
-	if (bmcr < 0)
-		goto err_out;
-	lpa = mii_read(mdev, mdev->address, MII_LPA);
-	if (lpa < 0)
-		goto err_out;
+	status = miidev_get_status(mdev);
+	if (status < 0)
+		return status;
 
-	printf("%s: Link is %s", mdev->cdev.name,
-			bmsr & BMSR_LSTATUS ? "up" : "down");
+	duplex = status & MIIDEV_STATUS_IS_FULL_DUPLEX ? "Full" : "Half";
+	speed = status & MIIDEV_STATUS_IS_100MBIT ? 100 : 10;
 
-	if (bmcr & BMCR_ANENABLE) {
-		duplex = lpa & LPA_DUPLEX ? "Full" : "Half";
-		speed = lpa & LPA_100 ? 100 : 10;
-	} else {
-		duplex = bmcr & BMCR_FULLDPLX ? "Full" : "Half";
-		speed = bmcr & BMCR_SPEED100 ? 100 : 10;
-	}
 
+	printf("%s: Link is %s", mdev->cdev.name,
+			status & MIIDEV_STATUS_IS_UP ? "up" : "down");
 	printf(" - %d/%s\n", speed, duplex);
 
 	return 0;
-err_out:
-	printf("%s: failed to read\n", mdev->cdev.name);
-	return -1;
 }
 
 static ssize_t miidev_read(struct cdev *cdev, void *_buf, size_t count, ulong offset, ulong flags)
diff -ruN barebox-2012.02.0/drivers/net/netx_eth.c barebox-2012.02.0-ccu2/drivers/net/netx_eth.c
--- barebox-2012.02.0/drivers/net/netx_eth.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/net/netx_eth.c	2013-01-14 12:46:35.000000000 +0100
@@ -130,7 +130,7 @@
 	value = MIIMU_REG >> 16;
 
 	debug("%s: addr: 0x%02x reg: 0x%02x val: 0x%04x\n", __func__,
-	      addr, reg, value);
+	      phy_addr, reg, value);
 
 	return value;
 }
@@ -139,7 +139,7 @@
 	int reg, int val)
 {
 	debug("%s: addr: 0x%02x reg: 0x%02x val: 0x%04x\n",__func__,
-	      addr, reg, val);
+	      phy_addr, reg, val);
 
 	MIIMU_REG = MIIMU_SNRDY | MIIMU_PREAMBLE | MIIMU_PHYADDR(phy_addr) |
 	            MIIMU_REGADDR(reg) | MIIMU_PHY_NRES | MIIMU_OPMODE_WRITE |
diff -ruN barebox-2012.02.0/drivers/serial/Kconfig barebox-2012.02.0-ccu2/drivers/serial/Kconfig
--- barebox-2012.02.0/drivers/serial/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/serial/Kconfig	2013-01-14 12:46:35.000000000 +0100
@@ -18,6 +18,11 @@
 	default y
 	bool "i.MX serial driver"
 
+config DRIVER_SERIAL_IMXAPP
+	depends on ARCH_IMX || ARCH_MXS
+	default y
+	bool "i.MX application serial driver"
+
 config DRIVER_SERIAL_STM378X
 	depends on ARCH_MXS
 	default y
diff -ruN barebox-2012.02.0/drivers/serial/Makefile barebox-2012.02.0-ccu2/drivers/serial/Makefile
--- barebox-2012.02.0/drivers/serial/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/serial/Makefile	2013-01-14 12:46:35.000000000 +0100
@@ -7,6 +7,7 @@
 obj-$(CONFIG_DRIVER_SERIAL_ARM_DCC)		+= arm_dcc.o
 obj-$(CONFIG_SERIAL_AMBA_PL011)			+= amba-pl011.o
 obj-$(CONFIG_DRIVER_SERIAL_IMX)			+= serial_imx.o
+obj-$(CONFIG_DRIVER_SERIAL_IMXAPP)		+= serial_imxapp.o
 obj-$(CONFIG_DRIVER_SERIAL_STM378X)		+= stm-serial.o
 obj-$(CONFIG_DRIVER_SERIAL_ATMEL)		+= atmel.o
 obj-$(CONFIG_DRIVER_SERIAL_NETX)		+= serial_netx.o
diff -ruN barebox-2012.02.0/drivers/serial/serial_imxapp.c barebox-2012.02.0-ccu2/drivers/serial/serial_imxapp.c
--- barebox-2012.02.0/drivers/serial/serial_imxapp.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/serial/serial_imxapp.c	2013-01-14 12:46:35.000000000 +0100
@@ -0,0 +1,261 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <common.h>
+#include <mach/imx-regs.h>
+#include <debug_ll.h>
+#include <mach/clock.h>
+#include <notifier.h>
+#include <driver.h>
+#include <init.h>
+#include <errno.h>
+#include <asm/io.h>
+
+#define HW_UARTAPP_CTRL0	0x00
+#define HW_UARTAPP_CTRL0_set	0x04
+#define HW_UARTAPP_CTRL0_clr	0x08
+#define HW_UARTAPP_CTRL1	0x10
+#define HW_UARTAPP_CTRL2	0x20
+#define HW_UARTAPP_CTRL2_set	0x24
+#define HW_UARTAPP_CTRL2_clr	0x28
+#define HW_UARTAPP_LINECTRL	0x30
+#define HW_UARTAPP_LINECTRL2	0x40
+#define HW_UARTAPP_INTR		0x50
+#define HW_UARTAPP_INTR_clr	0x58
+#define HW_UARTAPP_DATA		0x60
+#define HW_UARTAPP_STAT		0x70
+#define HW_UARTAPP_DEBUG	0x80
+#define HW_UARTAPP_VERSION	0x90
+#define HW_UARTAPP_AUTOBAUD	0xa0
+
+#define HW_UARTAPP_LINECTRL_BRK		(1u << 0)
+#define HW_UARTAPP_LINECTRL_PEN		(1u << 1)
+#define HW_UARTAPP_LINECTRL_EPS		(1u << 2)
+#define HW_UARTAPP_LINECTRL_STP2	(1u << 3)
+#define HW_UARTAPP_LINECTRL_FEN		(1u << 4)
+#define HW_UARTAPP_LINECTRL_WLEN_msk	(3u << 5)
+#define HW_UARTAPP_LINECTRL_WLEN_5	(0u << 5)
+#define HW_UARTAPP_LINECTRL_WLEN_6	(1u << 5)
+#define HW_UARTAPP_LINECTRL_WLEN_7	(2u << 5)
+#define HW_UARTAPP_LINECTRL_WLEN_8	(3u << 5)
+#define HW_UARTAPP_LINECTRL_SPS		(1u << 7)
+#define HW_UARTAPP_LINECTRL_BAUD_DIVFRAC_sft	(8)
+#define HW_UARTAPP_LINECTRL_BAUD_DIVFRAC_msk	(0x3fu << 8)
+#define HW_UARTAPP_LINECTRL_BAUD_DIVINT_sft	(16)
+#define HW_UARTAPP_LINECTRL_BAUD_DIVINT_msk	(0xffffu << 16)
+
+#define HW_UARTAPP_CTRL2_UARTEN		(1u << 0)
+#define HW_UARTAPP_CTRL2_SIREN		(1u << 1) /* unsupported */
+#define HW_UARTAPP_CTRL2_SIRLP		(1u << 2) /* unsupported */
+#define HW_UARTAPP_CTRL2_USE_LCR2	(1u << 6)
+#define HW_UARTAPP_CTRL2_LBE		(1u << 7)
+#define HW_UARTAPP_CTRL2_TXE		(1u << 8)
+#define HW_UARTAPP_CTRL2_RXE		(1u << 9)
+#define HW_UARTAPP_CTRL2_DTR		(1u << 10) /* unsupported */
+#define HW_UARTAPP_CTRL2_RTS		(1u << 11)
+#define HW_UARTAPP_CTRL2_OUT1		(1u << 12)
+#define HW_UARTAPP_CTRL2_OUT2		(1u << 13)
+#define HW_UARTAPP_CTRL2_RTSEN		(1u << 14)
+#define HW_UARTAPP_CTRL2_CTSEN		(1u << 15)
+#define HW_UARTAPP_CTRL2_TXIFLSEL_msk	(7u << 16)
+#define HW_UARTAPP_CTRL2_RXIFLSEL_msk	(7u << 20)
+#define HW_UARTAPP_CTRL2_RXDMAE		(7u << 24)
+#define HW_UARTAPP_CTRL2_TXDMAE		(7u << 25)
+#define HW_UARTAPP_CTRL2_DMAONERR	(7u << 26)
+#define HW_UARTAPP_CTRL2_RTS_SEMAPHORE	(7u << 27)
+#define HW_UARTAPP_CTRL2_INVERT_RX	(7u << 28)
+#define HW_UARTAPP_CTRL2_INVERT_TX	(7u << 29)
+#define HW_UARTAPP_CTRL2_INVERT_CTX	(7u << 30)
+#define HW_UARTAPP_CTRL2_INVERT_RTS	(7u << 31)
+
+#define HW_UARTAPP_CTRL0_SFTRST		(1u << 31)
+#define HW_UARTAPP_CTRL0_CLKGATE	(1u << 30)
+
+#define HW_UARTAPP_STAT_RXCOUNT_msk	(0xffffu)
+#define HW_UARTAPP_STAT_FERR		(1u << 16)
+#define HW_UARTAPP_STAT_PERR		(1u << 17)
+#define HW_UARTAPP_STAT_BERR		(1u << 18)
+#define HW_UARTAPP_STAT_OERR		(1u << 19)
+#define HW_UARTAPP_STAT_RXFE		(1u << 24)
+#define HW_UARTAPP_STAT_TXFF		(1u << 25)
+#define HW_UARTAPP_STAT_RXFF		(1u << 26)
+#define HW_UARTAPP_STAT_TXFE		(1u << 27)
+#define HW_UARTAPP_STAT_CTS		(1u << 28)
+#define HW_UARTAPP_STAT_BUSY		(1u << 29)
+#define HW_UARTAPP_STAT_HISPEED		(1u << 30)
+#define HW_UARTAPP_STAT_PRESENT		(1u << 31)
+
+struct imxapp_serial_priv {
+	struct console_device	cdev;
+	int			baudrate;
+	void __iomem		*regs;
+};
+#define cdev_to_imxapp(_cdev) \
+	container_of((_cdev), struct imxapp_serial_priv, cdev)
+
+static void imxapp_serial_putc(struct console_device *cdev, char c)
+{
+	struct imxapp_serial_priv	*priv = cdev_to_imxapp(cdev);
+	void __iomem			*regs = priv->regs;
+
+	/* Wait for room in TX FIFO */
+	while (readl(regs + HW_UARTAPP_STAT) & HW_UARTAPP_STAT_TXFF)
+		;			/* noop */
+
+	writel(c, regs + HW_UARTAPP_DATA);
+}
+
+static int imxapp_serial_tstc(struct console_device *cdev)
+{
+	struct imxapp_serial_priv	*priv = cdev_to_imxapp(cdev);
+	void __iomem			*regs = priv->regs;
+
+	/* Check if RX FIFO is not empty */
+	return !(readl(regs + HW_UARTAPP_STAT) & HW_UARTAPP_STAT_RXFE);
+}
+
+static int imxapp_serial_getc(struct console_device *cdev)
+{
+	struct imxapp_serial_priv	*priv = cdev_to_imxapp(cdev);
+	void __iomem			*regs = priv->regs;
+
+	/* Wait while TX FIFO is empty */
+	while (readl(regs + HW_UARTAPP_STAT) & HW_UARTAPP_STAT_RXFE)
+		;
+
+	return readl(regs + HW_UARTAPP_DATA) & 0xff;
+}
+
+static void imxapp_serial_flush(struct console_device *cdev)
+{
+	struct imxapp_serial_priv	*priv = cdev_to_imxapp(cdev);
+	void __iomem			*regs = priv->regs;
+
+	/* Wait for TX FIFO empty */
+	while (!(readl(regs + HW_UARTAPP_STAT) & HW_UARTAPP_STAT_TXFE))
+		;
+}
+
+static int imxapp_serial_setbaudrate(struct console_device *cdev, int new_baudrate)
+{
+	struct imxapp_serial_priv	*priv = cdev_to_imxapp(cdev);
+	void __iomem	*regs = priv->regs;
+	uint32_t	ctl2 = readl(regs + HW_UARTAPP_CTRL2);
+	uint32_t	lctl = (readl(regs + HW_UARTAPP_LINECTRL) &
+				~(HW_UARTAPP_LINECTRL_BAUD_DIVINT_msk |
+				  HW_UARTAPP_LINECTRL_BAUD_DIVFRAC_msk));
+	unsigned int	divisor;
+
+	if (new_baudrate > 3250000 || new_baudrate < 300)
+		return -EINVAL;
+
+	/* disable UART */
+	if (ctl2 & HW_UARTAPP_CTRL2_UARTEN) {
+		imxapp_serial_flush(cdev);
+		writel(HW_UARTAPP_CTRL2_UARTEN,
+		       regs + HW_UARTAPP_CTRL2_clr);
+	}
+
+	divisor = (24000000 * 32u + new_baudrate/2) / new_baudrate;
+	lctl |= ((divisor >> 6) & 0xffffu) << HW_UARTAPP_LINECTRL_BAUD_DIVINT_sft;
+	lctl |= ((divisor >> 0) & 0x3fu) << HW_UARTAPP_LINECTRL_BAUD_DIVFRAC_sft;
+
+	writel(lctl, regs + HW_UARTAPP_LINECTRL);
+	priv->baudrate = new_baudrate;
+
+	if (ctl2 & HW_UARTAPP_CTRL2_UARTEN)
+		writel(HW_UARTAPP_CTRL2_UARTEN, regs + HW_UARTAPP_CTRL2_set);
+
+	return 0;
+}
+
+static void imxapp_serial_init_port(struct console_device *cdev)
+{
+	struct imxapp_serial_priv	*priv = cdev_to_imxapp(cdev);
+	void __iomem			*regs = priv->regs;
+
+	writel(HW_UARTAPP_CTRL0_SFTRST, regs + HW_UARTAPP_CTRL0_clr);
+	while (readl(regs + HW_UARTAPP_CTRL0) & HW_UARTAPP_CTRL0_SFTRST)
+		;			/* noop */
+
+	writel(HW_UARTAPP_CTRL0_CLKGATE, regs + HW_UARTAPP_CTRL0_clr);
+	while (readl(regs + HW_UARTAPP_CTRL0) & HW_UARTAPP_CTRL0_CLKGATE)
+		;			/* noop */
+
+	if (readl(regs + HW_UARTAPP_CTRL2) & HW_UARTAPP_CTRL2_UARTEN)
+		imxapp_serial_flush(cdev);
+
+	writel(HW_UARTAPP_LINECTRL_FEN |
+	       HW_UARTAPP_LINECTRL_WLEN_8 |
+	       (0x68 << 16) | (0xb << 8),
+	       regs + HW_UARTAPP_LINECTRL);
+
+	writel(HW_UARTAPP_CTRL2_RXE |
+	       HW_UARTAPP_CTRL2_TXE |
+	       (2 << 16) | (2 << 20),
+	       regs + HW_UARTAPP_CTRL2);
+
+	writel(~0u, regs + HW_UARTAPP_INTR_clr);
+}
+
+static int imxapp_serial_probe(struct device_d *dev)
+{
+	struct console_device		*cdev;
+	struct imxapp_serial_priv	*priv;
+
+	priv = xmalloc(sizeof(*priv));
+	cdev = &priv->cdev;
+
+	priv->regs = dev_request_mem_region(dev, 0);
+	dev->type_data = cdev;
+	cdev->dev = dev;
+	cdev->f_caps = CONSOLE_STDIN | CONSOLE_STDOUT | CONSOLE_STDERR;
+	cdev->tstc = imxapp_serial_tstc;
+	cdev->putc = imxapp_serial_putc;
+	cdev->getc = imxapp_serial_getc;
+	cdev->flush = imxapp_serial_flush;
+	cdev->setbrg = imxapp_serial_setbaudrate;
+
+	imxapp_serial_init_port(cdev);
+	imxapp_serial_setbaudrate(cdev, 115200);
+
+	/* Enable UART */
+	writel(HW_UARTAPP_CTRL2_UARTEN, priv->regs + HW_UARTAPP_CTRL2_set);
+
+	console_register(cdev);
+
+	return 0;
+}
+
+static void imxapp_serial_remove(struct device_d *dev)
+{
+	struct console_device *cdev = dev->type_data;
+
+	imxapp_serial_flush(cdev);
+}
+
+static struct driver_d imxapp_serial_driver = {
+        .name   = "imxapp_serial",
+        .probe  = imxapp_serial_probe,
+	.remove = imxapp_serial_remove,
+};
+
+static int imxapp_serial_init(void)
+{
+	register_driver(&imxapp_serial_driver);
+	return 0;
+}
+console_initcall(imxapp_serial_init);
diff -ruN barebox-2012.02.0/drivers/serial/serial_ns16550.c barebox-2012.02.0-ccu2/drivers/serial/serial_ns16550.c
--- barebox-2012.02.0/drivers/serial/serial_ns16550.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/serial/serial_ns16550.c	2013-01-14 12:46:35.000000000 +0100
@@ -47,6 +47,7 @@
 #include <ns16550.h>
 
 /*********** Private Functions **********************************/
+static int ns16550_setbaudrate(struct console_device *cdev, int baud_rate);
 
 /**
  * @brief read register
@@ -120,7 +121,7 @@
  *
  * @return divisor to be set
  */
-static unsigned int ns16550_calc_divisor(struct console_device *cdev,
+static inline unsigned int ns16550_calc_divisor(struct console_device *cdev,
 					 unsigned int baudrate)
 {
 	struct NS16550_plat *plat = (struct NS16550_plat *)
@@ -138,22 +139,16 @@
  */
 static void ns16550_serial_init_port(struct console_device *cdev)
 {
-	unsigned int baud_divisor;
-
-	/* Setup the serial port with the defaults first */
-	baud_divisor = ns16550_calc_divisor(cdev, CONFIG_BAUDRATE);
-
 	/* initializing the device for the first time */
+	ns16550_write(cdev, 0x00, lcr); /* select ier reg */
 	ns16550_write(cdev, 0x00, ier);
+
 #ifdef CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS
 	ns16550_write(cdev, 0x07, mdr1);	/* Disable */
 #endif
-	ns16550_write(cdev, LCR_BKSE | LCRVAL, lcr);
-	ns16550_write(cdev, baud_divisor & 0xFF, dll);
-	ns16550_write(cdev, (baud_divisor >> 8) & 0xff, dlm);
-	ns16550_write(cdev, LCRVAL, lcr);
-	ns16550_write(cdev, MCRVAL, mcr);
-	ns16550_write(cdev, FCRVAL, fcr);
+
+	ns16550_setbaudrate(cdev, CONFIG_BAUDRATE);
+
 #ifdef CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS
 	ns16550_write(cdev, 0x00,  mdr1);
 #endif
@@ -211,14 +206,20 @@
 static int ns16550_setbaudrate(struct console_device *cdev, int baud_rate)
 {
 	unsigned int baud_divisor = ns16550_calc_divisor(cdev, baud_rate);
+	struct NS16550_plat *plat = (struct NS16550_plat *)
+	    cdev->dev->platform_data;
 
-	ns16550_write(cdev, 0x00, ier);
 	ns16550_write(cdev, LCR_BKSE, lcr);
 	ns16550_write(cdev, baud_divisor & 0xff, dll);
 	ns16550_write(cdev, (baud_divisor >> 8) & 0xff, dlm);
 	ns16550_write(cdev, LCRVAL, lcr);
 	ns16550_write(cdev, MCRVAL, mcr);
-	ns16550_write(cdev, FCRVAL, fcr);
+
+	if (plat->flags & NS16650_FLAG_DISABLE_FIFO)
+		ns16550_write(cdev, FCRVAL & ~FCR_FIFO_EN, fcr);
+	else
+		ns16550_write(cdev, FCRVAL, fcr);
+
 	return 0;
 }
 
diff -ruN barebox-2012.02.0/drivers/usb/host/ehci.h barebox-2012.02.0-ccu2/drivers/usb/host/ehci.h
--- barebox-2012.02.0/drivers/usb/host/ehci.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/usb/host/ehci.h	2013-01-14 12:46:35.000000000 +0100
@@ -55,7 +55,7 @@
 #define HCS_N_PORTS(p)		(((p) >> 0) & 0xf)
 	uint32_t cr_hccparams;
 	uint8_t cr_hcsp_portrt[8];
-} __attribute__ ((packed));
+} __attribute__ ((packed, aligned(4)));
 
 struct ehci_hcor {
 	uint32_t or_usbcmd;
@@ -80,7 +80,7 @@
 #define FLAG_CF		(1 << 0)	/* true:  we'll support "high speed" */
 	uint32_t or_portsc[CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS];
 	uint32_t or_systune;
-} __attribute__ ((packed));
+} __attribute__ ((packed, aligned(4)));
 
 #define USBMODE		0x68		/* USB Device mode */
 #define USBMODE_SDIS	(1 << 3)	/* Stream disable */
diff -ruN barebox-2012.02.0/drivers/video/imx-ipu-fb.c barebox-2012.02.0-ccu2/drivers/video/imx-ipu-fb.c
--- barebox-2012.02.0/drivers/video/imx-ipu-fb.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/video/imx-ipu-fb.c	2013-01-14 12:46:35.000000000 +0100
@@ -39,6 +39,7 @@
 	void			(*enable)(int enable);
 
 	struct fb_info		info;
+	struct fb_info		overlay;
 	struct device_d		*dev;
 };
 
@@ -465,10 +466,13 @@
 	case IPU_PANEL_SHARP_TFT:
 		reg_write(fbi, 0x00FD0102L, SDC_SHARP_CONF_1);
 		reg_write(fbi, 0x00F500F4L, SDC_SHARP_CONF_2);
-		reg_write(fbi, SDC_COM_SHARP | SDC_COM_TFT_COLOR, SDC_COM_CONF);
+		reg = reg_read(fbi, SDC_COM_CONF);
+		reg_write(fbi, reg | SDC_COM_SHARP | SDC_COM_TFT_COLOR,
+							SDC_COM_CONF);
 		break;
 	case IPU_PANEL_TFT:
-		reg_write(fbi, SDC_COM_TFT_COLOR, SDC_COM_CONF);
+		reg = reg_read(fbi, SDC_COM_CONF) & ~SDC_COM_SHARP;
+		reg_write(fbi, reg | SDC_COM_TFT_COLOR, SDC_COM_CONF);
 		break;
 	default:
 		return -EINVAL;
@@ -607,6 +611,7 @@
 
 	switch (channel) {
 	case IDMAC_SDC_0:
+	case IDMAC_SDC_1:
 		/* In original code only IPU_PIX_FMT_RGB565 was setting burst */
 		params.pp.npb = 16 - 1;
 		break;
@@ -651,6 +656,7 @@
 
 	switch (channel) {
 	case IDMAC_SDC_0:
+	case IDMAC_SDC_1:
 		ipu_channel_set_priority(fbi, channel, 1);
 		break;
 	default:
@@ -701,17 +707,21 @@
 	return ret;
 }
 
-static void sdc_enable_channel(struct ipu_fb_info *fbi, void *fbmem)
+static void sdc_enable_channel(struct ipu_fb_info *fbi, void *fbmem,
+				enum ipu_channel channel)
 {
-	int ret;
+	int ret = 0;
 	u32 reg;
 
-	ret = idmac_tx_submit(fbi, IDMAC_SDC_0, fbmem);
+	ret = idmac_tx_submit(fbi, channel, fbmem);
 
 	/* mx3fb.c::sdc_fb_init() */
 	if (ret >= 0) {
 		reg = reg_read(fbi, SDC_COM_CONF);
-		reg_write(fbi, reg | SDC_COM_BG_EN, SDC_COM_CONF);
+		if (channel == IDMAC_SDC_1)
+			reg_write(fbi, reg | SDC_COM_FG_EN, SDC_COM_CONF);
+		else
+			reg_write(fbi, reg | SDC_COM_BG_EN, SDC_COM_CONF);
 	}
 
 	/*
@@ -735,7 +745,7 @@
 
 	/* Start the clock */
 	reg = readl(IMX_CCM_BASE + CCM_CGR1);
-	reg |= (3 << 22);
+	reg |= (3 << 18);
 	writel(reg, IMX_CCM_BASE + CCM_CGR1);
 
 	/* ipu_idmac.c::ipu_idmac_init() */
@@ -743,14 +753,12 @@
 	/* Service request counter to maximum - shouldn't be needed */
 	reg_write(fbi, 0x00000070, IDMAC_CONF);
 
-
 	/* ipu_idmac.c::ipu_init_channel() */
 
 	/* Enable IPU sub modules */
 	reg = reg_read(fbi, IPU_CONF) | IPU_CONF_SDC_EN | IPU_CONF_DI_EN;
 	reg_write(fbi, reg, IPU_CONF);
 
-
 	/* mx3fb.c::init_fb_chan() */
 
 	/* set Display Interface clock period */
@@ -771,12 +779,11 @@
 	reg = reg_read(fbi, SDC_COM_CONF);
 	reg_write(fbi, reg | SDC_COM_GLB_A, SDC_COM_CONF);
 
-
 	/* mx3fb.c::sdc_set_color_key() */
 
 	/* Disable colour-keying for background */
 	reg = reg_read(fbi, SDC_COM_CONF) &
-		~(SDC_COM_GWSEL | SDC_COM_KEY_COLOR_G);
+		~(SDC_COM_KEY_COLOR_G);
 	reg_write(fbi, reg, SDC_COM_CONF);
 
 	sdc_init_panel(info, IPU_PIX_FMT_RGB666);
@@ -784,7 +791,7 @@
 	reg_write(fbi, (mode->left_margin << 16) | mode->upper_margin,
 			SDC_BG_POS);
 
-	sdc_enable_channel(fbi, info->screen_base);
+	sdc_enable_channel(fbi, info->screen_base, IDMAC_SDC_0);
 
 	/*
 	 * Linux driver calls sdc_set_brightness() here again,
@@ -807,9 +814,25 @@
 	reg_write(fbi, reg, SDC_COM_CONF);
 }
 
+static int ipu_fb_activate_var(struct fb_info *info)
+{
+#ifdef CONFIG_DRIVER_VIDEO_IMX_IPU_OVERLAY
+	struct ipu_fb_info *fbi = info->priv;
+	struct fb_info *overlay = &fbi->overlay;
+
+	/* overlay also needs to know the new values */
+	overlay->mode = info->mode;
+	overlay->xres = info->xres;
+	overlay->yres = info->yres;
+#endif
+
+	return 0;
+}
+
 static struct fb_ops imxfb_ops = {
 	.fb_enable = ipu_fb_enable,
 	.fb_disable = ipu_fb_disable,
+	.fb_activate_var = ipu_fb_activate_var,
 };
 
 static void imxfb_init_info(struct fb_info *info, struct fb_videomode *mode,
@@ -845,12 +868,121 @@
 	info->transp = rgb->transp;
 }
 
+#ifdef CONFIG_DRIVER_VIDEO_IMX_IPU_OVERLAY
+
+static void ipu_fb_overlay_enable_controller(struct fb_info *overlay)
+{
+	struct ipu_fb_info *fbi = overlay->priv;
+	struct fb_videomode *mode = overlay->mode;
+	int reg;
+
+	sdc_init_panel(overlay, IPU_PIX_FMT_RGB666);
+
+	reg_write(fbi, (mode->left_margin << 16) | mode->upper_margin,
+							SDC_FG_POS);
+
+	reg = reg_read(fbi, SDC_COM_CONF);
+	reg_write(fbi, reg | SDC_COM_GWSEL, SDC_COM_CONF);
+
+	if (fbi->enable)
+		fbi->enable(1);
+
+	sdc_enable_channel(fbi, overlay->screen_base, IDMAC_SDC_1);
+}
+
+static void ipu_fb_overlay_disable_controller(struct fb_info *overlay)
+{
+	struct ipu_fb_info *fbi = overlay->priv;
+	u32 reg;
+
+	if (fbi->enable)
+		fbi->enable(0);
+
+	/* Disable foreground and set graphic window to background */
+	reg = reg_read(fbi, SDC_COM_CONF);
+	reg &= ~(SDC_COM_FG_EN | SDC_COM_GWSEL);
+	reg_write(fbi, reg, SDC_COM_CONF);
+}
+
+static int ipu_fb_overlay_setcolreg(u_int regno, u_int red, u_int green,
+		u_int blue, u_int trans, struct fb_info *info)
+{
+	return 0;
+}
+
+static struct fb_ops ipu_fb_overlay_ops = {
+	.fb_setcolreg	= ipu_fb_overlay_setcolreg,
+	.fb_enable	= ipu_fb_overlay_enable_controller,
+	.fb_disable	= ipu_fb_overlay_disable_controller,
+};
+
+static int sdc_alpha_set(struct device_d *dev, struct param_d *param,
+			const char *val)
+{
+	struct fb_info *info = dev->priv;
+	struct ipu_fb_info *fbi = info->priv;
+	int alpha;
+	char alphastr[16];
+	unsigned int tmp;
+
+	if (!val)
+		return dev_param_set_generic(dev, param, NULL);
+
+	alpha = simple_strtoul(val, NULL, 0);
+	alpha &= 0xff;
+
+	tmp = reg_read(fbi, SDC_GW_CTRL) & 0x00FFFFFFL;
+	reg_write(fbi, tmp | ((u32) alpha << 24), SDC_GW_CTRL);
+
+	sprintf(alphastr, "%d", alpha);
+
+	dev_param_set_generic(dev, param, alphastr);
+
+	return 0;
+}
+
+static int sdc_fb_register_overlay(struct ipu_fb_info *fbi, void *fb)
+{
+	struct fb_info *overlay;
+	const struct imx_ipu_fb_platform_data *pdata = fbi->dev->platform_data;
+	int ret;
+
+	overlay = &fbi->overlay;
+	overlay->priv = fbi;
+	overlay->fbops = &ipu_fb_overlay_ops;
+
+	imxfb_init_info(overlay, pdata->mode, pdata->bpp);
+
+	if (fb)
+		overlay->screen_base = fb;
+	else
+		overlay->screen_base = xzalloc(overlay->xres * overlay->yres *
+				(overlay->bits_per_pixel >> 3));
+
+	if (!overlay->screen_base)
+		return -ENOMEM;
+
+	sdc_enable_channel(fbi, overlay->screen_base, IDMAC_SDC_1);
+
+	ret = register_framebuffer(&fbi->overlay);
+	if (ret < 0) {
+		dev_err(fbi->dev, "failed to register framebuffer\n");
+		return ret;
+	}
+
+	dev_add_param(&overlay->dev, "alpha", sdc_alpha_set, NULL, 0);
+	dev_set_param(&overlay->dev, "alpha", "0");
+	return 0;
+}
+
+#endif
+
 static int imxfb_probe(struct device_d *dev)
 {
 	struct ipu_fb_info *fbi;
 	struct fb_info *info;
 	const struct imx_ipu_fb_platform_data *pdata = dev->platform_data;
-	int ret;
+	int ret = 0;
 
 	if (!pdata)
 		return -ENODEV;
@@ -860,9 +992,11 @@
 
 	fbi->regs = dev_request_mem_region(dev, 0);
 	fbi->dev = dev;
+	fbi->enable = pdata->enable;
 	info->priv = fbi;
 	info->fbops = &imxfb_ops;
-	fbi->enable = pdata->enable;
+	info->num_modes = pdata->num_modes;
+	info->mode_list = pdata->mode;
 
 	imxfb_init_info(info, pdata->mode, pdata->bpp);
 
@@ -880,7 +1014,7 @@
 			return -ENOMEM;
 	}
 
-	sdc_enable_channel(fbi, info->screen_base);
+	sdc_enable_channel(fbi, info->screen_base, IDMAC_SDC_0);
 
 	ret = register_framebuffer(&fbi->info);
 	if (ret < 0) {
@@ -888,7 +1022,10 @@
 		return ret;
 	}
 
-	return 0;
+#ifdef CONFIG_DRIVER_VIDEO_IMX_IPU_OVERLAY
+	ret = sdc_fb_register_overlay(fbi, pdata->framebuffer_ovl);
+#endif
+	return ret;
 }
 
 static void imxfb_remove(struct device_d *dev)
diff -ruN barebox-2012.02.0/drivers/video/Kconfig barebox-2012.02.0-ccu2/drivers/video/Kconfig
--- barebox-2012.02.0/drivers/video/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/drivers/video/Kconfig	2013-01-14 12:46:35.000000000 +0100
@@ -20,6 +20,10 @@
 	  Add support for the IPU framebuffer device found on
 	  i.MX31 and i.MX35 CPUs.
 
+config DRIVER_VIDEO_IMX_IPU_OVERLAY
+	bool "i.MX31/35 framebuffer overlay support"
+	depends on DRIVER_VIDEO_IMX_IPU && (ARCH_IMX35 || ARCH_IMX_31)
+
 config DRIVER_VIDEO_STM
 	bool "i.MX23/28 framebuffer driver"
 	depends on ARCH_MXS
diff -ruN barebox-2012.02.0/fs/devfs-core.c barebox-2012.02.0-ccu2/fs/devfs-core.c
--- barebox-2012.02.0/fs/devfs-core.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/fs/devfs-core.c	2013-01-14 12:46:19.000000000 +0100
@@ -106,7 +106,6 @@
 	int ret = 0;
 	size_t offset;
 	struct mtd_info_user *user = buf;
-	struct region_info_user *reg = buf;
 
 	switch (request) {
 	case MEMSETBADBLOCK:
@@ -146,6 +145,8 @@
 #ifdef CONFIG_PARTITION
 	case MEMGETREGIONINFO:
 		if (cdev->mtd) {
+			struct region_info_user *reg = buf;
+
 			reg->offset = cdev->offset;
 			reg->erasesize = cdev->mtd->erasesize;
 			reg->numblocks = cdev->size/reg->erasesize;
diff -ruN barebox-2012.02.0/.gitignore barebox-2012.02.0-ccu2/.gitignore
--- barebox-2012.02.0/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# Normal rules
-#
-*~
-.*
-\#*\#
-*.o
-*.a
-*.s
-*.ko
-*.so
-*.mod.c
-*.i
-*.lst
-*.symtypes
-*.elf
-*.mcp
-*.orig
-
-#
-# Top-level generic files
-#
-tags
-TAGS
-cross_arch
-cross_compile
-barebox
-barebox.S
-barebox.bin
-barebox.srec
-barebox.netx
-barebox.map
-System.map
-Module.symvers
-barebox_default_env
-
-#
-# Generated include files
-#
-include/asm
-include/asm-*/asm-offsets.h
-include/config
-include/linux/compile.h
-include/generated
-
-# Generated files
-Doxyfile.version
-
-# stgit generated dirs
-patches-*
-
-# quilt's files
-patches
-series
-
-# cscope files
-cscope.*
-
-# patches
-*.patch
diff -ruN barebox-2012.02.0/include/asm-generic/barebox.lds.h barebox-2012.02.0-ccu2/include/asm-generic/barebox.lds.h
--- barebox-2012.02.0/include/asm-generic/barebox.lds.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/asm-generic/barebox.lds.h	2013-01-14 12:46:18.000000000 +0100
@@ -26,3 +26,18 @@
 #define BAREBOX_SYMS	KEEP(*(__usymtab))
 
 #define BAREBOX_MAGICVARS	KEEP(*(SORT_BY_NAME(.barebox_magicvar*)))
+
+#if defined(CONFIG_ARCH_BAREBOX_MAX_BARE_INIT_SIZE) && \
+CONFIG_ARCH_BAREBOX_MAX_BARE_INIT_SIZE < CONFIG_BAREBOX_MAX_BARE_INIT_SIZE
+#define MAX_BARE_INIT_SIZE CONFIG_ARCH_BAREBOX_MAX_BARE_INIT_SIZE
+#else
+#define MAX_BARE_INIT_SIZE CONFIG_BAREBOX_MAX_BARE_INIT_SIZE
+#endif
+
+#include <linux/stringify.h>
+/* use 2 ASSERT because ld can not accept '"size" "10"' format */
+#define BAREBOX_BARE_INIT_SIZE					\
+	_barebox_bare_init_size = __bare_init_end - _text;	\
+	ASSERT(_barebox_bare_init_size < MAX_BARE_INIT_SIZE, "Barebox bare_init size > ") \
+	ASSERT(_barebox_bare_init_size < MAX_BARE_INIT_SIZE, __stringify(MAX_BARE_INIT_SIZE)) \
+
diff -ruN barebox-2012.02.0/include/asm-generic/sections.h barebox-2012.02.0-ccu2/include/asm-generic/sections.h
--- barebox-2012.02.0/include/asm-generic/sections.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/asm-generic/sections.h	2013-01-14 12:46:18.000000000 +0100
@@ -3,9 +3,12 @@
 
 extern char _text[], _stext[], _etext[];
 extern char __bss_start[], __bss_stop[];
+extern char __bare_init_start[], __bare_init_end[];
 extern char _end[];
 extern void *_barebox_image_size;
+extern void *_barebox_bare_init_size;
 
 #define barebox_image_size	(unsigned int)&_barebox_image_size
+#define barebox_bare_init_size	(unsigned int)&_barebox_bare_init_size
 
 #endif /* _ASM_GENERIC_SECTIONS_H_ */
diff -ruN barebox-2012.02.0/include/common.h barebox-2012.02.0-ccu2/include/common.h
--- barebox-2012.02.0/include/common.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/common.h	2013-01-14 12:46:18.000000000 +0100
@@ -119,6 +119,15 @@
 /* common/console.c */
 int	ctrlc (void);
 
+#ifdef ARCH_HAS_STACK_DUMP
+void dump_stack(void);
+#else
+static inline void dump_stack(void)
+{
+	printf("no stack data available\n");
+}
+#endif
+
 #define MEMAREA_SIZE_SPECIFIED 1
 
 struct memarea_info {
@@ -198,7 +207,11 @@
 int memory_display(char *addr, ulong offs, ulong nbytes, int size);
 
 extern const char version_string[];
+#ifdef CONFIG_BANNER
 void barebox_banner(void);
+#else
+static inline void barebox_banner(void) {}
+#endif
 
 #define IOMEM(addr)	((void __force __iomem *)(addr))
 
diff -ruN barebox-2012.02.0/include/console.h barebox-2012.02.0-ccu2/include/console.h
--- barebox-2012.02.0/include/console.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/console.h	2013-01-14 12:46:18.000000000 +0100
@@ -56,17 +56,4 @@
 
 #define CFG_PBSIZE (CONFIG_CBSIZE+sizeof(CONFIG_PROMPT)+16)
 
-void early_console_putc(void *base, char c);
-void early_console_init(void *base, int baudrate);
-
-void early_console_start(const char *name, int baudrate);
-
-/*
- * Resolve an early console name to a pointer pointing
- * to the consoles base address, usually implemented in
- * board setup file.
- */
-void *get_early_console_base(const char *name);
-
 #endif
-
diff -ruN barebox-2012.02.0/include/driver.h barebox-2012.02.0-ccu2/include/driver.h
--- barebox-2012.02.0/include/driver.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/driver.h	2013-01-14 12:46:18.000000000 +0100
@@ -105,7 +105,7 @@
 struct driver_d {
 	/*! The name of this driver. Used to match to
 	 * the corresponding device. */
-	char name[MAX_DRIVER_NAME];
+	const char *name;
 
 	struct list_head list;
 
diff -ruN barebox-2012.02.0/include/environment.h barebox-2012.02.0-ccu2/include/environment.h
--- barebox-2012.02.0/include/environment.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/environment.h	2013-01-14 12:46:18.000000000 +0100
@@ -47,6 +47,8 @@
 #ifdef CONFIG_ENVIRONMENT_VARIABLES
 const char *getenv(const char *);
 int setenv(const char *, const char *);
+void export_env_ull(const char *name, unsigned long long val);
+unsigned long long getenv_ull(const char *name);
 #else
 static inline char *getenv(const char *var)
 {
@@ -57,11 +59,13 @@
 {
 	return 0;
 }
+static inline void export_env_ull(const char *name, unsigned long long val) {}
+static inline unsigned long long getenv_ull(const char *name)
+{
+	return 0;
+}
 #endif
 
-void export_env_ull(const char *name, unsigned long long val);
-unsigned long long getenv_ull(const char *name);
-
 int env_pop_context(void);
 int env_push_context(void);
 
diff -ruN barebox-2012.02.0/include/.gitignore barebox-2012.02.0-ccu2/include/.gitignore
--- barebox-2012.02.0/include/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-config.h
diff -ruN barebox-2012.02.0/include/kfifo.h barebox-2012.02.0-ccu2/include/kfifo.h
--- barebox-2012.02.0/include/kfifo.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/kfifo.h	2013-01-14 12:46:18.000000000 +0100
@@ -28,7 +28,7 @@
 	unsigned int out;	/* data is extracted from off. (out % size) */
 };
 
-struct kfifo *kfifo_init(unsigned char *buffer, unsigned int size);
+void kfifo_init(struct kfifo *fifo, unsigned char *buffer, unsigned int size);
 struct kfifo *kfifo_alloc(unsigned int size);
 void kfifo_free(struct kfifo *fifo);
 
diff -ruN barebox-2012.02.0/include/linux/kconfig.h barebox-2012.02.0-ccu2/include/linux/kconfig.h
--- barebox-2012.02.0/include/linux/kconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/linux/kconfig.h	2013-01-14 12:46:18.000000000 +0100
@@ -0,0 +1,32 @@
+#ifndef __LINUX_KCONFIG_H
+#define __LINUX_KCONFIG_H
+
+#include <generated/autoconf.h>
+
+/*
+ * Helper macros to use CONFIG_ options in C expressions. Note that
+ * these only work with boolean and tristate options.
+ */
+
+/*
+ * IS_ENABLED(CONFIG_FOO) evaluates to 1 if CONFIG_FOO is set to 'y' or 'm',
+ * 0 otherwise.
+ *
+ */
+#define IS_ENABLED(option) \
+	(__enabled_ ## option || __enabled_ ## option ## _MODULE)
+
+/*
+ * IS_BUILTIN(CONFIG_FOO) evaluates to 1 if CONFIG_FOO is set to 'y', 0
+ * otherwise. For boolean options, this is equivalent to
+ * IS_ENABLED(CONFIG_FOO).
+ */
+#define IS_BUILTIN(option) __enabled_ ## option
+
+/*
+ * IS_MODULE(CONFIG_FOO) evaluates to 1 if CONFIG_FOO is set to 'm', 0
+ * otherwise.
+ */
+#define IS_MODULE(option) __enabled_ ## option ## _MODULE
+
+#endif /* __LINUX_KCONFIG_H */
diff -ruN barebox-2012.02.0/include/linux/mtd/mtd.h barebox-2012.02.0-ccu2/include/linux/mtd/mtd.h
--- barebox-2012.02.0/include/linux/mtd/mtd.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/linux/mtd/mtd.h	2013-01-14 12:46:18.000000000 +0100
@@ -43,6 +43,7 @@
 	u_long priv;
 	u_char state;
 	struct erase_info *next;
+	unsigned int num_erase_bad;
 };
 
 struct mtd_erase_region_info {
diff -ruN barebox-2012.02.0/include/mci.h barebox-2012.02.0-ccu2/include/mci.h
--- barebox-2012.02.0/include/mci.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/mci.h	2013-01-14 12:46:18.000000000 +0100
@@ -249,7 +249,7 @@
 	int ready_for_use;	/** true if already probed */
 };
 
-int mci_register(struct mci_host*);
+int mci_register(struct mci_host*, int id);
 
 #define GET_HOST_DATA(x) (x->priv)
 #define GET_HOST_PDATA(x) (x->platform_data)
diff -ruN barebox-2012.02.0/include/miidev.h barebox-2012.02.0-ccu2/include/miidev.h
--- barebox-2012.02.0/include/miidev.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/miidev.h	2013-01-14 12:46:18.000000000 +0100
@@ -49,6 +49,11 @@
 void mii_unregister(struct mii_device *mdev);
 int miidev_restart_aneg(struct mii_device *mdev);
 int miidev_wait_aneg(struct mii_device *mdev);
+int miidev_get_status(struct mii_device *mdev);
+#define MIIDEV_STATUS_IS_UP		(1 << 0)
+#define MIIDEV_STATUS_IS_FULL_DUPLEX	(1 << 1)
+#define MIIDEV_STATUS_IS_10MBIT		(1 << 2)
+#define MIIDEV_STATUS_IS_100MBIT	(1 << 3)
 int miidev_print_status(struct mii_device *mdev);
 
 static int inline mii_write(struct mii_device *dev, int addr, int reg, int value)
diff -ruN barebox-2012.02.0/include/nand.h barebox-2012.02.0-ccu2/include/nand.h
--- barebox-2012.02.0/include/nand.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/nand.h	2013-01-14 12:46:18.000000000 +0100
@@ -5,10 +5,10 @@
 struct nand_bb;
 
 #ifdef CONFIG_NAND
-int dev_add_bb_dev(char *filename, const char *name);
+int dev_add_bb_dev(char const *filename, const char *name);
 int dev_remove_bb_dev(const char *name);
 #else
-static inline int dev_add_bb_dev(char *filename, const char *name) {
+static inline int dev_add_bb_dev(char const *filename, const char *name) {
 	return 0;
 }
 static inline int dev_remove_bb_dev(const char *name)
diff -ruN barebox-2012.02.0/include/ns16550.h barebox-2012.02.0-ccu2/include/ns16550.h
--- barebox-2012.02.0/include/ns16550.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/ns16550.h	2013-01-14 12:46:18.000000000 +0100
@@ -52,6 +52,8 @@
 				    unsigned char reg_offset);
 
 	int shift;
+	unsigned int flags;
+#define NS16650_FLAG_DISABLE_FIFO	1
 };
 
 #endif				/* __NS16650_PLATFORM_H_ */
diff -ruN barebox-2012.02.0/include/param.h barebox-2012.02.0-ccu2/include/param.h
--- barebox-2012.02.0/include/param.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/param.h	2013-01-14 12:46:18.000000000 +0100
@@ -19,6 +19,7 @@
 	struct list_head list;
 };
 
+#ifdef CONFIG_PARAMETER
 const char *dev_get_param(struct device_d *dev, const char *name);
 int dev_set_param(struct device_d *dev, const char *name, const char *val);
 struct param_d *get_param_by_name(struct device_d *dev, const char *name);
@@ -40,6 +41,58 @@
 IPaddr_t dev_get_param_ip(struct device_d *dev, char *name);
 
 int global_add_parameter(struct param_d *param);
+#else
+static inline const char *dev_get_param(struct device_d *dev, const char *name)
+{
+	return NULL;
+}
+static inline int dev_set_param(struct device_d *dev, const char *name,
+				const char *val)
+{
+	return 0;
+}
+static inline struct param_d *get_param_by_name(struct device_d *dev,
+						const char *name)
+{
+	return NULL;
+}
+
+static inline int dev_add_param(struct device_d *dev, char *name,
+		int (*set)(struct device_d *dev, struct param_d *p, const char *val),
+		char *(*get)(struct device_d *, struct param_d *p),
+		unsigned long flags)
+{
+	return 0;
+}
+
+static inline int dev_add_param_fixed(struct device_d *dev, char *name, char *value)
+{
+	return 0;
+}
+
+static inline void dev_remove_parameters(struct device_d *dev) {}
+
+static inline int dev_param_set_generic(struct device_d *dev, struct param_d *p,
+		const char *val)
+{
+	return 0;
+}
+
+/* Convenience functions to handle a parameter as an ip address */
+static inline int dev_set_param_ip(struct device_d *dev, char *name, IPaddr_t ip)
+{
+	return 0;
+}
+static inline IPaddr_t dev_get_param_ip(struct device_d *dev, char *name)
+{
+	return 0;
+}
+
+static inline int global_add_parameter(struct param_d *param)
+{
+	return 0;
+}
+#endif
 
 #endif /* PARAM_H */
 
diff -ruN barebox-2012.02.0/include/usb/usb.h barebox-2012.02.0-ccu2/include/usb/usb.h
--- barebox-2012.02.0/include/usb/usb.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/include/usb/usb.h	2013-01-14 12:46:18.000000000 +0100
@@ -187,7 +187,7 @@
 struct usb_device_id;
 
 struct usb_driver {
-	char	*name;
+	const char	*name;
 	int     (*probe) (struct usb_device *, const struct usb_device_id *);
 	void    (*disconnect)(struct usb_device *);
 
diff -ruN barebox-2012.02.0/lib/Kconfig barebox-2012.02.0-ccu2/lib/Kconfig
--- barebox-2012.02.0/lib/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/lib/Kconfig	2013-01-14 12:46:19.000000000 +0100
@@ -1,9 +1,18 @@
 menu "Library routines"
+config PARAMETER
+	bool
+
+config UNCOMPRESS
+	bool
+	select FILETYPE
+
 config ZLIB
 	bool "include gzip uncompression support"
+	select UNCOMPRESS
 
 config BZLIB
 	bool "include bzip2 uncompression support"
+	select UNCOMPRESS
 
 config GENERIC_FIND_NEXT_BIT
 	def_bool n
diff -ruN barebox-2012.02.0/lib/kfifo.c barebox-2012.02.0-ccu2/lib/kfifo.c
--- barebox-2012.02.0/lib/kfifo.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/lib/kfifo.c	2013-01-14 12:46:19.000000000 +0100
@@ -34,19 +34,11 @@
  * Do NOT pass the kfifo to kfifo_free() after use! Simply free the
  * &struct kfifo with free().
  */
-struct kfifo *kfifo_init(unsigned char *buffer, unsigned int size)
+void kfifo_init(struct kfifo *fifo, unsigned char *buffer, unsigned int size)
 {
-	struct kfifo *fifo;
-
-	fifo = malloc(sizeof(struct kfifo));
-	if (!fifo)
-		return NULL;
-
 	fifo->buffer = buffer;
 	fifo->size = size;
 	fifo->in = fifo->out = 0;
-
-	return fifo;
 }
 
 /**
@@ -60,18 +52,21 @@
 struct kfifo *kfifo_alloc(unsigned int size)
 {
 	unsigned char *buffer;
-	struct kfifo *ret;
+	struct kfifo *fifo;
 
 	buffer = malloc(size);
 	if (!buffer)
 		return NULL;
 
-	ret = kfifo_init(buffer, size);
-
-	if (!ret)
+	fifo = malloc(sizeof(struct kfifo));
+	if (!fifo) {
 		free(buffer);
+		return NULL;
+	}
+
+	kfifo_init(fifo, buffer, size);
 
-	return ret;
+	return fifo;
 }
 
 /**
diff -ruN barebox-2012.02.0/lib/lzo/Kconfig barebox-2012.02.0-ccu2/lib/lzo/Kconfig
--- barebox-2012.02.0/lib/lzo/Kconfig	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/lib/lzo/Kconfig	2013-01-14 12:46:19.000000000 +0100
@@ -1,6 +1,6 @@
 config LZO_DECOMPRESS
 	bool "include lzo uncompression support"
-	bool
+	select UNCOMPRESS
 
 config LZO_COMPRESS
 	bool
diff -ruN barebox-2012.02.0/lib/Makefile barebox-2012.02.0-ccu2/lib/Makefile
--- barebox-2012.02.0/lib/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/lib/Makefile	2013-01-14 12:46:19.000000000 +0100
@@ -5,7 +5,7 @@
 obj-y			+= vsprintf.o
 obj-y			+= div64.o
 obj-y			+= misc.o
-obj-y			+= parameter.o
+obj-$(CONFIG_PARAMETER)	+= parameter.o
 obj-y			+= xfuncs.o
 obj-y			+= getopt.o
 obj-y 			+= readkey.o
@@ -30,6 +30,6 @@
 obj-$(CONFIG_LZO_DECOMPRESS)		+= decompress_unlzo.o
 obj-$(CONFIG_PROCESS_ESCAPE_SEQUENCE)	+= process_escape_sequence.o
 obj-$(CONFIG_FDT)	+= fdt/
-obj-y			+= uncompress.o
+obj-$(CONFIG_UNCOMPRESS)	+= uncompress.o
 obj-$(CONFIG_BCH)	+= bch.o
 obj-$(CONFIG_BITREV)	+= bitrev.o
diff -ruN barebox-2012.02.0/lib/show_progress.c barebox-2012.02.0-ccu2/lib/show_progress.c
--- barebox-2012.02.0/lib/show_progress.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/lib/show_progress.c	2013-01-14 12:46:19.000000000 +0100
@@ -22,6 +22,7 @@
 
 #include <common.h>
 #include <progress.h>
+#include <asm-generic/div64.h>
 
 #define HASHES_PER_LINE	65
 
@@ -38,8 +39,11 @@
 		return;
 	}
 
-	if (progress_max)
-		now = now * HASHES_PER_LINE / progress_max;
+	if (progress_max) {
+		uint64_t tmp = (int64_t)now * HASHES_PER_LINE;
+		do_div(tmp, progress_max);
+		now = tmp;
+	}
 
 	while (printed < now) {
 		if (!(printed % HASHES_PER_LINE) && printed)
diff -ruN barebox-2012.02.0/lib/vsprintf.c barebox-2012.02.0-ccu2/lib/vsprintf.c
--- barebox-2012.02.0/lib/vsprintf.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/lib/vsprintf.c	2013-01-14 12:46:19.000000000 +0100
@@ -625,6 +625,8 @@
 	putchar('\n');
 	va_end(args);
 
+	dump_stack();
+
 	led_trigger(LED_TRIGGER_PANIC, TRIGGER_ENABLE);
 
 #if defined (CONFIG_PANIC_HANG)
diff -ruN barebox-2012.02.0/Makefile barebox-2012.02.0-ccu2/Makefile
--- barebox-2012.02.0/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/Makefile	2013-01-14 12:46:35.000000000 +0100
@@ -290,7 +290,8 @@
                    $(if $(KBUILD_SRC),-Iinclude2 -I$(srctree)/include) \
 		   -I$(srctree)/arch/$(ARCH)/include \
 		   -I$(objtree)/arch/$(ARCH)/include \
-                   -include include/generated/autoconf.h
+                   -include include/generated/autoconf.h \
+                   -include $(srctree)/include/linux/kconfig.h
 
 CPPFLAGS        := -D__KERNEL__ -D__BAREBOX__ $(LINUXINCLUDE) -fno-builtin -ffreestanding
 
@@ -515,9 +516,9 @@
 # Rule to link barebox
 # May be overridden by arch/$(ARCH)/Makefile
 quiet_cmd_barebox__ ?= LD      $@
-      cmd_barebox__ ?= $(LD) $(LDFLAGS) $(LDFLAGS_barebox) -o $@ \
+      cmd_barebox__ ?=  $(LD) $(LDFLAGS) $(LDFLAGS_barebox) -o $@ \
       -T $(barebox-lds) $(barebox-head)                         \
-      --start-group $(barebox-common) --end-group                  \
+      --start-group $(barebox-common) --end-group        \
       $(filter-out $(barebox-lds) $(barebox-common) FORCE ,$^)
 
 # Generate new barebox version
@@ -530,7 +531,18 @@
 	  mv .version .old_version;			\
 	  expr 0$$(cat .old_version) + 1 >.version;	\
 	fi;						\
+	$(MAKE) $(build)=common
 
+# Check size of a file
+quiet_cmd_check_file_size = CHKSIZE $@
+      cmd_check_file_size = set -e;					\
+	size=`stat -c%s $@`;						\
+	max_size=`printf "%d" $2`;					\
+	if [ $$size -gt $$max_size ] ;					\
+	then								\
+		echo "$@ size $$size > of the maximum size $$max_size";	\
+		exit 1 ;						\
+	fi;
 
 # Generate System.map
 quiet_cmd_sysmap = SYSMAP
@@ -658,6 +670,7 @@
 
 barebox.bin: barebox FORCE
 	$(call if_changed,objcopy)
+	$(call cmd,check_file_size,$(CONFIG_BAREBOX_MAX_IMAGE_SIZE))
 
 ifdef CONFIG_X86
 barebox.S: barebox
diff -ruN barebox-2012.02.0/net/dhcp.c barebox-2012.02.0-ccu2/net/dhcp.c
--- barebox-2012.02.0/net/dhcp.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/net/dhcp.c	2013-01-29 13:04:45.000000000 +0100
@@ -19,6 +19,7 @@
 #include <linux/err.h>
 
 #define OPT_SIZE 312	/* Minimum DHCP Options size per RFC2131 - results in 576 byte pkt */
+#define DHCP_VENDOR_ID	"eQ3-CCU2"
 
 struct bootp {
 	uint8_t		bp_op;		/* Operation				*/
@@ -146,6 +147,11 @@
 	*e++ = (576 - 312 + OPT_SIZE) >> 8;
 	*e++ = (576 - 312 + OPT_SIZE) & 0xff;
 
+	*e++ = 60;
+	*e++ = sizeof DHCP_VENDOR_ID - 1;
+	memcpy(e, DHCP_VENDOR_ID, sizeof DHCP_VENDOR_ID - 1);
+	e   += sizeof DHCP_VENDOR_ID - 1;
+
 	if (ServerID) {
 		int tmp = ntohl (ServerID);
 
diff -ruN barebox-2012.02.0/net/nfs.c barebox-2012.02.0-ccu2/net/nfs.c
--- barebox-2012.02.0/net/nfs.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/net/nfs.c	2013-01-14 12:46:18.000000000 +0100
@@ -124,7 +124,7 @@
 	} u;
 };
 
-#define NFS_TIMEOUT 1
+#define NFS_TIMEOUT 15
 
 static unsigned long rpc_id = 0;
 static int nfs_offset = -1;
Binary files barebox-2012.02.0/scripts/basic/docproc and barebox-2012.02.0-ccu2/scripts/basic/docproc differ
diff -ruN barebox-2012.02.0/scripts/basic/.docproc.cmd barebox-2012.02.0-ccu2/scripts/basic/.docproc.cmd
--- barebox-2012.02.0/scripts/basic/.docproc.cmd	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/basic/.docproc.cmd	2013-02-14 16:06:34.000000000 +0100
@@ -0,0 +1,66 @@
+cmd_scripts/basic/docproc := gcc -Wp,-MD,scripts/basic/.docproc.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/docproc scripts/basic/docproc.c  
+
+deps_scripts/basic/docproc := \
+  scripts/basic/docproc.c \
+  /usr/include/stdio.h \
+  /usr/include/features.h \
+  /usr/include/bits/predefs.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-64.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/stdlib.h \
+  /usr/include/sys/types.h \
+  /usr/include/time.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/alloca.h \
+  /usr/include/string.h \
+  /usr/include/xlocale.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/include/ctype.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/syslimits.h \
+  /usr/include/limits.h \
+  /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h \
+  /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/include/sys/wait.h \
+  /usr/include/signal.h \
+  /usr/include/bits/signum.h \
+  /usr/include/bits/siginfo.h \
+  /usr/include/bits/sigaction.h \
+  /usr/include/bits/sigcontext.h \
+  /usr/include/bits/sigstack.h \
+  /usr/include/bits/sigthread.h \
+  /usr/include/sys/resource.h \
+  /usr/include/bits/resource.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+
+scripts/basic/docproc: $(deps_scripts/basic/docproc)
+
+$(deps_scripts/basic/docproc):
Binary files barebox-2012.02.0/scripts/basic/fixdep and barebox-2012.02.0-ccu2/scripts/basic/fixdep differ
diff -ruN barebox-2012.02.0/scripts/basic/.fixdep.cmd barebox-2012.02.0-ccu2/scripts/basic/.fixdep.cmd
--- barebox-2012.02.0/scripts/basic/.fixdep.cmd	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/basic/.fixdep.cmd	2013-02-14 16:06:33.000000000 +0100
@@ -0,0 +1,79 @@
+cmd_scripts/basic/fixdep := gcc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/fixdep scripts/basic/fixdep.c  
+
+deps_scripts/basic/fixdep := \
+  scripts/basic/fixdep.c \
+    $(wildcard include/config/his/driver.h) \
+    $(wildcard include/config/my/option.h) \
+    $(wildcard include/config/.h) \
+    $(wildcard include/config/foo.h) \
+    $(wildcard include/config/boom.h) \
+  /usr/include/sys/types.h \
+  /usr/include/features.h \
+  /usr/include/bits/predefs.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-64.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/time.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/sys/stat.h \
+  /usr/include/bits/stat.h \
+  /usr/include/sys/mman.h \
+  /usr/include/bits/mman.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/string.h \
+  /usr/include/xlocale.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/include/stdlib.h \
+  /usr/include/alloca.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/syslimits.h \
+  /usr/include/limits.h \
+  /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h \
+  /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/include/ctype.h \
+  /usr/include/arpa/inet.h \
+  /usr/include/netinet/in.h \
+  /usr/include/stdint.h \
+  /usr/include/bits/wchar.h \
+  /usr/include/sys/socket.h \
+  /usr/include/sys/uio.h \
+  /usr/include/bits/uio.h \
+  /usr/include/bits/socket.h \
+  /usr/include/bits/sockaddr.h \
+  /usr/include/asm/socket.h \
+  /usr/include/asm-generic/socket.h \
+  /usr/include/asm/sockios.h \
+  /usr/include/asm-generic/sockios.h \
+  /usr/include/bits/in.h \
+
+scripts/basic/fixdep: $(deps_scripts/basic/fixdep)
+
+$(deps_scripts/basic/fixdep):
diff -ruN barebox-2012.02.0/scripts/basic/.gitignore barebox-2012.02.0-ccu2/scripts/basic/.gitignore
--- barebox-2012.02.0/scripts/basic/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/basic/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-docproc
-fixdep
diff -ruN barebox-2012.02.0/scripts/.gitignore barebox-2012.02.0-ccu2/scripts/.gitignore
--- barebox-2012.02.0/scripts/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-bareboxenv
-bin2c
-mkimage
-kallsyms
-gen_netx_image
-omap_signGP
Binary files barebox-2012.02.0/scripts/kconfig/conf and barebox-2012.02.0-ccu2/scripts/kconfig/conf differ
diff -ruN barebox-2012.02.0/scripts/kconfig/conf.c barebox-2012.02.0-ccu2/scripts/kconfig/conf.c
--- barebox-2012.02.0/scripts/kconfig/conf.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/conf.c	2013-01-14 12:46:18.000000000 +0100
@@ -14,11 +14,11 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 static void conf(struct menu *menu);
 static void check_conf(struct menu *menu);
+static void xfgets(char *str, int size, FILE *in);
 
 enum input_mode {
 	oldaskconfig,
@@ -35,8 +35,6 @@
 	oldnoconfig,
 } input_mode = oldaskconfig;
 
-char *defconfig_file;
-
 static int indent = 1;
 static int valid_stdin = 1;
 static int sync_kconfig;
@@ -106,6 +104,7 @@
 			return 0;
 		}
 		check_stdin();
+		/* fall through */
 	case oldaskconfig:
 		fflush(stdout);
 		xfgets(line, 128, stdin);
@@ -150,6 +149,7 @@
 				def = NULL;
 				break;
 			}
+			/* fall through */
 		default:
 			line[strlen(line)-1] = 0;
 			def = line;
@@ -304,6 +304,7 @@
 				break;
 			}
 			check_stdin();
+			/* fall through */
 		case oldaskconfig:
 			fflush(stdout);
 			xfgets(line, 128, stdin);
@@ -332,7 +333,7 @@
 		}
 		if (!child)
 			continue;
-		if (line[strlen(line) - 1] == '?') {
+		if (line[0] && line[strlen(line) - 1] == '?') {
 			print_help(child);
 			continue;
 		}
@@ -369,6 +370,7 @@
 				check_conf(menu);
 				return;
 			}
+			/* fall through */
 		case P_COMMENT:
 			prompt = menu_get_prompt(menu);
 			if (prompt)
@@ -456,10 +458,30 @@
 	{NULL, 0, NULL, 0}
 };
 
+static void conf_usage(const char *progname)
+{
+
+	printf("Usage: %s [option] <kconfig-file>\n", progname);
+	printf("[option] is _one_ of the following:\n");
+	printf("  --listnewconfig         List new options\n");
+	printf("  --oldaskconfig          Start a new configuration using a line-oriented program\n");
+	printf("  --oldconfig             Update a configuration using a provided .config as base\n");
+	printf("  --silentoldconfig       Same as oldconfig, but quietly, additionally update deps\n");
+	printf("  --oldnoconfig           Same as silentoldconfig but set new symbols to no\n");
+	printf("  --defconfig <file>      New config with default defined in <file>\n");
+	printf("  --savedefconfig <file>  Save the minimal current configuration to <file>\n");
+	printf("  --allnoconfig           New config where all options are answered with no\n");
+	printf("  --allyesconfig          New config where all options are answered with yes\n");
+	printf("  --allmodconfig          New config where all options are answered with mod\n");
+	printf("  --alldefconfig          New config with all symbols set to default\n");
+	printf("  --randconfig            New config with random answer to all options\n");
+}
+
 int main(int ac, char **av)
 {
+	const char *progname = av[0];
 	int opt;
-	const char *name;
+	const char *name, *defconfig_file = NULL /* gcc uninit */;
 	struct stat tmpstat;
 
 	setlocale(LC_ALL, "");
@@ -491,14 +513,24 @@
 			srand(seed);
 			break;
 		}
+		case oldaskconfig:
+		case oldconfig:
+		case allnoconfig:
+		case allyesconfig:
+		case allmodconfig:
+		case alldefconfig:
+		case listnewconfig:
+		case oldnoconfig:
+			break;
 		case '?':
-			fprintf(stderr, _("See README for usage info\n"));
+			conf_usage(progname);
 			exit(1);
 			break;
 		}
 	}
 	if (ac == optind) {
 		printf(_("%s: Kconfig file missing\n"), av[0]);
+		conf_usage(progname);
 		exit(1);
 	}
 	name = av[optind];
@@ -641,13 +673,11 @@
 	}
 	return 0;
 }
+
 /*
  * Helper function to facilitate fgets() by Jean Sacren.
  */
-void xfgets(str, size, in)
-	char *str;
-	int size;
-	FILE *in;
+void xfgets(char *str, int size, FILE *in)
 {
 	if (fgets(str, size, in) == NULL)
 		fprintf(stderr, "\nError in reading or end of file.\n");
diff -ruN barebox-2012.02.0/scripts/kconfig/.conf.cmd barebox-2012.02.0-ccu2/scripts/kconfig/.conf.cmd
--- barebox-2012.02.0/scripts/kconfig/.conf.cmd	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/.conf.cmd	2013-02-14 16:06:36.000000000 +0100
@@ -0,0 +1 @@
+cmd_scripts/kconfig/conf := gcc  -o scripts/kconfig/conf scripts/kconfig/conf.o scripts/kconfig/zconf.tab.o  
diff -ruN barebox-2012.02.0/scripts/kconfig/confdata.c barebox-2012.02.0-ccu2/scripts/kconfig/confdata.c
--- barebox-2012.02.0/scripts/kconfig/confdata.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/confdata.c	2013-01-14 12:46:18.000000000 +0100
@@ -7,13 +7,13 @@
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 static void conf_warning(const char *fmt, ...)
@@ -128,6 +128,7 @@
 			sym->flags |= def_flags;
 			break;
 		}
+		/* fall through */
 	case S_BOOLEAN:
 		if (p[0] == 'y') {
 			sym->def[def].tri = yes;
@@ -140,7 +141,7 @@
 			break;
 		}
 		conf_warning("symbol value '%s' invalid for %s", p, sym->name);
-		break;
+		return 1;
 	case S_OTHER:
 		if (*p != '"') {
 			for (p2 = p; *p2 && !isspace(*p2); p2++)
@@ -148,6 +149,7 @@
 			sym->type = S_STRING;
 			goto done;
 		}
+		/* fall through */
 	case S_STRING:
 		if (*p++ != '"')
 			break;
@@ -162,6 +164,7 @@
 			conf_warning("invalid string found");
 			return 1;
 		}
+		/* fall through */
 	case S_INT:
 	case S_HEX:
 	done:
@@ -237,6 +240,7 @@
 		case S_STRING:
 			if (sym->def[def].val)
 				free(sym->def[def].val);
+			/* fall through */
 		default:
 			sym->def[def].val = NULL;
 			sym->def[def].tri = no;
@@ -363,6 +367,7 @@
 					break;
 				if (!sym_is_choice(sym))
 					goto sym_ok;
+				/* fall through */
 			default:
 				if (!strcmp(sym->curr.val, sym->def[S_DEF_USER].val))
 					goto sym_ok;
@@ -417,64 +422,220 @@
 	return 0;
 }
 
-/* Write a S_STRING */
-static void conf_write_string(bool headerfile, const char *name,
-                              const char *str, FILE *out)
-{
-	int l;
-	if (headerfile)
-		fprintf(out, "#define %s%s \"", CONFIG_, name);
-	else
-		fprintf(out, "%s%s=\"", CONFIG_, name);
+/*
+ * Kconfig configuration printer
+ *
+ * This printer is used when generating the resulting configuration after
+ * kconfig invocation and `defconfig' files. Unset symbol might be omitted by
+ * passing a non-NULL argument to the printer.
+ *
+ */
+static void
+kconfig_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
+{
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		if (*value == 'n') {
+			bool skip_unset = (arg != NULL);
+
+			if (!skip_unset)
+				fprintf(fp, "# %s%s is not set\n",
+				    CONFIG_, sym->name);
+			return;
+		}
+		break;
+	default:
+		break;
+	}
 
-	while (1) {
-		l = strcspn(str, "\"\\");
+	fprintf(fp, "%s%s=%s\n", CONFIG_, sym->name, value);
+}
+
+static void
+kconfig_print_comment(FILE *fp, const char *value, void *arg)
+{
+	const char *p = value;
+	size_t l;
+
+	for (;;) {
+		l = strcspn(p, "\n");
+		fprintf(fp, "#");
 		if (l) {
-			xfwrite(str, l, 1, out);
-			str += l;
+			fprintf(fp, " ");
+			fwrite(p, l, 1, fp);
+			p += l;
 		}
-		if (!*str)
+		fprintf(fp, "\n");
+		if (*p++ == '\0')
 			break;
-		fprintf(out, "\\%c", *str++);
 	}
-	fputs("\"\n", out);
 }
 
-static void conf_write_symbol(struct symbol *sym, FILE *out, bool write_no)
+static struct conf_printer kconfig_printer_cb =
+{
+	.print_symbol = kconfig_print_symbol,
+	.print_comment = kconfig_print_comment,
+};
+
+/*
+ * Header printer
+ *
+ * This printer is used when generating the `include/generated/autoconf.h' file.
+ */
+static void
+header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
 {
-	const char *str;
 
 	switch (sym->type) {
 	case S_BOOLEAN:
-	case S_TRISTATE:
-		switch (sym_get_tristate_value(sym)) {
-		case no:
-			if (write_no)
-				fprintf(out, "# %s%s is not set\n",
-				    CONFIG_, sym->name);
-			break;
-		case mod:
-			fprintf(out, "%s%s=m\n", CONFIG_, sym->name);
-			break;
-		case yes:
-			fprintf(out, "%s%s=y\n", CONFIG_, sym->name);
+	case S_TRISTATE: {
+		const char *suffix = "";
+
+		switch (*value) {
+		case 'n':
 			break;
+		case 'm':
+			suffix = "_MODULE";
+			/* fall through */
+		default:
+			fprintf(fp, "#define %s%s%s 1\n",
+			    CONFIG_, sym->name, suffix);
 		}
 		break;
-	case S_STRING:
-		conf_write_string(false, sym->name, sym_get_string_value(sym), out);
+	}
+	case S_HEX: {
+		const char *prefix = "";
+
+		if (value[0] != '0' || (value[1] != 'x' && value[1] != 'X'))
+			prefix = "0x";
+		fprintf(fp, "#define %s%s %s%s\n",
+		    CONFIG_, sym->name, prefix, value);
 		break;
-	case S_HEX:
+	}
+	case S_STRING:
 	case S_INT:
-		str = sym_get_string_value(sym);
-		fprintf(out, "%s%s=%s\n", CONFIG_, sym->name, str);
+		fprintf(fp, "#define %s%s %s\n",
+		    CONFIG_, sym->name, value);
+		break;
+	default:
+		break;
+	}
+
+}
+
+static void
+header_print_comment(FILE *fp, const char *value, void *arg)
+{
+	const char *p = value;
+	size_t l;
+
+	fprintf(fp, "/*\n");
+	for (;;) {
+		l = strcspn(p, "\n");
+		fprintf(fp, " *");
+		if (l) {
+			fprintf(fp, " ");
+			fwrite(p, l, 1, fp);
+			p += l;
+		}
+		fprintf(fp, "\n");
+		if (*p++ == '\0')
+			break;
+	}
+	fprintf(fp, " */\n");
+}
+
+static struct conf_printer header_printer_cb =
+{
+	.print_symbol = header_print_symbol,
+	.print_comment = header_print_comment,
+};
+
+/*
+ * Generate the __enabled_CONFIG_* and __enabled_CONFIG_*_MODULE macros for
+ * use by the IS_{ENABLED,BUILTIN,MODULE} macros. The _MODULE variant is
+ * generated even for booleans so that the IS_ENABLED() macro works.
+ */
+static void
+header_print__enabled_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
+{
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE: {
+		fprintf(fp, "#define __enabled_" CONFIG_ "%s %d\n",
+		    sym->name, (*value == 'y'));
+		fprintf(fp, "#define __enabled_" CONFIG_ "%s_MODULE %d\n",
+		    sym->name, (*value == 'm'));
 		break;
+	}
+	default:
+		break;
+	}
+}
+
+static struct conf_printer header__enabled_printer_cb =
+{
+	.print_symbol = header_print__enabled_symbol,
+	.print_comment = header_print_comment,
+};
+
+/*
+ * Tristate printer
+ *
+ * This printer is used when generating the `include/config/tristate.conf' file.
+ */
+static void
+tristate_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
+{
+
+	if (sym->type == S_TRISTATE && *value != 'n')
+		fprintf(fp, "%s%s=%c\n", CONFIG_, sym->name, (char)toupper(*value));
+}
+
+static struct conf_printer tristate_printer_cb =
+{
+	.print_symbol = tristate_print_symbol,
+	.print_comment = kconfig_print_comment,
+};
+
+static void conf_write_symbol(FILE *fp, struct symbol *sym,
+			      struct conf_printer *printer, void *printer_arg)
+{
+	const char *str;
+
+	switch (sym->type) {
 	case S_OTHER:
 	case S_UNKNOWN:
 		break;
+	case S_STRING:
+		str = sym_get_string_value(sym);
+		str = sym_escape_string_value(str);
+		printer->print_symbol(fp, sym, str, printer_arg);
+		free((void *)str);
+		break;
+	default:
+		str = sym_get_string_value(sym);
+		printer->print_symbol(fp, sym, str, printer_arg);
 	}
 }
 
+static void
+conf_write_heading(FILE *fp, struct conf_printer *printer, void *printer_arg)
+{
+	char buf[256];
+
+	snprintf(buf, sizeof(buf),
+	    "\n"
+	    "Automatically generated file; DO NOT EDIT.\n"
+	    "%s\n",
+	    rootmenu.prompt->text);
+
+	printer->print_comment(fp, buf, printer_arg);
+}
+
 /*
  * Write out a minimal config.
  * All values that has default values are skipped as this is redundant.
@@ -531,7 +692,7 @@
 						goto next_menu;
 				}
 			}
-			conf_write_symbol(sym, out, true);
+			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
 		}
 next_menu:
 		if (menu->list != NULL) {
@@ -560,8 +721,6 @@
 	const char *basename;
 	const char *str;
 	char dirname[PATH_MAX+1], tmpname[PATH_MAX+1], newname[PATH_MAX+1];
-	time_t now;
-	int use_timestamp = 1;
 	char *env;
 
 	dirname[0] = 0;
@@ -598,19 +757,7 @@
 	if (!out)
 		return 1;
 
-	time(&now);
-	env = getenv("KCONFIG_NOTIMESTAMP");
-	if (env && *env)
-		use_timestamp = 0;
-
-	fprintf(out, _("#\n"
-		       "# Automatically generated make config: don't edit\n"
-		       "# %s\n"
-		       "%s%s"
-		       "#\n"),
-		     rootmenu.prompt->text,
-		     use_timestamp ? "# " : "",
-		     use_timestamp ? ctime(&now) : "");
+	conf_write_heading(out, &kconfig_printer_cb, NULL);
 
 	if (!conf_get_changed())
 		sym_clear_all_valid();
@@ -631,8 +778,8 @@
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
 			sym->flags &= ~SYMBOL_WRITE;
-			/* Write config symbol to file */
-			conf_write_symbol(sym, out, true);
+
+			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
 		}
 
 next:
@@ -781,10 +928,8 @@
 int conf_write_autoconf(void)
 {
 	struct symbol *sym;
-	const char *str;
 	const char *name;
 	FILE *out, *tristate, *out_h;
-	time_t now;
 	int i;
 
 	sym_clear_all_valid();
@@ -811,71 +956,28 @@
 		return 1;
 	}
 
-	time(&now);
-	fprintf(out, "#\n"
-		     "# Automatically generated make config: don't edit\n"
-		     "# %s\n"
-		     "# %s"
-		     "#\n",
-		     rootmenu.prompt->text, ctime(&now));
-	fprintf(tristate, "#\n"
-			  "# Automatically generated - do not edit\n"
-			  "\n");
-	fprintf(out_h, "/*\n"
-		       " * Automatically generated C config: don't edit\n"
-		       " * %s\n"
-		       " * %s"
-		       " */\n",
-		       rootmenu.prompt->text, ctime(&now));
+	conf_write_heading(out, &kconfig_printer_cb, NULL);
+
+	conf_write_heading(tristate, &tristate_printer_cb, NULL);
+
+	conf_write_heading(out_h, &header_printer_cb, NULL);
 
 	for_all_symbols(i, sym) {
+		if (!sym->name)
+			continue;
+
 		sym_calc_value(sym);
-		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
+
+		conf_write_symbol(out_h, sym, &header__enabled_printer_cb, NULL);
+
+		if (!(sym->flags & SYMBOL_WRITE))
 			continue;
 
-		/* write symbol to config file */
-		conf_write_symbol(sym, out, false);
+		conf_write_symbol(out, sym, &kconfig_printer_cb, (void *)1);
 
-		/* update autoconf and tristate files */
-		switch (sym->type) {
-		case S_BOOLEAN:
-		case S_TRISTATE:
-			switch (sym_get_tristate_value(sym)) {
-			case no:
-				break;
-			case mod:
-				fprintf(tristate, "%s%s=M\n",
-				    CONFIG_, sym->name);
-				fprintf(out_h, "#define %s%s_MODULE 1\n",
-				    CONFIG_, sym->name);
-				break;
-			case yes:
-				if (sym->type == S_TRISTATE)
-					fprintf(tristate,"%s%s=Y\n",
-					    CONFIG_, sym->name);
-				fprintf(out_h, "#define %s%s 1\n",
-				    CONFIG_, sym->name);
-				break;
-			}
-			break;
-		case S_STRING:
-			conf_write_string(true, sym->name, sym_get_string_value(sym), out_h);
-			break;
-		case S_HEX:
-			str = sym_get_string_value(sym);
-			if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
-				fprintf(out_h, "#define %s%s 0x%s\n",
-				    CONFIG_, sym->name, str);
-				break;
-			}
-		case S_INT:
-			str = sym_get_string_value(sym);
-			fprintf(out_h, "#define %s%s %s\n",
-			    CONFIG_, sym->name, str);
-			break;
-		default:
-			break;
-		}
+		conf_write_symbol(tristate, sym, &tristate_printer_cb, (void *)1);
+
+		conf_write_symbol(out_h, sym, &header_printer_cb, NULL);
 	}
 	fclose(out);
 	fclose(tristate);
Binary files barebox-2012.02.0/scripts/kconfig/conf.o and barebox-2012.02.0-ccu2/scripts/kconfig/conf.o differ
diff -ruN barebox-2012.02.0/scripts/kconfig/.conf.o.cmd barebox-2012.02.0-ccu2/scripts/kconfig/.conf.o.cmd
--- barebox-2012.02.0/scripts/kconfig/.conf.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/.conf.o.cmd	2013-02-14 16:06:34.000000000 +0100
@@ -0,0 +1,61 @@
+cmd_scripts/kconfig/conf.o := gcc -Wp,-MD,scripts/kconfig/.conf.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c
+
+deps_scripts/kconfig/conf.o := \
+  scripts/kconfig/conf.c \
+    $(wildcard include/config/.h) \
+    $(wildcard include/config/allconfig.h) \
+    $(wildcard include/config/nosilentupdate.h) \
+  /usr/include/locale.h \
+  /usr/include/features.h \
+  /usr/include/bits/predefs.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-64.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h \
+  /usr/include/bits/locale.h \
+  /usr/include/xlocale.h \
+  /usr/include/ctype.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/stdlib.h \
+  /usr/include/sys/types.h \
+  /usr/include/time.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/alloca.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/sys/stat.h \
+  /usr/include/bits/stat.h \
+  /usr/include/sys/time.h \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/list.h) \
+  scripts/kconfig/expr.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stdbool.h \
+  /usr/include/libintl.h \
+  scripts/kconfig/lkc_proto.h \
+
+scripts/kconfig/conf.o: $(deps_scripts/kconfig/conf.o)
+
+$(deps_scripts/kconfig/conf.o):
diff -ruN barebox-2012.02.0/scripts/kconfig/expr.c barebox-2012.02.0-ccu2/scripts/kconfig/expr.c
--- barebox-2012.02.0/scripts/kconfig/expr.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/expr.c	2013-01-14 12:46:18.000000000 +0100
@@ -7,15 +7,13 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 #define DEBUG_EXPR	0
 
 struct expr *expr_alloc_symbol(struct symbol *sym)
 {
-	struct expr *e = malloc(sizeof(*e));
-	memset(e, 0, sizeof(*e));
+	struct expr *e = calloc(1, sizeof(*e));
 	e->type = E_SYMBOL;
 	e->left.sym = sym;
 	return e;
@@ -23,8 +21,7 @@
 
 struct expr *expr_alloc_one(enum expr_type type, struct expr *ce)
 {
-	struct expr *e = malloc(sizeof(*e));
-	memset(e, 0, sizeof(*e));
+	struct expr *e = calloc(1, sizeof(*e));
 	e->type = type;
 	e->left.expr = ce;
 	return e;
@@ -32,8 +29,7 @@
 
 struct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2)
 {
-	struct expr *e = malloc(sizeof(*e));
-	memset(e, 0, sizeof(*e));
+	struct expr *e = calloc(1, sizeof(*e));
 	e->type = type;
 	e->left.expr = e1;
 	e->right.expr = e2;
@@ -42,8 +38,7 @@
 
 struct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2)
 {
-	struct expr *e = malloc(sizeof(*e));
-	memset(e, 0, sizeof(*e));
+	struct expr *e = calloc(1, sizeof(*e));
 	e->type = type;
 	e->left.sym = s1;
 	e->right.sym = s2;
diff -ruN barebox-2012.02.0/scripts/kconfig/expr.h barebox-2012.02.0-ccu2/scripts/kconfig/expr.h
--- barebox-2012.02.0/scripts/kconfig/expr.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/expr.h	2013-01-14 12:46:18.000000000 +0100
@@ -20,12 +20,8 @@
 	struct file *parent;
 	const char *name;
 	int lineno;
-	int flags;
 };
 
-#define FILE_BUSY		0x0001
-#define FILE_SCANNED		0x0002
-
 typedef enum tristate {
 	no, mod, yes
 } tristate;
@@ -176,8 +172,6 @@
 #define MENU_CHANGED		0x0001
 #define MENU_ROOT		0x0002
 
-#ifndef SWIG
-
 extern struct file *file_list;
 extern struct file *current_file;
 struct file *lookup_file(const char *name);
@@ -222,7 +216,6 @@
 {
 	return e && (e->type == E_SYMBOL && e->left.sym == &symbol_no);
 }
-#endif
 
 #ifdef __cplusplus
 }
diff -ruN barebox-2012.02.0/scripts/kconfig/gconf.c barebox-2012.02.0-ccu2/scripts/kconfig/gconf.c
--- barebox-2012.02.0/scripts/kconfig/gconf.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/gconf.c	2013-01-14 12:46:18.000000000 +0100
@@ -253,7 +253,7 @@
 
 	gtk_tree_view_set_model(view, model1);
 	gtk_tree_view_set_headers_visible(view, TRUE);
-	gtk_tree_view_set_rules_hint(view, FALSE);
+	gtk_tree_view_set_rules_hint(view, TRUE);
 
 	column = gtk_tree_view_column_new();
 	gtk_tree_view_append_column(view, column);
@@ -285,8 +285,6 @@
 static void renderer_edited(GtkCellRendererText * cell,
 			    const gchar * path_string,
 			    const gchar * new_text, gpointer user_data);
-static void renderer_toggled(GtkCellRendererToggle * cellrenderertoggle,
-			     gchar * arg1, gpointer user_data);
 
 void init_right_tree(void)
 {
@@ -298,7 +296,7 @@
 
 	gtk_tree_view_set_model(view, model2);
 	gtk_tree_view_set_headers_visible(view, TRUE);
-	gtk_tree_view_set_rules_hint(view, FALSE);
+	gtk_tree_view_set_rules_hint(view, TRUE);
 
 	column = gtk_tree_view_column_new();
 	gtk_tree_view_append_column(view, column);
@@ -320,8 +318,6 @@
 					    "inconsistent", COL_BTNINC,
 					    "visible", COL_BTNVIS,
 					    "radio", COL_BTNRAD, NULL);
-	/*g_signal_connect(G_OBJECT(renderer), "toggled",
-	   G_CALLBACK(renderer_toggled), NULL); */
 	renderer = gtk_cell_renderer_text_new();
 	gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),
 					renderer, FALSE);
@@ -756,7 +752,6 @@
 void on_single_clicked(GtkButton * button, gpointer user_data)
 {
 	view_mode = SINGLE_VIEW;
-	gtk_paned_set_position(GTK_PANED(hpaned), 0);
 	gtk_widget_hide(tree1_w);
 	current = &rootmenu;
 	display_tree_part();
@@ -782,7 +777,6 @@
 void on_full_clicked(GtkButton * button, gpointer user_data)
 {
 	view_mode = FULL_VIEW;
-	gtk_paned_set_position(GTK_PANED(hpaned), 0);
 	gtk_widget_hide(tree1_w);
 	if (tree2)
 		gtk_tree_store_clear(tree2);
@@ -890,35 +884,6 @@
 		display_tree_part();	//fixme: keep exp/coll
 }
 
-static void renderer_toggled(GtkCellRendererToggle * cell,
-			     gchar * path_string, gpointer user_data)
-{
-	GtkTreePath *path, *sel_path = NULL;
-	GtkTreeIter iter, sel_iter;
-	GtkTreeSelection *sel;
-	struct menu *menu;
-
-	path = gtk_tree_path_new_from_string(path_string);
-	if (!gtk_tree_model_get_iter(model2, &iter, path))
-		return;
-
-	sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree2_w));
-	if (gtk_tree_selection_get_selected(sel, NULL, &sel_iter))
-		sel_path = gtk_tree_model_get_path(model2, &sel_iter);
-	if (!sel_path)
-		goto out1;
-	if (gtk_tree_path_compare(path, sel_path))
-		goto out2;
-
-	gtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);
-	toggle_sym_value(menu);
-
-      out2:
-	gtk_tree_path_free(sel_path);
-      out1:
-	gtk_tree_path_free(path);
-}
-
 static gint column2index(GtkTreeViewColumn * column)
 {
 	gint i;
@@ -1174,6 +1139,7 @@
 			row[COL_BTNVIS] = GINT_TO_POINTER(TRUE);
 		if (sym_is_choice(sym))
 			break;
+		/* fall through */
 	case S_TRISTATE:
 		val = sym_get_tristate_value(sym);
 		switch (val) {
@@ -1444,6 +1410,12 @@
                 if (((menu != &rootmenu) && !(menu->flags & MENU_ROOT))
 		    || (view_mode == FULL_VIEW)
 		    || (view_mode == SPLIT_VIEW))*/
+
+		/* Change paned position if the view is not in 'split mode' */
+		if (view_mode == SINGLE_VIEW || view_mode == FULL_VIEW) {
+			gtk_paned_set_position(GTK_PANED(hpaned), 0);
+		}
+
 		if (((view_mode == SINGLE_VIEW) && (menu->flags & MENU_ROOT))
 		    || (view_mode == FULL_VIEW)
 		    || (view_mode == SPLIT_VIEW)) {
@@ -1502,10 +1474,6 @@
 	char *env;
 	gchar *glade_file;
 
-#ifndef LKC_DIRECT_LINK
-	kconfig_load();
-#endif
-
 	bindtextdomain(PACKAGE, LOCALEDIR);
 	bind_textdomain_codeset(PACKAGE, "UTF-8");
 	textdomain(PACKAGE);
diff -ruN barebox-2012.02.0/scripts/kconfig/.gitignore barebox-2012.02.0-ccu2/scripts/kconfig/.gitignore
--- barebox-2012.02.0/scripts/kconfig/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-#
-# Generated files
-#
-config*
-lex.*.c
-*.tab.c
-*.tab.h
-zconf.hash.c
-*.moc
-lkc_defs.h
-gconf.glade.h
-*.pot
-*.mo
-
-#
-# configuration programs
-#
-conf
-mconf
-nconf
-qconf
-gconf
-kxgettext
diff -ruN barebox-2012.02.0/scripts/kconfig/kxgettext.c barebox-2012.02.0-ccu2/scripts/kconfig/kxgettext.c
--- barebox-2012.02.0/scripts/kconfig/kxgettext.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/kxgettext.c	2013-01-14 12:46:18.000000000 +0100
@@ -7,7 +7,6 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 static char *escape(const char* text, char *bf, int len)
diff -ruN barebox-2012.02.0/scripts/kconfig/lkc.h barebox-2012.02.0-ccu2/scripts/kconfig/lkc.h
--- barebox-2012.02.0/scripts/kconfig/lkc.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/lkc.h	2013-01-14 12:46:18.000000000 +0100
@@ -21,12 +21,7 @@
 extern "C" {
 #endif
 
-#ifdef LKC_DIRECT_LINK
 #define P(name,type,arg)	extern type name arg
-#else
-#include "lkc_defs.h"
-#define P(name,type,arg)	extern type (*name ## _p) arg
-#endif
 #include "lkc_proto.h"
 #undef P
 
@@ -68,9 +63,7 @@
 	enum symbol_type stype;
 };
 
-#ifdef YYDEBUG
 extern int zconfdebug;
-#endif
 
 int zconfparse(void);
 void zconfdump(FILE *out);
@@ -81,9 +74,6 @@
 int zconf_lineno(void);
 const char *zconf_curname(void);
 
-/* conf.c */
-void xfgets(char *str, int size, FILE *in);
-
 /* confdata.c */
 const char *conf_get_configname(void);
 const char *conf_get_autoconfig_name(void);
@@ -92,6 +82,11 @@
 void sym_add_change_count(int count);
 void conf_set_all_new_symbols(enum conf_def_mode mode);
 
+struct conf_printer {
+	void (*print_symbol)(FILE *, struct symbol *, const char *, void *);
+	void (*print_comment)(FILE *, const char *, void *);
+};
+
 /* confdata.c and expr.c */
 static inline void xfwrite(const void *str, size_t len, size_t count, FILE *out)
 {
@@ -99,9 +94,6 @@
 		fprintf(stderr, "\nError in writing or end of file.\n");
 }
 
-/* kconfig_load.c */
-void kconfig_load(void);
-
 /* menu.c */
 void _menu_init(void);
 void menu_warn(struct menu *menu, const char *fmt, ...);
diff -ruN barebox-2012.02.0/scripts/kconfig/lkc_proto.h barebox-2012.02.0-ccu2/scripts/kconfig/lkc_proto.h
--- barebox-2012.02.0/scripts/kconfig/lkc_proto.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/lkc_proto.h	2013-01-14 12:46:18.000000000 +0100
@@ -31,6 +31,7 @@
 P(sym_lookup,struct symbol *,(const char *name, int flags));
 P(sym_find,struct symbol *,(const char *name));
 P(sym_expand_string_value,const char *,(const char *in));
+P(sym_escape_string_value, const char *,(const char *in));
 P(sym_re_search,struct symbol **,(const char *pattern));
 P(sym_type_name,const char *,(enum symbol_type type));
 P(sym_calc_value,void,(struct symbol *sym));
diff -ruN barebox-2012.02.0/scripts/kconfig/lxdialog/BIG.FAT.WARNING barebox-2012.02.0-ccu2/scripts/kconfig/lxdialog/BIG.FAT.WARNING
--- barebox-2012.02.0/scripts/kconfig/lxdialog/BIG.FAT.WARNING	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/lxdialog/BIG.FAT.WARNING	2013-01-14 12:46:18.000000000 +0100
@@ -1,4 +1,4 @@
 This is NOT the official version of dialog.  This version has been
 significantly modified from the original.  It is for use by the Linux
-barebox configuration script.  Please do not bother Savio Lam with 
+kernel configuration script.  Please do not bother Savio Lam with 
 questions about this program.
diff -ruN barebox-2012.02.0/scripts/kconfig/lxdialog/.gitignore barebox-2012.02.0-ccu2/scripts/kconfig/lxdialog/.gitignore
--- barebox-2012.02.0/scripts/kconfig/lxdialog/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/lxdialog/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#
-# Generated files
-#
-lxdialog
diff -ruN barebox-2012.02.0/scripts/kconfig/lxdialog/textbox.c barebox-2012.02.0-ccu2/scripts/kconfig/lxdialog/textbox.c
--- barebox-2012.02.0/scripts/kconfig/lxdialog/textbox.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/lxdialog/textbox.c	2013-01-14 12:46:18.000000000 +0100
@@ -320,7 +320,6 @@
  */
 static void print_line(WINDOW * win, int row, int width)
 {
-	int y, x;
 	char *line;
 
 	line = get_line();
@@ -329,10 +328,10 @@
 	waddch(win, ' ');
 	waddnstr(win, line, MIN(strlen(line), width - 2));
 
-	getyx(win, y, x);
 	/* Clear 'residue' of previous line */
 #if OLD_NCURSES
 	{
+		int x = getcurx(win);
 		int i;
 		for (i = 0; i < width - x; i++)
 			waddch(win, ' ');
diff -ruN barebox-2012.02.0/scripts/kconfig/Makefile barebox-2012.02.0-ccu2/scripts/kconfig/Makefile
--- barebox-2012.02.0/scripts/kconfig/Makefile	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/Makefile	2013-01-14 12:46:18.000000000 +0100
@@ -33,17 +33,9 @@
 	$(Q)mkdir -p include/generated
 	$< --$@ $(Kconfig)
 
-# if no path is given, then use src directory to find file
-ifdef LSMOD
-LSMOD_F := $(LSMOD)
-ifeq ($(findstring /,$(LSMOD)),)
-  LSMOD_F := $(objtree)/$(LSMOD)
-endif
-endif
-
-localmodconfig: $(obj)/streamline_config.pl $(obj)/conf
+localyesconfig localmodconfig: $(obj)/streamline_config.pl $(obj)/conf
 	$(Q)mkdir -p include/generated
-	$(Q)perl $< $(srctree) $(Kconfig) $(LSMOD_F) > .tmp.config
+	$(Q)perl $< --$@ $(srctree) $(Kconfig) > .tmp.config
 	$(Q)if [ -f .config ]; then 					\
 			cmp -s .tmp.config .config ||			\
 			(mv -f .config .config.old.1;			\
@@ -56,35 +48,20 @@
 	fi
 	$(Q)rm -f .tmp.config
 
-localyesconfig: $(obj)/streamline_config.pl $(obj)/conf
-	$(Q)mkdir -p include/generated
-	$(Q)perl $< $(srctree) $(Kconfig) $(LSMOD_F) > .tmp.config
-	$(Q)sed -i s/=m/=y/ .tmp.config
-	$(Q)if [ -f .config ]; then					\
-			cmp -s .tmp.config .config ||			\
-			(mv -f .config .config.old.1;			\
-			 mv -f .tmp.config .config;			\
-			 $(obj)/conf --silentoldconfig $(Kconfig);	\
-			 mv -f .config.old.1 .config.old)		\
-	else								\
-			mv -f .tmp.config .config;			\
-			$(obj)/conf --silentoldconfig $(Kconfig);	\
-	fi
-	$(Q)rm -f .tmp.config
-
 # Create new linux.pot file
 # Adjust charset to UTF-8 in .po file to accept UTF-8 in Kconfig files
 # The symlink is used to repair a deficiency in arch/um
 update-po-config: $(obj)/kxgettext $(obj)/gconf.glade.h
 	$(Q)echo "  GEN config"
-	$(Q)xgettext --default-domain=linux              \
-	    --add-comments --keyword=_ --keyword=N_      \
-	    --from-code=UTF-8                            \
-	    --files-from=scripts/kconfig/POTFILES.in     \
+	$(Q)xgettext --default-domain=linux                         \
+	    --add-comments --keyword=_ --keyword=N_                 \
+	    --from-code=UTF-8                                       \
+	    --files-from=$(srctree)/scripts/kconfig/POTFILES.in     \
+	    --directory=$(srctree) --directory=$(objtree)           \
 	    --output $(obj)/config.pot
 	$(Q)sed -i s/CHARSET/UTF-8/ $(obj)/config.pot
-	$(Q)ln -fs Kconfig.i386 arch/um/Kconfig.arch
-	$(Q)(for i in `ls arch/*/Kconfig`;               \
+	$(Q)ln -fs Kconfig.x86 arch/um/Kconfig
+	$(Q)(for i in `ls $(srctree)/arch/*/Kconfig`;    \
 	    do                                           \
 		echo "  GEN $$i";                        \
 		$(obj)/kxgettext $$i                     \
@@ -92,7 +69,7 @@
 	    done )
 	$(Q)msguniq --sort-by-file --to-code=UTF-8 $(obj)/config.pot \
 	    --output $(obj)/linux.pot
-	$(Q)rm -f arch/um/Kconfig.arch
+	$(Q)rm -f $(srctree)/arch/um/Kconfig
 	$(Q)rm -f $(obj)/config.pot
 
 PHONY += allnoconfig allyesconfig allmodconfig alldefconfig randconfig
@@ -168,8 +145,11 @@
 mconf-objs     := mconf.o zconf.tab.o $(lxdialog)
 nconf-objs     := nconf.o zconf.tab.o nconf.gui.o
 kxgettext-objs	:= kxgettext.o zconf.tab.o
+qconf-cxxobjs	:= qconf.o
+qconf-objs	:= zconf.tab.o
+gconf-objs	:= gconf.o zconf.tab.o
 
-hostprogs-y := conf qconf gconf kxgettext
+hostprogs-y := conf
 
 ifeq ($(MAKECMDGOALS),nconfig)
 	hostprogs-y += nconf
@@ -179,6 +159,10 @@
 	hostprogs-y += mconf
 endif
 
+ifeq ($(MAKECMDGOALS),update-po-config)
+	hostprogs-y += kxgettext
+endif
+
 ifeq ($(MAKECMDGOALS),xconfig)
 	qconf-target := 1
 endif
@@ -188,16 +172,15 @@
 
 
 ifeq ($(qconf-target),1)
-qconf-cxxobjs	:= qconf.o
-qconf-objs	:= kconfig_load.o zconf.tab.o
+	hostprogs-y += qconf
 endif
 
 ifeq ($(gconf-target),1)
-gconf-objs	:= gconf.o kconfig_load.o zconf.tab.o
+	hostprogs-y += gconf
 endif
 
-clean-files	:= lkc_defs.h qconf.moc .tmp_qtcheck \
-		   .tmp_gtkcheck zconf.tab.c lex.zconf.c zconf.hash.c gconf.glade.h
+clean-files	:= qconf.moc .tmp_qtcheck .tmp_gtkcheck
+clean-files	+= zconf.tab.c zconf.lex.c zconf.hash.c gconf.glade.h
 clean-files     += mconf qconf gconf nconf
 clean-files     += config.pot linux.pot
 
@@ -213,15 +196,18 @@
 HOST_EXTRACFLAGS += $(shell $(CONFIG_SHELL) $(srctree)/$(src)/check.sh $(HOSTCC) $(HOSTCFLAGS))
 
 # generated files seem to need this to find local include files
-HOSTCFLAGS_lex.zconf.o	:= -I$(src)
+HOSTCFLAGS_zconf.lex.o	:= -I$(src)
 HOSTCFLAGS_zconf.tab.o	:= -I$(src)
 
-HOSTLOADLIBES_qconf	= $(KC_QT_LIBS) -ldl
-HOSTCXXFLAGS_qconf.o	= $(KC_QT_CFLAGS) -D LKC_DIRECT_LINK
+LEX_PREFIX_zconf	:= zconf
+YACC_PREFIX_zconf	:= zconf
 
-HOSTLOADLIBES_gconf	= `pkg-config --libs gtk+-2.0 gmodule-2.0 libglade-2.0` -ldl
+HOSTLOADLIBES_qconf	= $(KC_QT_LIBS)
+HOSTCXXFLAGS_qconf.o	= $(KC_QT_CFLAGS)
+
+HOSTLOADLIBES_gconf	= `pkg-config --libs gtk+-2.0 gmodule-2.0 libglade-2.0`
 HOSTCFLAGS_gconf.o	= `pkg-config --cflags gtk+-2.0 gmodule-2.0 libglade-2.0` \
-                          -D LKC_DIRECT_LINK
+                          -Wno-missing-prototypes
 
 HOSTLOADLIBES_mconf   = $(shell $(CONFIG_SHELL) $(check-lxdialog) -ldflags $(HOSTCC))
 
@@ -309,46 +295,15 @@
 	fi
 endif
 
-$(obj)/zconf.tab.o: $(obj)/lex.zconf.c $(obj)/zconf.hash.c
-
-$(obj)/kconfig_load.o: $(obj)/lkc_defs.h
-
-$(obj)/qconf.o: $(obj)/qconf.moc $(obj)/lkc_defs.h
+$(obj)/zconf.tab.o: $(obj)/zconf.lex.c $(obj)/zconf.hash.c
 
-$(obj)/gconf.o: $(obj)/lkc_defs.h
+$(obj)/qconf.o: $(obj)/qconf.moc
 
 $(obj)/%.moc: $(src)/%.h
 	$(KC_QT_MOC) -i $< -o $@
 
-$(obj)/lkc_defs.h: $(src)/lkc_proto.h
-	sed < $< > $@ 's/P(\([^,]*\),.*/#define \1 (\*\1_p)/'
-
 # Extract gconf menu items for I18N support
 $(obj)/gconf.glade.h: $(obj)/gconf.glade
-	intltool-extract --type=gettext/glade $(obj)/gconf.glade
-
-###
-# The following requires flex/bison/gperf
-# By default we use the _shipped versions, uncomment the following line if
-# you are modifying the flex/bison src.
-# LKC_GENPARSER := 1
-
-ifdef LKC_GENPARSER
-
-$(obj)/zconf.tab.c: $(src)/zconf.y
-$(obj)/lex.zconf.c: $(src)/zconf.l
-$(obj)/zconf.hash.c: $(src)/zconf.gperf
-
-%.tab.c: %.y
-	bison -l -b $* -p $(notdir $*) $<
-	cp $@ $@_shipped
-
-lex.%.c: %.l
-	flex -L -P$(notdir $*) -o$@ $<
-	cp $@ $@_shipped
-
-%.hash.c: %.gperf
-	gperf < $< > $@
-	cp $@ $@_shipped
+	$(Q)intltool-extract --type=gettext/glade --srcdir=$(srctree) \
+	$(obj)/gconf.glade
 
-endif
diff -ruN barebox-2012.02.0/scripts/kconfig/mconf.c barebox-2012.02.0-ccu2/scripts/kconfig/mconf.c
--- barebox-2012.02.0/scripts/kconfig/mconf.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/mconf.c	2013-01-14 12:46:18.000000000 +0100
@@ -15,10 +15,10 @@
 #include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
+#include <signal.h>
 #include <unistd.h>
 #include <locale.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 #include "lxdialog/dialog.h"
 
@@ -273,6 +273,7 @@
 static int child_count;
 static int single_menu_mode;
 static int show_all_options;
+static int saved_x, saved_y;
 
 static void conf(struct menu *menu);
 static void conf_choice(struct menu *menu);
@@ -793,9 +794,54 @@
 	}
 }
 
+static int handle_exit(void)
+{
+	int res;
+
+	dialog_clear();
+	if (conf_get_changed())
+		res = dialog_yesno(NULL,
+				   _("Do you wish to save your new configuration ?\n"
+				     "<ESC><ESC> to continue."),
+				   6, 60);
+	else
+		res = -1;
+
+	end_dialog(saved_x, saved_y);
+
+	switch (res) {
+	case 0:
+		if (conf_write(filename)) {
+			fprintf(stderr, _("\n\n"
+					  "Error while writing of the configuration.\n"
+					  "Your configuration changes were NOT saved."
+					  "\n\n"));
+			return 1;
+		}
+		/* fall through */
+	case -1:
+		printf(_("\n\n"
+			 "*** End of the configuration.\n"
+			 "*** Execute 'make' to start the build or try 'make help'."
+			 "\n\n"));
+		res = 0;
+		break;
+	default:
+		fprintf(stderr, _("\n\n"
+				  "Your configuration changes were NOT saved."
+				  "\n\n"));
+	}
+
+	return res;
+}
+
+static void sig_handler(int signo)
+{
+	exit(handle_exit());
+}
+
 int main(int ac, char **av)
 {
-	int saved_x, saved_y;
 	char *mode;
 	int res;
 
@@ -803,6 +849,8 @@
 	bindtextdomain(PACKAGE, LOCALEDIR);
 	textdomain(PACKAGE);
 
+	signal(SIGINT, sig_handler);
+
 	conf_parse(av[1]);
 	conf_read(NULL);
 
@@ -824,39 +872,9 @@
 	set_config_filename(conf_get_configname());
 	do {
 		conf(&rootmenu);
-		dialog_clear();
-		if (conf_get_changed())
-			res = dialog_yesno(NULL,
-					   _("Do you wish to save your "
-					     "new configuration?\n"
-					     "<ESC><ESC> to continue."),
-					   6, 60);
-		else
-			res = -1;
+		res = handle_exit();
 	} while (res == KEY_ESC);
-	end_dialog(saved_x, saved_y);
-
-	switch (res) {
-	case 0:
-		if (conf_write(filename)) {
-			fprintf(stderr, _("\n\n"
-				"Error while writing of the configuration.\n"
-				"Your configuration changes were NOT saved."
-				"\n\n"));
-			return 1;
-		}
-	case -1:
-		printf(_("\n\n"
-			"*** End of the configuration.\n"
-			"*** Execute 'make' to start the build or try 'make help'."
-			"\n\n"));
-		break;
-	default:
-		fprintf(stderr, _("\n\n"
-			"Your configuration changes were NOT saved."
-			"\n\n"));
-	}
 
-	return 0;
+	return res;
 }
 
diff -ruN barebox-2012.02.0/scripts/kconfig/menu.c barebox-2012.02.0-ccu2/scripts/kconfig/menu.c
--- barebox-2012.02.0/scripts/kconfig/menu.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/menu.c	2013-01-14 12:46:18.000000000 +0100
@@ -3,14 +3,14 @@
  * Released under the terms of the GNU GPL v2.0.
  */
 
+#include <ctype.h>
+#include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
-static const char nohelp_text[] = N_(
-	"There is no help available for this option.\n");
+static const char nohelp_text[] = "There is no help available for this option.";
 
 struct menu rootmenu;
 static struct menu **last_entry_ptr;
@@ -350,7 +350,7 @@
 			last_menu->next = NULL;
 		}
 
-		sym->dir_dep.expr = parent->dep;
+		sym->dir_dep.expr = expr_alloc_or(sym->dir_dep.expr, parent->dep);
 	}
 	for (menu = parent->list; menu; menu = menu->next) {
 		if (sym && sym_is_choice(sym) &&
@@ -594,16 +594,14 @@
 void menu_get_ext_help(struct menu *menu, struct gstr *help)
 {
 	struct symbol *sym = menu->sym;
+	const char *help_text = nohelp_text;
 
 	if (menu_has_help(menu)) {
-		if (sym->name) {
+		if (sym->name)
 			str_printf(help, "%s%s:\n\n", CONFIG_, sym->name);
-			str_append(help, _(menu_get_help(menu)));
-			str_append(help, "\n");
-		}
-	} else {
-		str_append(help, nohelp_text);
+		help_text = menu_get_help(menu);
 	}
+	str_printf(help, "%s\n", _(help_text));
 	if (sym)
 		get_symbol_str(help, sym);
 }
diff -ruN barebox-2012.02.0/scripts/kconfig/nconf.c barebox-2012.02.0-ccu2/scripts/kconfig/nconf.c
--- barebox-2012.02.0/scripts/kconfig/nconf.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/nconf.c	2013-01-14 12:46:18.000000000 +0100
@@ -7,7 +7,7 @@
  */
 #define _GNU_SOURCE
 #include <string.h>
-#define LKC_DIRECT_LINK
+
 #include "lkc.h"
 #include "nconf.h"
 #include <ctype.h>
@@ -182,8 +182,6 @@
 "This feature depends on another which\n"
 "has been configured as a module.\n"
 "As a result, this feature will be built as a module."),
-nohelp_text[] = N_(
-"There is no help available for this option.\n"),
 load_config_text[] = N_(
 "Enter the name of the configuration file you wish to load.\n"
 "Accept the name shown to restore the configuration you\n"
@@ -280,6 +278,9 @@
 /* the currently selected button */
 const char *current_instructions = menu_instructions;
 
+static char *dialog_input_result;
+static int dialog_input_result_len;
+
 static void conf(struct menu *menu);
 static void conf_choice(struct menu *menu);
 static void conf_string(struct menu *menu);
@@ -373,18 +374,18 @@
 	const int skip = 1;
 
 	for (i = 0; i < function_keys_num; i++) {
-		wattrset(main_window, attributes[FUNCTION_HIGHLIGHT]);
+		(void) wattrset(main_window, attributes[FUNCTION_HIGHLIGHT]);
 		mvwprintw(main_window, LINES-3, offset,
 				"%s",
 				function_keys[i].key_str);
-		wattrset(main_window, attributes[FUNCTION_TEXT]);
+		(void) wattrset(main_window, attributes[FUNCTION_TEXT]);
 		offset += strlen(function_keys[i].key_str);
 		mvwprintw(main_window, LINES-3,
 				offset, "%s",
 				function_keys[i].func);
 		offset += strlen(function_keys[i].func) + skip;
 	}
-	wattrset(main_window, attributes[NORMAL]);
+	(void) wattrset(main_window, attributes[NORMAL]);
 }
 
 /* help */
@@ -695,7 +696,6 @@
 {
 	struct symbol **sym_arr;
 	struct gstr res;
-	char dialog_input_result[100];
 	char *dialog_input;
 	int dres;
 again:
@@ -703,7 +703,7 @@
 			_("Search Configuration Parameter"),
 			_("Enter " CONFIG_ " (sub)string to search for "
 				"(with or without \"" CONFIG_ "\")"),
-			"", dialog_input_result, 99);
+			"", &dialog_input_result, &dialog_input_result_len);
 	switch (dres) {
 	case 0:
 		break;
@@ -953,16 +953,16 @@
 	current_instructions = instructions;
 
 	clear();
-	wattrset(main_window, attributes[NORMAL]);
+	(void) wattrset(main_window, attributes[NORMAL]);
 	print_in_middle(stdscr, 1, 0, COLS,
 			menu_backtitle,
 			attributes[MAIN_HEADING]);
 
-	wattrset(main_window, attributes[MAIN_MENU_BOX]);
+	(void) wattrset(main_window, attributes[MAIN_MENU_BOX]);
 	box(main_window, 0, 0);
-	wattrset(main_window, attributes[MAIN_MENU_HEADING]);
+	(void) wattrset(main_window, attributes[MAIN_MENU_HEADING]);
 	mvwprintw(main_window, 0, 3, " %s ", prompt);
-	wattrset(main_window, attributes[NORMAL]);
+	(void) wattrset(main_window, attributes[NORMAL]);
 
 	set_menu_items(curses_menu, curses_menu_items);
 
@@ -1067,7 +1067,6 @@
 	struct menu *submenu = 0;
 	const char *prompt = menu_get_prompt(menu);
 	struct symbol *sym;
-	struct menu *active_menu = NULL;
 	int res;
 	int current_index = 0;
 	int last_top_row = 0;
@@ -1152,13 +1151,9 @@
 			continue;
 
 		submenu = (struct menu *) item_data();
-		active_menu = (struct menu *)item_data();
 		if (!submenu || !menu_is_visible(submenu))
 			continue;
-		if (submenu)
-			sym = submenu->sym;
-		else
-			sym = NULL;
+		sym = submenu->sym;
 
 		switch (res) {
 		case ' ':
@@ -1222,20 +1217,13 @@
 
 static void show_help(struct menu *menu)
 {
-	struct gstr help = str_new();
+	struct gstr help;
 
-	if (menu && menu->sym && menu_has_help(menu)) {
-		if (menu->sym->name) {
-			str_printf(&help, "%s%s:\n\n", CONFIG_, menu->sym->name);
-			str_append(&help, _(menu_get_help(menu)));
-			str_append(&help, "\n");
-			get_symbol_str(&help, menu->sym);
-		} else {
-			str_append(&help, _(menu_get_help(menu)));
-		}
-	} else {
-		str_append(&help, nohelp_text);
-	}
+	if (!menu)
+		return;
+
+	help = str_new();
+	menu_get_ext_help(menu, &help);
 	show_scroll_win(main_window, _(menu_get_prompt(menu)), str_get(&help));
 	str_free(&help);
 }
@@ -1360,7 +1348,6 @@
 static void conf_string(struct menu *menu)
 {
 	const char *prompt = menu_get_prompt(menu);
-	char dialog_input_result[256];
 
 	while (1) {
 		int res;
@@ -1383,8 +1370,8 @@
 				prompt ? _(prompt) : _("Main Menu"),
 				heading,
 				sym_get_string_value(menu->sym),
-				dialog_input_result,
-				sizeof(dialog_input_result));
+				&dialog_input_result,
+				&dialog_input_result_len);
 		switch (res) {
 		case 0:
 			if (sym_set_string_value(menu->sym,
@@ -1404,14 +1391,13 @@
 
 static void conf_load(void)
 {
-	char dialog_input_result[256];
 	while (1) {
 		int res;
 		res = dialog_inputbox(main_window,
 				NULL, load_config_text,
 				filename,
-				dialog_input_result,
-				sizeof(dialog_input_result));
+				&dialog_input_result,
+				&dialog_input_result_len);
 		switch (res) {
 		case 0:
 			if (!dialog_input_result[0])
@@ -1436,14 +1422,13 @@
 
 static void conf_save(void)
 {
-	char dialog_input_result[256];
 	while (1) {
 		int res;
 		res = dialog_inputbox(main_window,
 				NULL, save_config_text,
 				filename,
-				dialog_input_result,
-				sizeof(dialog_input_result));
+				&dialog_input_result,
+				&dialog_input_result_len);
 		switch (res) {
 		case 0:
 			if (!dialog_input_result[0])
diff -ruN barebox-2012.02.0/scripts/kconfig/nconf.gui.c barebox-2012.02.0-ccu2/scripts/kconfig/nconf.gui.c
--- barebox-2012.02.0/scripts/kconfig/nconf.gui.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/nconf.gui.c	2013-01-14 12:46:18.000000000 +0100
@@ -356,7 +356,7 @@
 
 int dialog_inputbox(WINDOW *main_window,
 		const char *title, const char *prompt,
-		const char *init, char *result, int result_len)
+		const char *init, char **resultp, int *result_len)
 {
 	int prompt_lines = 0;
 	int prompt_width = 0;
@@ -367,7 +367,13 @@
 	int i, x, y;
 	int res = -1;
 	int cursor_position = strlen(init);
+	int cursor_form_win;
+	char *result = *resultp;
 
+	if (strlen(init)+1 > *result_len) {
+		*result_len = strlen(init)+1;
+		*resultp = result = realloc(result, *result_len);
+	}
 
 	/* find the widest line of msg: */
 	prompt_lines = get_line_no(prompt);
@@ -384,7 +390,7 @@
 	y = (LINES-(prompt_lines+4))/2;
 	x = (COLS-(prompt_width+4))/2;
 
-	strncpy(result, init, result_len);
+	strncpy(result, init, *result_len);
 
 	/* create the windows */
 	win = newwin(prompt_lines+6, prompt_width+7, y, x);
@@ -405,7 +411,9 @@
 	fill_window(prompt_win, prompt);
 
 	mvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");
-	mvwprintw(form_win, 0, 0, "%s", result);
+	cursor_form_win = min(cursor_position, prompt_width-1);
+	mvwprintw(form_win, 0, 0, "%s",
+		  result + cursor_position-cursor_form_win);
 
 	/* create panels */
 	panel = new_panel(win);
@@ -431,6 +439,8 @@
 						&result[cursor_position],
 						len-cursor_position+1);
 				cursor_position--;
+				cursor_form_win--;
+				len--;
 			}
 			break;
 		case KEY_DC:
@@ -438,38 +448,63 @@
 				memmove(&result[cursor_position],
 						&result[cursor_position+1],
 						len-cursor_position+1);
+				len--;
 			}
 			break;
 		case KEY_UP:
 		case KEY_RIGHT:
-			if (cursor_position < len &&
-			    cursor_position < min(result_len, prompt_width))
+			if (cursor_position < len) {
 				cursor_position++;
+				cursor_form_win++;
+			}
 			break;
 		case KEY_DOWN:
 		case KEY_LEFT:
-			if (cursor_position > 0)
+			if (cursor_position > 0) {
 				cursor_position--;
+				cursor_form_win--;
+			}
+			break;
+		case KEY_HOME:
+			cursor_position = 0;
+			cursor_form_win = 0;
+			break;
+		case KEY_END:
+			cursor_position = len;
+			cursor_form_win = min(cursor_position, prompt_width-1);
 			break;
 		default:
-			if ((isgraph(res) || isspace(res)) &&
-					len-2 < result_len) {
+			if ((isgraph(res) || isspace(res))) {
+				/* one for new char, one for '\0' */
+				if (len+2 > *result_len) {
+					*result_len = len+2;
+					*resultp = result = realloc(result,
+								*result_len);
+				}
 				/* insert the char at the proper position */
 				memmove(&result[cursor_position+1],
 						&result[cursor_position],
-						len+1);
+						len-cursor_position+1);
 				result[cursor_position] = res;
 				cursor_position++;
+				cursor_form_win++;
+				len++;
 			} else {
-				mvprintw(0, 0, "unknow key: %d\n", res);
+				mvprintw(0, 0, "unknown key: %d\n", res);
 			}
 			break;
 		}
+		if (cursor_form_win < 0)
+			cursor_form_win = 0;
+		else if (cursor_form_win > prompt_width-1)
+			cursor_form_win = prompt_width-1;
+
 		wmove(form_win, 0, 0);
 		wclrtoeol(form_win);
 		mvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");
-		mvwprintw(form_win, 0, 0, "%s", result);
-		wmove(form_win, 0, cursor_position);
+		mvwprintw(form_win, 0, 0, "%s",
+			result + cursor_position-cursor_form_win);
+		wmove(form_win, 0, cursor_form_win);
 		touchwin(win);
 		refresh_all_windows(main_window);
 
diff -ruN barebox-2012.02.0/scripts/kconfig/nconf.h barebox-2012.02.0-ccu2/scripts/kconfig/nconf.h
--- barebox-2012.02.0/scripts/kconfig/nconf.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/nconf.h	2013-01-14 12:46:18.000000000 +0100
@@ -89,7 +89,7 @@
 int btn_dialog(WINDOW *main_window, const char *msg, int btn_num, ...);
 int dialog_inputbox(WINDOW *main_window,
 		const char *title, const char *prompt,
-		const char *init, char *result, int result_len);
+		const char *init, char **resultp, int *result_len);
 void refresh_all_windows(WINDOW *main_window);
 void show_scroll_win(WINDOW *main_window,
 		const char *title,
diff -ruN barebox-2012.02.0/scripts/kconfig/qconf.cc barebox-2012.02.0-ccu2/scripts/kconfig/qconf.cc
--- barebox-2012.02.0/scripts/kconfig/qconf.cc	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/qconf.cc	2013-01-14 12:46:18.000000000 +0100
@@ -1478,10 +1478,13 @@
 	ConfigView::updateListAll();
 }
 
-void ConfigMainWindow::saveConfig(void)
+bool ConfigMainWindow::saveConfig(void)
 {
-	if (conf_write(NULL))
+	if (conf_write(NULL)) {
 		QMessageBox::information(this, "qconf", _("Unable to save configuration!"));
+		return false;
+	}
+	return true;
 }
 
 void ConfigMainWindow::saveConfigAs(void)
@@ -1489,8 +1492,7 @@
 	QString s = Q3FileDialog::getSaveFileName(conf_get_configname(), NULL, this);
 	if (s.isNull())
 		return;
-	if (conf_write(QFile::encodeName(s)))
-		QMessageBox::information(this, "qconf", _("Unable to save configuration!"));
+	saveConfig();
 }
 
 void ConfigMainWindow::searchConfig(void)
@@ -1643,7 +1645,11 @@
 	mb.setButtonText(QMessageBox::Cancel, _("Cancel Exit"));
 	switch (mb.exec()) {
 	case QMessageBox::Yes:
-		conf_write(NULL);
+		if (saveConfig())
+			e->accept();
+		else
+			e->ignore();
+		break;
 	case QMessageBox::No:
 		e->accept();
 		break;
@@ -1673,7 +1679,7 @@
 void ConfigMainWindow::showAbout(void)
 {
 	static const QString str = _("qconf is Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>.\n\n"
-		"Bug reports and feature request can also be entered at http://bugzilla.barebox.org/\n");
+		"Bug reports and feature request can also be entered at http://bugzilla.kernel.org/\n");
 
 	QMessageBox::information(this, "qconf", str);
 }
@@ -1746,10 +1752,6 @@
 	bindtextdomain(PACKAGE, LOCALEDIR);
 	textdomain(PACKAGE);
 
-#ifndef LKC_DIRECT_LINK
-	kconfig_load();
-#endif
-
 	progname = av[0];
 	configApp = new QApplication(ac, av);
 	if (ac > 1 && av[1][0] == '-') {
diff -ruN barebox-2012.02.0/scripts/kconfig/qconf.h barebox-2012.02.0-ccu2/scripts/kconfig/qconf.h
--- barebox-2012.02.0/scripts/kconfig/qconf.h	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/qconf.h	2013-01-14 12:46:18.000000000 +0100
@@ -311,7 +311,7 @@
 	void listFocusChanged(void);
 	void goBack(void);
 	void loadConfig(void);
-	void saveConfig(void);
+	bool saveConfig(void);
 	void saveConfigAs(void);
 	void searchConfig(void);
 	void showSingleView(void);
diff -ruN barebox-2012.02.0/scripts/kconfig/streamline_config.pl barebox-2012.02.0-ccu2/scripts/kconfig/streamline_config.pl
--- barebox-2012.02.0/scripts/kconfig/streamline_config.pl	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/streamline_config.pl	2013-01-14 12:46:18.000000000 +0100
@@ -1,6 +1,6 @@
 #!/usr/bin/perl -w
 #
-# Copywrite 2005-2009 - Steven Rostedt
+# Copyright 2005-2009 - Steven Rostedt
 # Licensed under the terms of the GNU GPL License version 2
 #
 #  It's simple enough to figure out how this works.
@@ -8,7 +8,7 @@
 #
 # What it does?
 #
-#   If you have installed a Linux barebox from a distribution
+#   If you have installed a Linux kernel from a distribution
 #   that turns on way too many modules than you need, and
 #   you only want the modules you use, then this program
 #   is perfect for you.
@@ -18,9 +18,9 @@
 #
 # Howto:
 #
-#  1. Boot up the barebox that you want to stream line the config on.
+#  1. Boot up the kernel that you want to stream line the config on.
 #  2. Change directory to the directory holding the source of the
-#       barebox that you just booted.
+#       kernel that you just booted.
 #  3. Copy the configuraton file to this directory as .config
 #  4. Have all your devices that you need modules for connected and
 #      operational (make sure that their corresponding modules are loaded)
@@ -30,7 +30,7 @@
 #  7. copy the config_strip file to .config
 #  8. Run "make oldconfig"
 #
-#  Now your barebox is ready to be built with only the modules that
+#  Now your kernel is ready to be built with only the modules that
 #  are loaded.
 #
 # Here's what I did with my Debian distribution.
@@ -43,6 +43,7 @@
 #    make oldconfig
 #
 use strict;
+use Getopt::Long;
 
 my $config = ".config";
 
@@ -73,17 +74,17 @@
 	    "test" => "scripts/extract-ikconfig",
 	},
 	{
-	    "file" => "/lib/modules/$uname/barebox/barebox/configs.ko",
+	    "file" => "/lib/modules/$uname/kernel/kernel/configs.ko",
 	    "exec" => "scripts/extract-ikconfig",
 	    "test" => "scripts/extract-ikconfig",
 	},
 	{
-	    "file" => "barebox/configs.ko",
+	    "file" => "kernel/configs.ko",
 	    "exec" => "scripts/extract-ikconfig",
 	    "test" => "scripts/extract-ikconfig",
 	},
 	{
-	    "file" => "barebox/configs.o",
+	    "file" => "kernel/configs.o",
 	    "exec" => "scripts/extract-ikconfig",
 	    "test" => "scripts/extract-ikconfig",
 	},
@@ -112,10 +113,17 @@
 
 find_config;
 
+# Parse options
+my $localmodconfig = 0;
+my $localyesconfig = 0;
+
+GetOptions("localmodconfig" => \$localmodconfig,
+	   "localyesconfig" => \$localyesconfig);
+
 # Get the build source and top level Kconfig file (passed in)
 my $ksource = $ARGV[0];
 my $kconfig = $ARGV[1];
-my $lsmod_file = $ARGV[2];
+my $lsmod_file = $ENV{'LSMOD'};
 
 my @makefiles = `find $ksource -name Makefile 2>/dev/null`;
 chomp @makefiles;
@@ -296,7 +304,11 @@
 
 if (defined($lsmod_file)) {
     if ( ! -f $lsmod_file) {
-	die "$lsmod_file not found";
+	if ( -f $ENV{'objtree'}."/".$lsmod_file) {
+	    $lsmod_file = $ENV{'objtree'}."/".$lsmod_file;
+	} else {
+		die "$lsmod_file not found";
+	}
     }
     if ( -x $lsmod_file) {
 	# the file is executable, run it
@@ -421,7 +433,11 @@
 
     if (/^(CONFIG.*)=(m|y)/) {
 	if (defined($configs{$1})) {
-	    $setconfigs{$1} = $2;
+	    if ($localyesconfig) {
+	        $setconfigs{$1} = 'y';
+	    } else {
+	        $setconfigs{$1} = $2;
+	    }
 	} elsif ($2 eq "m") {
 	    print "# $1 is not set\n";
 	    next;
diff -ruN barebox-2012.02.0/scripts/kconfig/symbol.c barebox-2012.02.0-ccu2/scripts/kconfig/symbol.c
--- barebox-2012.02.0/scripts/kconfig/symbol.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/symbol.c	2013-01-14 12:46:18.000000000 +0100
@@ -9,7 +9,6 @@
 #include <regex.h>
 #include <sys/utsname.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 struct symbol symbol_yes = {
@@ -751,7 +750,8 @@
 		case no:
 			return "n";
 		case mod:
-			return "m";
+			sym_calc_value(modules_sym);
+			return (modules_sym->curr.tri == no) ? "n" : "m";
 		case yes:
 			return "y";
 		}
@@ -893,6 +893,49 @@
 	return res;
 }
 
+const char *sym_escape_string_value(const char *in)
+{
+	const char *p;
+	size_t reslen;
+	char *res;
+	size_t l;
+
+	reslen = strlen(in) + strlen("\"\"") + 1;
+
+	p = in;
+	for (;;) {
+		l = strcspn(p, "\"\\");
+		p += l;
+
+		if (p[0] == '\0')
+			break;
+
+		reslen++;
+		p++;
+	}
+
+	res = malloc(reslen);
+	res[0] = '\0';
+
+	strcat(res, "\"");
+
+	p = in;
+	for (;;) {
+		l = strcspn(p, "\"\\");
+		strncat(res, p, l);
+		p += l;
+
+		if (p[0] == '\0')
+			break;
+
+		strcat(res, "\\");
+		strncat(res, p++, 1);
+	}
+
+	strcat(res, "\"");
+	return res;
+}
+
 struct symbol **sym_re_search(const char *pattern)
 {
 	struct symbol *sym, **sym_arr = NULL;
diff -ruN barebox-2012.02.0/scripts/kconfig/util.c barebox-2012.02.0-ccu2/scripts/kconfig/util.c
--- barebox-2012.02.0/scripts/kconfig/util.c	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/util.c	2013-01-14 12:46:18.000000000 +0100
@@ -5,6 +5,8 @@
  * Released under the terms of the GNU GPL v2.0.
  */
 
+#include <stdarg.h>
+#include <stdlib.h>
 #include <string.h>
 #include "lkc.h"
 
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.gperf barebox-2012.02.0-ccu2/scripts/kconfig/zconf.gperf
--- barebox-2012.02.0/scripts/kconfig/zconf.gperf	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.gperf	2013-01-14 12:46:18.000000000 +0100
@@ -9,7 +9,7 @@
 
 struct kconf_id;
 
-static struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+static const struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
 
 %%
 mainmenu,	T_MAINMENU,	TF_COMMAND
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.hash.c barebox-2012.02.0-ccu2/scripts/kconfig/zconf.hash.c
--- barebox-2012.02.0/scripts/kconfig/zconf.hash.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.hash.c	2013-01-14 12:46:18.000000000 +0100
@@ -0,0 +1,286 @@
+/* ANSI-C code produced by gperf version 3.0.4 */
+/* Command-line: gperf -t --output-file scripts/kconfig/zconf.hash.c_shipped -a -C -E -g -k '1,3,$' -p -t scripts/kconfig/zconf.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 10 "scripts/kconfig/zconf.gperf"
+struct kconf_id;
+
+static const struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 71, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 25, 25,
+       0,  0,  0,  5,  0,  0, 73, 73,  5,  0,
+      10,  5, 45, 73, 20, 20,  0, 15, 15, 73,
+      20, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("if")];
+    char kconf_id_strings_str3[sizeof("int")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str7[sizeof("default")];
+    char kconf_id_strings_str8[sizeof("tristate")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str12[sizeof("def_tristate")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("defconfig_list")];
+    char kconf_id_strings_str17[sizeof("on")];
+    char kconf_id_strings_str18[sizeof("optional")];
+    char kconf_id_strings_str21[sizeof("option")];
+    char kconf_id_strings_str22[sizeof("endmenu")];
+    char kconf_id_strings_str23[sizeof("mainmenu")];
+    char kconf_id_strings_str25[sizeof("menuconfig")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("select")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str33[sizeof("env")];
+    char kconf_id_strings_str35[sizeof("range")];
+    char kconf_id_strings_str36[sizeof("choice")];
+    char kconf_id_strings_str39[sizeof("bool")];
+    char kconf_id_strings_str41[sizeof("source")];
+    char kconf_id_strings_str42[sizeof("visible")];
+    char kconf_id_strings_str43[sizeof("hex")];
+    char kconf_id_strings_str46[sizeof("config")];
+    char kconf_id_strings_str47[sizeof("boolean")];
+    char kconf_id_strings_str51[sizeof("string")];
+    char kconf_id_strings_str54[sizeof("help")];
+    char kconf_id_strings_str56[sizeof("prompt")];
+    char kconf_id_strings_str72[sizeof("depends")];
+  };
+static const struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "if",
+    "int",
+    "endif",
+    "default",
+    "tristate",
+    "endchoice",
+    "def_tristate",
+    "def_bool",
+    "defconfig_list",
+    "on",
+    "optional",
+    "option",
+    "endmenu",
+    "mainmenu",
+    "menuconfig",
+    "modules",
+    "menu",
+    "select",
+    "comment",
+    "env",
+    "range",
+    "choice",
+    "bool",
+    "source",
+    "visible",
+    "hex",
+    "config",
+    "boolean",
+    "string",
+    "help",
+    "prompt",
+    "depends"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 32,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 72
+    };
+
+  static const struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+#line 25 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_IF,		TF_COMMAND|TF_PARAM},
+#line 36 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1},
+#line 26 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {-1},
+#line 29 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+#line 31 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+#line 20 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 32 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+#line 35 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+#line 45 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1}, {-1},
+#line 43 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,		T_ON,		TF_PARAM},
+#line 28 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_OPTIONAL,	TF_COMMAND},
+      {-1}, {-1},
+#line 42 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_OPTION,	TF_COMMAND},
+#line 17 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,	T_ENDMENU,	TF_COMMAND},
+#line 15 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,	T_MAINMENU,	TF_COMMAND},
+      {-1},
+#line 23 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str25,	T_MENUCONFIG,	TF_COMMAND},
+      {-1},
+#line 44 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {-1},
+#line 16 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+#line 39 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SELECT,	TF_COMMAND},
+#line 21 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+#line 46 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+#line 40 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,		T_RANGE,	TF_COMMAND},
+#line 19 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_CHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 33 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str39,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+#line 18 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_SOURCE,	TF_COMMAND},
+#line 41 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_VISIBLE,	TF_COMMAND},
+#line 37 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str43,		T_TYPE,		TF_COMMAND, S_HEX},
+      {-1}, {-1},
+#line 22 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_CONFIG,	TF_COMMAND},
+#line 34 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str47,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1}, {-1}, {-1},
+#line 38 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_TYPE,		TF_COMMAND, S_STRING},
+      {-1}, {-1},
+#line 24 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str54,		T_HELP,		TF_COMMAND},
+      {-1},
+#line 30 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str56,		T_PROMPT,	TF_COMMAND},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+#line 27 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str72,	T_DEPENDS,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+#line 47 "scripts/kconfig/zconf.gperf"
+
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.hash.c_shipped barebox-2012.02.0-ccu2/scripts/kconfig/zconf.hash.c_shipped
--- barebox-2012.02.0/scripts/kconfig/zconf.hash.c_shipped	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.hash.c_shipped	2013-01-14 12:46:18.000000000 +0100
@@ -1,6 +1,5 @@
-/* ANSI-C code produced by gperf version 3.0.3 */
-/* Command-line: gperf  */
-/* Computed positions: -k'1,3' */
+/* ANSI-C code produced by gperf version 3.0.4 */
+/* Command-line: gperf -t --output-file scripts/kconfig/zconf.hash.c_shipped -a -C -E -g -k '1,3,$' -p -t scripts/kconfig/zconf.gperf  */
 
 #if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
       && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
@@ -29,10 +28,11 @@
 #error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
 #endif
 
+#line 10 "scripts/kconfig/zconf.gperf"
 struct kconf_id;
 
-static struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
-/* maximum key range = 50, duplicates = 0 */
+static const struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 71, duplicates = 0 */
 
 #ifdef __GNUC__
 __inline
@@ -44,34 +44,34 @@
 static unsigned int
 kconf_id_hash (register const char *str, register unsigned int len)
 {
-  static unsigned char asso_values[] =
+  static const unsigned char asso_values[] =
     {
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 40,  5,
-       0,  0,  5, 52,  0, 20, 52, 52, 10, 20,
-       5,  0, 35, 52,  0, 30,  0, 15,  0, 52,
-      15, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
-      52, 52, 52, 52, 52, 52
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 25, 25,
+       0,  0,  0,  5,  0,  0, 73, 73,  5,  0,
+      10,  5, 45, 73, 20, 20,  0, 15, 15, 73,
+      20, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73
     };
   register int hval = len;
 
@@ -85,87 +85,87 @@
         hval += asso_values[(unsigned char)str[0]];
         break;
     }
-  return hval;
+  return hval + asso_values[(unsigned char)str[len - 1]];
 }
 
 struct kconf_id_strings_t
   {
-    char kconf_id_strings_str2[sizeof("on")];
-    char kconf_id_strings_str3[sizeof("env")];
+    char kconf_id_strings_str2[sizeof("if")];
+    char kconf_id_strings_str3[sizeof("int")];
     char kconf_id_strings_str5[sizeof("endif")];
-    char kconf_id_strings_str6[sizeof("option")];
-    char kconf_id_strings_str7[sizeof("endmenu")];
-    char kconf_id_strings_str8[sizeof("optional")];
+    char kconf_id_strings_str7[sizeof("default")];
+    char kconf_id_strings_str8[sizeof("tristate")];
     char kconf_id_strings_str9[sizeof("endchoice")];
-    char kconf_id_strings_str10[sizeof("range")];
-    char kconf_id_strings_str11[sizeof("choice")];
-    char kconf_id_strings_str12[sizeof("default")];
+    char kconf_id_strings_str12[sizeof("def_tristate")];
     char kconf_id_strings_str13[sizeof("def_bool")];
-    char kconf_id_strings_str14[sizeof("help")];
-    char kconf_id_strings_str16[sizeof("config")];
-    char kconf_id_strings_str17[sizeof("def_tristate")];
-    char kconf_id_strings_str18[sizeof("hex")];
-    char kconf_id_strings_str19[sizeof("defconfig_list")];
-    char kconf_id_strings_str22[sizeof("if")];
-    char kconf_id_strings_str23[sizeof("int")];
+    char kconf_id_strings_str14[sizeof("defconfig_list")];
+    char kconf_id_strings_str17[sizeof("on")];
+    char kconf_id_strings_str18[sizeof("optional")];
+    char kconf_id_strings_str21[sizeof("option")];
+    char kconf_id_strings_str22[sizeof("endmenu")];
+    char kconf_id_strings_str23[sizeof("mainmenu")];
+    char kconf_id_strings_str25[sizeof("menuconfig")];
     char kconf_id_strings_str27[sizeof("modules")];
-    char kconf_id_strings_str28[sizeof("tristate")];
     char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("select")];
     char kconf_id_strings_str32[sizeof("comment")];
-    char kconf_id_strings_str35[sizeof("menuconfig")];
-    char kconf_id_strings_str36[sizeof("string")];
-    char kconf_id_strings_str37[sizeof("visible")];
-    char kconf_id_strings_str41[sizeof("prompt")];
-    char kconf_id_strings_str42[sizeof("depends")];
-    char kconf_id_strings_str44[sizeof("bool")];
-    char kconf_id_strings_str46[sizeof("select")];
+    char kconf_id_strings_str33[sizeof("env")];
+    char kconf_id_strings_str35[sizeof("range")];
+    char kconf_id_strings_str36[sizeof("choice")];
+    char kconf_id_strings_str39[sizeof("bool")];
+    char kconf_id_strings_str41[sizeof("source")];
+    char kconf_id_strings_str42[sizeof("visible")];
+    char kconf_id_strings_str43[sizeof("hex")];
+    char kconf_id_strings_str46[sizeof("config")];
     char kconf_id_strings_str47[sizeof("boolean")];
-    char kconf_id_strings_str48[sizeof("mainmenu")];
-    char kconf_id_strings_str51[sizeof("source")];
+    char kconf_id_strings_str51[sizeof("string")];
+    char kconf_id_strings_str54[sizeof("help")];
+    char kconf_id_strings_str56[sizeof("prompt")];
+    char kconf_id_strings_str72[sizeof("depends")];
   };
-static struct kconf_id_strings_t kconf_id_strings_contents =
+static const struct kconf_id_strings_t kconf_id_strings_contents =
   {
-    "on",
-    "env",
+    "if",
+    "int",
     "endif",
-    "option",
-    "endmenu",
-    "optional",
-    "endchoice",
-    "range",
-    "choice",
     "default",
-    "def_bool",
-    "help",
-    "config",
+    "tristate",
+    "endchoice",
     "def_tristate",
-    "hex",
+    "def_bool",
     "defconfig_list",
-    "if",
-    "int",
+    "on",
+    "optional",
+    "option",
+    "endmenu",
+    "mainmenu",
+    "menuconfig",
     "modules",
-    "tristate",
     "menu",
+    "select",
     "comment",
-    "menuconfig",
-    "string",
-    "visible",
-    "prompt",
-    "depends",
+    "env",
+    "range",
+    "choice",
     "bool",
-    "select",
+    "source",
+    "visible",
+    "hex",
+    "config",
     "boolean",
-    "mainmenu",
-    "source"
+    "string",
+    "help",
+    "prompt",
+    "depends"
   };
 #define kconf_id_strings ((const char *) &kconf_id_strings_contents)
 #ifdef __GNUC__
 __inline
-#ifdef __GNUC_STDC_INLINE__
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
 __attribute__ ((__gnu_inline__))
 #endif
 #endif
-struct kconf_id *
+const struct kconf_id *
 kconf_id_lookup (register const char *str, register unsigned int len)
 {
   enum
@@ -174,54 +174,94 @@
       MIN_WORD_LENGTH = 2,
       MAX_WORD_LENGTH = 14,
       MIN_HASH_VALUE = 2,
-      MAX_HASH_VALUE = 51
+      MAX_HASH_VALUE = 72
     };
 
-  static struct kconf_id wordlist[] =
+  static const struct kconf_id wordlist[] =
     {
       {-1}, {-1},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_ON,		TF_PARAM},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_OPT_ENV,	TF_OPTION},
+#line 25 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_IF,		TF_COMMAND|TF_PARAM},
+#line 36 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_TYPE,		TF_COMMAND, S_INT},
       {-1},
+#line 26 "scripts/kconfig/zconf.gperf"
       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str6,		T_OPTION,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_ENDMENU,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_OPTIONAL,	TF_COMMAND},
+      {-1},
+#line 29 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+#line 31 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+#line 20 "scripts/kconfig/zconf.gperf"
       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str10,		T_RANGE,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str11,		T_CHOICE,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+      {-1}, {-1},
+#line 32 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+#line 35 "scripts/kconfig/zconf.gperf"
       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,		T_HELP,		TF_COMMAND},
-      {-1},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str16,		T_CONFIG,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,		T_TYPE,		TF_COMMAND, S_HEX},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str19,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+#line 45 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
       {-1}, {-1},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,		T_IF,		TF_COMMAND|TF_PARAM},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,		T_TYPE,		TF_COMMAND, S_INT},
-      {-1}, {-1}, {-1},
+#line 43 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,		T_ON,		TF_PARAM},
+#line 28 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_OPTIONAL,	TF_COMMAND},
+      {-1}, {-1},
+#line 42 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_OPTION,	TF_COMMAND},
+#line 17 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,	T_ENDMENU,	TF_COMMAND},
+#line 15 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,	T_MAINMENU,	TF_COMMAND},
+      {-1},
+#line 23 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str25,	T_MENUCONFIG,	TF_COMMAND},
+      {-1},
+#line 44 "scripts/kconfig/zconf.gperf"
       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+      {-1},
+#line 16 "scripts/kconfig/zconf.gperf"
       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
-      {-1}, {-1},
+      {-1},
+#line 39 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SELECT,	TF_COMMAND},
+#line 21 "scripts/kconfig/zconf.gperf"
       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
-      {-1}, {-1},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,	T_MENUCONFIG,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_TYPE,		TF_COMMAND, S_STRING},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str37,	T_VISIBLE,	TF_COMMAND},
-      {-1}, {-1}, {-1},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_PROMPT,	TF_COMMAND},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_DEPENDS,	TF_COMMAND},
+#line 46 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_OPT_ENV,	TF_OPTION},
       {-1},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str44,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+#line 40 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,		T_RANGE,	TF_COMMAND},
+#line 19 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_CHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 33 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str39,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
       {-1},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_SELECT,	TF_COMMAND},
+#line 18 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_SOURCE,	TF_COMMAND},
+#line 41 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_VISIBLE,	TF_COMMAND},
+#line 37 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str43,		T_TYPE,		TF_COMMAND, S_HEX},
+      {-1}, {-1},
+#line 22 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_CONFIG,	TF_COMMAND},
+#line 34 "scripts/kconfig/zconf.gperf"
       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str47,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str48,	T_MAINMENU,	TF_COMMAND},
+      {-1}, {-1}, {-1},
+#line 38 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_TYPE,		TF_COMMAND, S_STRING},
       {-1}, {-1},
-      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_SOURCE,	TF_COMMAND}
+#line 24 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str54,		T_HELP,		TF_COMMAND},
+      {-1},
+#line 30 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str56,		T_PROMPT,	TF_COMMAND},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+#line 27 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str72,	T_DEPENDS,	TF_COMMAND}
     };
 
   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
@@ -242,4 +282,5 @@
     }
   return 0;
 }
+#line 47 "scripts/kconfig/zconf.gperf"
 
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.l barebox-2012.02.0-ccu2/scripts/kconfig/zconf.l
--- barebox-2012.02.0/scripts/kconfig/zconf.l	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.l	2013-01-14 12:46:18.000000000 +0100
@@ -1,5 +1,5 @@
-%option backup nostdinit noyywrap never-interactive full ecs
-%option 8bit backup nodefault perf-report perf-report
+%option nostdinit noyywrap never-interactive full ecs
+%option 8bit nodefault perf-report perf-report
 %option noinput
 %x COMMAND HELP STRING PARAM
 %{
@@ -14,7 +14,6 @@
 #include <string.h>
 #include <unistd.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 #define START_STRSIZE	16
@@ -96,7 +95,7 @@
 
 <COMMAND>{
 	{n}+	{
-		struct kconf_id *id = kconf_id_lookup(yytext, yyleng);
+		const struct kconf_id *id = kconf_id_lookup(yytext, yyleng);
 		BEGIN(PARAM);
 		current_pos.file = current_file;
 		current_pos.lineno = current_file->lineno;
@@ -132,7 +131,7 @@
 	\n	BEGIN(INITIAL); current_file->lineno++; return T_EOL;
 	---	/* ignore */
 	({n}|[-/.])+	{
-		struct kconf_id *id = kconf_id_lookup(yytext, yyleng);
+		const struct kconf_id *id = kconf_id_lookup(yytext, yyleng);
 		if (id && id->flags & TF_PARAM) {
 			zconflval.id = id;
 			return id->token;
@@ -262,7 +261,7 @@
  * ./name
  * $(srctree)/name
  * The latter is used when srctree is separate from objtree
- * when compiling the barebox.
+ * when compiling the kernel.
  * Return NULL if file is not found.
  */
 FILE *zconf_fopen(const char *name)
@@ -294,11 +293,11 @@
 
 	current_file = file_lookup(name);
 	current_file->lineno = 1;
-	current_file->flags = FILE_BUSY;
 }
 
 void zconf_nextfile(const char *name)
 {
+	struct file *iter;
 	struct file *file = file_lookup(name);
 	struct buffer *buf = malloc(sizeof(*buf));
 	memset(buf, 0, sizeof(*buf));
@@ -314,18 +313,25 @@
 	buf->parent = current_buf;
 	current_buf = buf;
 
-	if (file->flags & FILE_BUSY) {
-		printf("%s:%d: do not source '%s' from itself\n",
-		       zconf_curname(), zconf_lineno(), name);
-		exit(1);
-	}
-	if (file->flags & FILE_SCANNED) {
-		printf("%s:%d: file '%s' is already sourced from '%s'\n",
-		       zconf_curname(), zconf_lineno(), name,
-		       file->parent->name);
-		exit(1);
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
 	}
-	file->flags |= FILE_BUSY;
 	file->lineno = 1;
 	file->parent = current_file;
 	current_file = file;
@@ -335,8 +341,6 @@
 {
 	struct buffer *parent;
 
-	current_file->flags |= FILE_SCANNED;
-	current_file->flags &= ~FILE_BUSY;
 	current_file = current_file->parent;
 
 	parent = current_buf->parent;
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.lex.c barebox-2012.02.0-ccu2/scripts/kconfig/zconf.lex.c
--- barebox-2012.02.0/scripts/kconfig/zconf.lex.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.lex.c	2013-01-14 12:46:18.000000000 +0100
@@ -0,0 +1,2420 @@
+
+#line 3 "scripts/kconfig/zconf.lex.c_shipped"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(file->name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n",
+		    zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
+	}
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.lex.c_shipped barebox-2012.02.0-ccu2/scripts/kconfig/zconf.lex.c_shipped
--- barebox-2012.02.0/scripts/kconfig/zconf.lex.c_shipped	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.lex.c_shipped	2013-01-14 12:46:18.000000000 +0100
@@ -0,0 +1,2420 @@
+
+#line 3 "scripts/kconfig/zconf.lex.c_shipped"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(file->name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n",
+		    zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
+	}
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.tab.c barebox-2012.02.0-ccu2/scripts/kconfig/zconf.tab.c
--- barebox-2012.02.0/scripts/kconfig/zconf.tab.c	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.tab.c	2013-01-14 12:46:18.000000000 +0100
@@ -0,0 +1,2504 @@
+/* A Bison parser, made by GNU Bison 2.4.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
+   2009, 2010 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[SYMBOL_HASHSIZE];
+
+static struct menu *current_menu, *current_entry;
+
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_VISIBLE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	const struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   290
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  50
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  118
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  191
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    11,    13,    14,    17,    20,
+      23,    26,    31,    36,    40,    42,    44,    46,    48,    50,
+      52,    54,    56,    58,    60,    62,    64,    66,    68,    72,
+      75,    79,    82,    86,    89,    90,    93,    96,    99,   102,
+     105,   108,   112,   117,   122,   127,   133,   137,   138,   142,
+     143,   146,   150,   153,   155,   159,   160,   163,   166,   169,
+     172,   175,   180,   184,   187,   192,   193,   196,   200,   202,
+     206,   207,   210,   213,   216,   220,   224,   228,   230,   234,
+     235,   238,   241,   244,   248,   252,   255,   258,   261,   262,
+     265,   268,   271,   276,   277,   280,   283,   286,   287,   290,
+     292,   294,   297,   300,   303,   305,   308,   309,   312,   314,
+     318,   322,   326,   329,   333,   337,   339,   341,   342
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      37,     0,    -1,    81,    38,    -1,    38,    -1,    63,    39,
+      -1,    39,    -1,    -1,    39,    41,    -1,    39,    55,    -1,
+      39,    67,    -1,    39,    80,    -1,    39,    26,     1,    31,
+      -1,    39,    40,     1,    31,    -1,    39,     1,    31,    -1,
+      16,    -1,    18,    -1,    19,    -1,    21,    -1,    17,    -1,
+      22,    -1,    20,    -1,    23,    -1,    31,    -1,    61,    -1,
+      71,    -1,    44,    -1,    46,    -1,    69,    -1,    26,     1,
+      31,    -1,     1,    31,    -1,    10,    26,    31,    -1,    43,
+      47,    -1,    11,    26,    31,    -1,    45,    47,    -1,    -1,
+      47,    48,    -1,    47,    49,    -1,    47,    75,    -1,    47,
+      73,    -1,    47,    42,    -1,    47,    31,    -1,    19,    78,
+      31,    -1,    18,    79,    82,    31,    -1,    20,    83,    82,
+      31,    -1,    21,    26,    82,    31,    -1,    22,    84,    84,
+      82,    31,    -1,    24,    50,    31,    -1,    -1,    50,    26,
+      51,    -1,    -1,    34,    79,    -1,     7,    85,    31,    -1,
+      52,    56,    -1,    80,    -1,    53,    58,    54,    -1,    -1,
+      56,    57,    -1,    56,    75,    -1,    56,    73,    -1,    56,
+      31,    -1,    56,    42,    -1,    18,    79,    82,    31,    -1,
+      19,    78,    31,    -1,    17,    31,    -1,    20,    26,    82,
+      31,    -1,    -1,    58,    41,    -1,    14,    83,    81,    -1,
+      80,    -1,    59,    62,    60,    -1,    -1,    62,    41,    -1,
+      62,    67,    -1,    62,    55,    -1,     3,    79,    81,    -1,
+       4,    79,    31,    -1,    64,    76,    74,    -1,    80,    -1,
+      65,    68,    66,    -1,    -1,    68,    41,    -1,    68,    67,
+      -1,    68,    55,    -1,     6,    79,    31,    -1,     9,    79,
+      31,    -1,    70,    74,    -1,    12,    31,    -1,    72,    13,
+      -1,    -1,    74,    75,    -1,    74,    31,    -1,    74,    42,
+      -1,    16,    25,    83,    31,    -1,    -1,    76,    77,    -1,
+      76,    31,    -1,    23,    82,    -1,    -1,    79,    82,    -1,
+      26,    -1,    27,    -1,     5,    31,    -1,     8,    31,    -1,
+      15,    31,    -1,    31,    -1,    81,    31,    -1,    -1,    14,
+      83,    -1,    84,    -1,    84,    34,    84,    -1,    84,    28,
+      84,    -1,    30,    83,    29,    -1,    35,    83,    -1,    83,
+      32,    83,    -1,    83,    33,    83,    -1,    26,    -1,    27,
+      -1,    -1,    26,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   104,   104,   104,   106,   106,   108,   110,   111,   112,
+     113,   114,   115,   119,   123,   123,   123,   123,   123,   123,
+     123,   123,   127,   128,   129,   130,   131,   132,   136,   137,
+     143,   151,   157,   165,   175,   177,   178,   179,   180,   181,
+     182,   185,   193,   199,   209,   215,   221,   224,   226,   237,
+     238,   243,   252,   257,   265,   268,   270,   271,   272,   273,
+     274,   277,   283,   294,   300,   310,   312,   317,   325,   333,
+     336,   338,   339,   340,   345,   352,   359,   364,   372,   375,
+     377,   378,   379,   382,   390,   397,   404,   410,   417,   419,
+     420,   421,   424,   432,   434,   435,   438,   445,   447,   452,
+     453,   456,   457,   458,   462,   463,   466,   467,   470,   471,
+     472,   473,   474,   475,   476,   479,   480,   483,   484
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_VISIBLE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "start", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "mainmenu_stmt", "menu",
+  "menu_entry", "menu_end", "menu_stmt", "menu_block", "source_stmt",
+  "comment", "comment_stmt", "help_start", "help", "depends_list",
+  "depends", "visibility_list", "visible", "prompt_stmt_opt", "prompt",
+  "end", "nl", "if_expr", "expr", "symbol", "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    39,    39,    39,    39,
+      39,    39,    39,    39,    40,    40,    40,    40,    40,    40,
+      40,    40,    41,    41,    41,    41,    41,    41,    42,    42,
+      43,    44,    45,    46,    47,    47,    47,    47,    47,    47,
+      47,    48,    48,    48,    48,    48,    49,    50,    50,    51,
+      51,    52,    53,    54,    55,    56,    56,    56,    56,    56,
+      56,    57,    57,    57,    57,    58,    58,    59,    60,    61,
+      62,    62,    62,    62,    63,    64,    65,    66,    67,    68,
+      68,    68,    68,    69,    70,    71,    72,    73,    74,    74,
+      74,    74,    75,    76,    76,    76,    77,    78,    78,    79,
+      79,    80,    80,    80,    81,    81,    82,    82,    83,    83,
+      83,    83,    83,    83,    83,    84,    84,    85,    85
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     2,     1,     0,     2,     2,     2,
+       2,     4,     4,     3,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     2,
+       3,     2,     3,     2,     0,     2,     2,     2,     2,     2,
+       2,     3,     4,     4,     4,     5,     3,     0,     3,     0,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     2,
+       2,     4,     3,     2,     4,     0,     2,     3,     1,     3,
+       0,     2,     2,     2,     3,     3,     3,     1,     3,     0,
+       2,     2,     2,     3,     3,     2,     2,     2,     0,     2,
+       2,     2,     4,     0,     2,     2,     2,     0,     2,     1,
+       1,     2,     2,     2,     1,     2,     0,     2,     1,     3,
+       3,     3,     2,     3,     3,     1,     1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       6,     0,   104,     0,     3,     0,     6,     6,    99,   100,
+       0,     1,     0,     0,     0,     0,   117,     0,     0,     0,
+       0,     0,     0,    14,    18,    15,    16,    20,    17,    19,
+      21,     0,    22,     0,     7,    34,    25,    34,    26,    55,
+      65,     8,    70,    23,    93,    79,     9,    27,    88,    24,
+      10,     0,   105,     2,    74,    13,     0,   101,     0,   118,
+       0,   102,     0,     0,     0,   115,   116,     0,     0,     0,
+     108,   103,     0,     0,     0,     0,     0,     0,     0,    88,
+       0,     0,    75,    83,    51,    84,    30,    32,     0,   112,
+       0,     0,    67,     0,     0,    11,    12,     0,     0,     0,
+       0,    97,     0,     0,     0,    47,     0,    40,    39,    35,
+      36,     0,    38,    37,     0,     0,    97,     0,    59,    60,
+      56,    58,    57,    66,    54,    53,    71,    73,    69,    72,
+      68,   106,    95,     0,    94,    80,    82,    78,    81,    77,
+      90,    91,    89,   111,   113,   114,   110,   109,    29,    86,
+       0,   106,     0,   106,   106,   106,     0,     0,     0,    87,
+      63,   106,     0,   106,     0,    96,     0,     0,    41,    98,
+       0,     0,   106,    49,    46,    28,     0,    62,     0,   107,
+      92,    42,    43,    44,     0,     0,    48,    61,    64,    45,
+      50
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     5,    33,    34,   108,    35,    36,    37,
+      38,    74,   109,   110,   157,   186,    39,    40,   124,    41,
+      76,   120,    77,    42,   128,    43,    78,     6,    44,    45,
+     137,    46,    80,    47,    48,    49,   111,   112,    81,   113,
+      79,   134,   152,   153,    50,     7,   165,    69,    70,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int16 yypact[] =
+{
+       4,    42,   -90,    96,   -90,   111,   -90,    15,   -90,   -90,
+      75,   -90,    82,    42,   104,    42,   110,   107,    42,   115,
+     125,    -4,   121,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   162,   -90,   163,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   139,   -90,   -90,   138,   -90,   142,   -90,   143,   -90,
+     152,   -90,   164,   167,   168,   -90,   -90,    -4,    -4,    77,
+     -18,   -90,   177,   185,    33,    71,   195,   247,   236,    -2,
+     236,   171,   -90,   -90,   -90,   -90,   -90,   -90,    41,   -90,
+      -4,    -4,   138,    97,    97,   -90,   -90,   186,   187,   194,
+      42,    42,    -4,   196,    97,   -90,   219,   -90,   -90,   -90,
+     -90,   210,   -90,   -90,   204,    42,    42,   199,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   222,   -90,   223,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   215,   -90,   -90,   -90,   -90,   -90,
+      -4,   222,   228,   222,    -5,   222,    97,    35,   229,   -90,
+     -90,   222,   232,   222,    -4,   -90,   135,   233,   -90,   -90,
+     234,   235,   222,   240,   -90,   -90,   237,   -90,   239,   -13,
+     -90,   -90,   -90,   -90,   244,    42,   -90,   -90,   -90,   -90,
+     -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -90,   -90,   269,   271,   -90,    23,   -70,   -90,   -90,   -90,
+     -90,   243,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -48,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -20,   -90,   -90,   -90,   -90,   -90,   206,   205,   -68,
+     -90,   -90,   169,    -1,    27,    -7,   118,   -66,   -89,   -90
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -86
+static const yytype_int16 yytable[] =
+{
+      10,    88,    89,    54,   146,   147,   119,     1,   122,   164,
+      93,   141,    56,   142,    58,   156,    94,    62,     1,    90,
+      91,   131,    65,    66,   144,   145,    67,    90,    91,   132,
+     127,    68,   136,   -31,    97,     2,   154,   -31,   -31,   -31,
+     -31,   -31,   -31,   -31,   -31,    98,    52,   -31,   -31,    99,
+     -31,   100,   101,   102,   103,   104,   -31,   105,   129,   106,
+     138,   173,    92,   141,   107,   142,   174,   172,     8,     9,
+     143,   -33,    97,    90,    91,   -33,   -33,   -33,   -33,   -33,
+     -33,   -33,   -33,    98,   166,   -33,   -33,    99,   -33,   100,
+     101,   102,   103,   104,   -33,   105,    11,   106,   179,   151,
+     123,   126,   107,   135,   125,   130,     2,   139,     2,    90,
+      91,    -5,    12,    55,   161,    13,    14,    15,    16,    17,
+      18,    19,    20,    65,    66,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    57,    59,    31,    61,    -4,
+      12,    63,    32,    13,    14,    15,    16,    17,    18,    19,
+      20,    64,    71,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    72,    73,    31,   180,    90,    91,    52,
+      32,   -85,    97,    82,    83,   -85,   -85,   -85,   -85,   -85,
+     -85,   -85,   -85,    84,   190,   -85,   -85,    99,   -85,   -85,
+     -85,   -85,   -85,   -85,   -85,    85,    97,   106,    86,    87,
+     -52,   -52,   140,   -52,   -52,   -52,   -52,    98,    95,   -52,
+     -52,    99,   114,   115,   116,   117,    96,   148,   149,   150,
+     158,   106,   155,   159,    97,   163,   118,   -76,   -76,   -76,
+     -76,   -76,   -76,   -76,   -76,   160,   164,   -76,   -76,    99,
+      13,    14,    15,    16,    17,    18,    19,    20,    91,   106,
+      21,    22,    14,    15,   140,    17,    18,    19,    20,   168,
+     175,    21,    22,   177,   181,   182,   183,    32,   187,   167,
+     188,   169,   170,   171,   185,   189,    53,    51,    32,   176,
+      75,   178,   121,     0,   133,   162,     0,     0,     0,     0,
+     184
+};
+
+static const yytype_int16 yycheck[] =
+{
+       1,    67,    68,    10,    93,    94,    76,     3,    76,    14,
+      28,    81,    13,    81,    15,   104,    34,    18,     3,    32,
+      33,    23,    26,    27,    90,    91,    30,    32,    33,    31,
+      78,    35,    80,     0,     1,    31,   102,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    78,    26,
+      80,    26,    69,   133,    31,   133,    31,   156,    26,    27,
+      29,     0,     1,    32,    33,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   150,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,     0,    26,   164,   100,
+      77,    78,    31,    80,    77,    78,    31,    80,    31,    32,
+      33,     0,     1,    31,   115,     4,     5,     6,     7,     8,
+       9,    10,    11,    26,    27,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,    26,    26,    31,     0,
+       1,    26,    31,     4,     5,     6,     7,     8,     9,    10,
+      11,    26,    31,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     1,     1,    26,    31,    32,    33,    31,
+      31,     0,     1,    31,    31,     4,     5,     6,     7,     8,
+       9,    10,    11,    31,   185,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,     1,    26,    31,    31,
+       5,     6,    31,     8,     9,    10,    11,    12,    31,    14,
+      15,    16,    17,    18,    19,    20,    31,    31,    31,    25,
+       1,    26,    26,    13,     1,    26,    31,     4,     5,     6,
+       7,     8,     9,    10,    11,    31,    14,    14,    15,    16,
+       4,     5,     6,     7,     8,     9,    10,    11,    33,    26,
+      14,    15,     5,     6,    31,     8,     9,    10,    11,    31,
+      31,    14,    15,    31,    31,    31,    31,    31,    31,   151,
+      31,   153,   154,   155,    34,    31,     7,     6,    31,   161,
+      37,   163,    76,    -1,    79,   116,    -1,    -1,    -1,    -1,
+     172
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    31,    37,    38,    39,    63,    81,    26,    27,
+      79,     0,     1,     4,     5,     6,     7,     8,     9,    10,
+      11,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    26,    31,    40,    41,    43,    44,    45,    46,    52,
+      53,    55,    59,    61,    64,    65,    67,    69,    70,    71,
+      80,    39,    31,    38,    81,    31,    79,    31,    79,    26,
+      85,    31,    79,    26,    26,    26,    27,    30,    35,    83,
+      84,    31,     1,     1,    47,    47,    56,    58,    62,    76,
+      68,    74,    31,    31,    31,    31,    31,    31,    83,    83,
+      32,    33,    81,    28,    34,    31,    31,     1,    12,    16,
+      18,    19,    20,    21,    22,    24,    26,    31,    42,    48,
+      49,    72,    73,    75,    17,    18,    19,    20,    31,    42,
+      57,    73,    75,    41,    54,    80,    41,    55,    60,    67,
+      80,    23,    31,    74,    77,    41,    55,    66,    67,    80,
+      31,    42,    75,    29,    83,    83,    84,    84,    31,    31,
+      25,    79,    78,    79,    83,    26,    84,    50,     1,    13,
+      31,    79,    78,    26,    14,    82,    83,    82,    31,    82,
+      82,    82,    84,    26,    31,    31,    82,    31,    82,    83,
+      31,    31,    31,    31,    82,    34,    51,    31,    31,    31,
+      79
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 53: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 59: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 65: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 10:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 11:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 12:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+;}
+    break;
+
+  case 13:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 28:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+    break;
+
+  case 29:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 30:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 31:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 32:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 33:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 43:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+;}
+    break;
+
+  case 44:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 48:
+
+    {
+	const struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 49:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 50:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+    break;
+
+  case 51:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 52:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 53:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 61:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 62:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 63:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 64:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 67:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 68:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 74:
+
+    {
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+;}
+    break;
+
+  case 75:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 76:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 77:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 83:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 84:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 85:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 86:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 87:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 92:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 96:
+
+    {
+	menu_add_visibility((yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 98:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 101:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 102:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 103:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 107:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 110:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 111:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 112:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 113:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 114:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 115:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 116:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 117:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	_menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+
+	rootmenu.prompt->text = _(rootmenu.prompt->text);
+	rootmenu.prompt->text = sym_expand_string_value(rootmenu.prompt->text);
+
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+        }
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	case T_VISIBLE:		return "visible";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "\nchoice\n");
+	else
+		fprintf(out, "\nconfig %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		case P_SELECT:
+			fputs( "  select ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_RANGE:
+			fputs( "  range ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_MENU:
+			fputs( "  menu ", out);
+			print_quoted_string(out, prop->text);
+			fputc('\n', out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "zconf.lex.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.tab.c_shipped barebox-2012.02.0-ccu2/scripts/kconfig/zconf.tab.c_shipped
--- barebox-2012.02.0/scripts/kconfig/zconf.tab.c_shipped	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.tab.c_shipped	2013-01-14 12:46:18.000000000 +0100
@@ -1,10 +1,9 @@
-
-/* A Bison parser, made by GNU Bison 2.4.1.  */
+/* A Bison parser, made by GNU Bison 2.4.3.  */
 
 /* Skeleton implementation for Bison's Yacc-like parsers in C
    
-      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
+   2009, 2010 Free Software Foundation, Inc.
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -46,7 +45,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.4.1"
+#define YYBISON_VERSION "2.4.3"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -88,7 +87,6 @@
 #include <string.h>
 #include <stdbool.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 #define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
@@ -102,22 +100,18 @@
 static void zconfprint(const char *err, ...);
 static void zconf_error(const char *err, ...);
 static void zconferror(const char *err);
-static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken);
 
 struct symbol *symbol_hash[SYMBOL_HASHSIZE];
 
 static struct menu *current_menu, *current_entry;
 
-#define YYDEBUG 0
-#if YYDEBUG
-#define YYERROR_VERBOSE
-#endif
 
 
 
 /* Enabling traces.  */
 #ifndef YYDEBUG
-# define YYDEBUG 0
+# define YYDEBUG 1
 #endif
 
 /* Enabling verbose error messages.  */
@@ -188,7 +182,7 @@
 	struct symbol *symbol;
 	struct expr *expr;
 	struct menu *menu;
-	struct kconf_id *id;
+	const struct kconf_id *id;
 
 
 
@@ -255,7 +249,7 @@
 #define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
 
 #ifndef YY_
-# if YYENABLE_NLS
+# if defined YYENABLE_NLS && YYENABLE_NLS
 #  if ENABLE_NLS
 #   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
 #   define YY_(msgid) dgettext ("bison-runtime", msgid)
@@ -535,18 +529,18 @@
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const yytype_uint16 yyrline[] =
 {
-       0,   108,   108,   108,   110,   110,   112,   114,   115,   116,
-     117,   118,   119,   123,   127,   127,   127,   127,   127,   127,
-     127,   127,   131,   132,   133,   134,   135,   136,   140,   141,
-     147,   155,   161,   169,   179,   181,   182,   183,   184,   185,
-     186,   189,   197,   203,   213,   219,   225,   228,   230,   241,
-     242,   247,   256,   261,   269,   272,   274,   275,   276,   277,
-     278,   281,   287,   298,   304,   314,   316,   321,   329,   337,
-     340,   342,   343,   344,   349,   356,   363,   368,   376,   379,
-     381,   382,   383,   386,   394,   401,   408,   414,   421,   423,
-     424,   425,   428,   436,   438,   439,   442,   449,   451,   456,
-     457,   460,   461,   462,   466,   467,   470,   471,   474,   475,
-     476,   477,   478,   479,   480,   483,   484,   487,   488
+       0,   104,   104,   104,   106,   106,   108,   110,   111,   112,
+     113,   114,   115,   119,   123,   123,   123,   123,   123,   123,
+     123,   123,   127,   128,   129,   130,   131,   132,   136,   137,
+     143,   151,   157,   165,   175,   177,   178,   179,   180,   181,
+     182,   185,   193,   199,   209,   215,   221,   224,   226,   237,
+     238,   243,   252,   257,   265,   268,   270,   271,   272,   273,
+     274,   277,   283,   294,   300,   310,   312,   317,   325,   333,
+     336,   338,   339,   340,   345,   352,   359,   364,   372,   375,
+     377,   378,   379,   382,   390,   397,   404,   410,   417,   419,
+     420,   421,   424,   432,   434,   435,   438,   445,   447,   452,
+     453,   456,   457,   458,   462,   463,   466,   467,   470,   471,
+     472,   473,   474,   475,   476,   479,   480,   483,   484
 };
 #endif
 
@@ -806,9 +800,18 @@
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
 
 #define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
@@ -865,7 +868,7 @@
    we won't break user code: when these are the locations we know.  */
 
 #ifndef YY_LOCATION_PRINT
-# if YYLTYPE_IS_TRIVIAL
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
 #  define YY_LOCATION_PRINT(File, Loc)			\
      fprintf (File, "%d.%d-%d.%d",			\
 	      (Loc).first_line, (Loc).first_column,	\
@@ -1753,7 +1756,7 @@
   case 48:
 
     {
-	struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	const struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
 	if (id && id->flags & TF_OPTION)
 		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
 	else
@@ -2258,10 +2261,8 @@
 	modules_sym->flags |= SYMBOL_AUTO;
 	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
 
-#if YYDEBUG
 	if (getenv("ZCONF_DEBUG"))
 		zconfdebug = 1;
-#endif
 	zconfparse();
 	if (zconfnerrs)
 		exit(1);
@@ -2300,7 +2301,7 @@
 	return "<token>";
 }
 
-static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken)
 {
 	if (id->token != endtoken) {
 		zconf_error("unexpected '%s' within %s block",
@@ -2345,9 +2346,7 @@
 
 static void zconferror(const char *err)
 {
-#if YYDEBUG
 	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
-#endif
 }
 
 static void print_quoted_string(FILE *out, const char *str)
@@ -2496,7 +2495,7 @@
 	}
 }
 
-#include "lex.zconf.c"
+#include "zconf.lex.c"
 #include "util.c"
 #include "confdata.c"
 #include "expr.c"
Binary files barebox-2012.02.0/scripts/kconfig/zconf.tab.o and barebox-2012.02.0-ccu2/scripts/kconfig/zconf.tab.o differ
diff -ruN barebox-2012.02.0/scripts/kconfig/.zconf.tab.o.cmd barebox-2012.02.0-ccu2/scripts/kconfig/.zconf.tab.o.cmd
--- barebox-2012.02.0/scripts/kconfig/.zconf.tab.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/.zconf.tab.o.cmd	2013-02-14 16:06:36.000000000 +0100
@@ -0,0 +1,89 @@
+cmd_scripts/kconfig/zconf.tab.o := gcc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c
+
+deps_scripts/kconfig/zconf.tab.o := \
+  scripts/kconfig/zconf.tab.c \
+  /usr/include/ctype.h \
+  /usr/include/features.h \
+  /usr/include/bits/predefs.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-64.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/xlocale.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stdarg.h \
+  /usr/include/stdio.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stddef.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/stdlib.h \
+  /usr/include/sys/types.h \
+  /usr/include/time.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/alloca.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include/stdbool.h \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/.h) \
+    $(wildcard include/config/list.h) \
+  scripts/kconfig/expr.h \
+  /usr/include/libintl.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  scripts/kconfig/lkc_proto.h \
+  scripts/kconfig/zconf.hash.c \
+  scripts/kconfig/zconf.lex.c \
+  /usr/include/errno.h \
+  /usr/include/bits/errno.h \
+  /usr/include/linux/errno.h \
+  /usr/include/asm/errno.h \
+  /usr/include/asm-generic/errno.h \
+  /usr/include/asm-generic/errno-base.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/limits.h \
+  /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed/syslimits.h \
+  /usr/include/limits.h \
+  /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h \
+  /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  scripts/kconfig/util.c \
+  scripts/kconfig/confdata.c \
+    $(wildcard include/config/config.h) \
+    $(wildcard include/config/autoconfig.h) \
+    $(wildcard include/config/overwriteconfig.h) \
+    $(wildcard include/config/autoheader.h) \
+    $(wildcard include/config/tristate.h) \
+  /usr/include/sys/stat.h \
+  /usr/include/bits/stat.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  scripts/kconfig/expr.c \
+  scripts/kconfig/symbol.c \
+  /usr/include/regex.h \
+  /usr/include/gnu/option-groups.h \
+  /usr/include/sys/utsname.h \
+  /usr/include/bits/utsname.h \
+  scripts/kconfig/menu.c \
+
+scripts/kconfig/zconf.tab.o: $(deps_scripts/kconfig/zconf.tab.o)
+
+$(deps_scripts/kconfig/zconf.tab.o):
diff -ruN barebox-2012.02.0/scripts/kconfig/zconf.y barebox-2012.02.0-ccu2/scripts/kconfig/zconf.y
--- barebox-2012.02.0/scripts/kconfig/zconf.y	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/kconfig/zconf.y	2013-01-14 12:46:18.000000000 +0100
@@ -11,7 +11,6 @@
 #include <string.h>
 #include <stdbool.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 #define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
@@ -25,16 +24,12 @@
 static void zconfprint(const char *err, ...);
 static void zconf_error(const char *err, ...);
 static void zconferror(const char *err);
-static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken);
 
 struct symbol *symbol_hash[SYMBOL_HASHSIZE];
 
 static struct menu *current_menu, *current_entry;
 
-#define YYDEBUG 0
-#if YYDEBUG
-#define YYERROR_VERBOSE
-#endif
 %}
 %expect 30
 
@@ -45,7 +40,7 @@
 	struct symbol *symbol;
 	struct expr *expr;
 	struct menu *menu;
-	struct kconf_id *id;
+	const struct kconf_id *id;
 }
 
 %token <id>T_MAINMENU
@@ -229,7 +224,7 @@
 	  /* empty */
 	| symbol_option_list T_WORD symbol_option_arg
 {
-	struct kconf_id *id = kconf_id_lookup($2, strlen($2));
+	const struct kconf_id *id = kconf_id_lookup($2, strlen($2));
 	if (id && id->flags & TF_OPTION)
 		menu_add_option(id->token, $3);
 	else
@@ -503,10 +498,8 @@
 	modules_sym->flags |= SYMBOL_AUTO;
 	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
 
-#if YYDEBUG
 	if (getenv("ZCONF_DEBUG"))
 		zconfdebug = 1;
-#endif
 	zconfparse();
 	if (zconfnerrs)
 		exit(1);
@@ -545,7 +538,7 @@
 	return "<token>";
 }
 
-static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken)
 {
 	if (id->token != endtoken) {
 		zconf_error("unexpected '%s' within %s block",
@@ -590,9 +583,7 @@
 
 static void zconferror(const char *err)
 {
-#if YYDEBUG
 	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
-#endif
 }
 
 static void print_quoted_string(FILE *out, const char *str)
@@ -741,7 +732,7 @@
 	}
 }
 
-#include "lex.zconf.c"
+#include "zconf.lex.c"
 #include "util.c"
 #include "confdata.c"
 #include "expr.c"
diff -ruN barebox-2012.02.0/scripts/mod/.gitignore barebox-2012.02.0-ccu2/scripts/mod/.gitignore
--- barebox-2012.02.0/scripts/mod/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/mod/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-elfconfig.h
-mk_elfconfig
-modpost
diff -ruN barebox-2012.02.0/scripts/setupmbr/.gitignore barebox-2012.02.0-ccu2/scripts/setupmbr/.gitignore
--- barebox-2012.02.0/scripts/setupmbr/.gitignore	2012-02-06 12:55:01.000000000 +0100
+++ barebox-2012.02.0-ccu2/scripts/setupmbr/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-setupmbr
